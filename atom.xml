<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KuoZ&#39;s blog</title>
  
  
  <link href="http://cv-elevation.github.io/atom.xml" rel="self"/>
  
  <link href="http://cv-elevation.github.io/"/>
  <updated>2025-07-23T11:03:42.635Z</updated>
  <id>http://cv-elevation.github.io/</id>
  
  <author>
    <name>KuoZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis之多级缓存</title>
    <link href="http://cv-elevation.github.io/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://cv-elevation.github.io/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2025-07-23T11:01:55.000Z</published>
    <updated>2025-07-23T11:03:42.635Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis之多级缓存——亿级流量方案</h1><h2 id="序言">序言</h2><p>传统缓存问题：</p><p>传统缓存一般是请求到达Tomcat后，Tomcat先查询Redis缓存，如果<strong>未命中</strong>则查询数据库。存在下面问题：</p><ol><li>请求要经过Tomcat服务器，Tomcat的性能成为整个并发缓存的瓶颈</li><li>如果Redis缓存失效，会对数据库产生冲击</li></ol><p>多级缓存</p><p>充分利用各环节，分别添加缓存，减轻Tomcat的压力</p><p>客户端缓存-&gt;NGINX本地缓存-&gt;Redis-&gt;Tomcat-&gt;DB</p><p>其中Nginx缓存是业务Nginx，通常部署为集群，再由专门的Nginx做反向代理</p><h2 id="JVM进程缓存">JVM进程缓存</h2><p>Caffeine技术</p><p>缓存驱逐策略：</p><ul><li>基于容量、基于时间、基于引用</li></ul><p>实现效果：</p><ul><li>第一次查询走数据库，然后就会放入缓存，之后查询就走缓存</li></ul><h2 id="Lua语法">Lua语法</h2><p>轻量小巧的脚本语言</p><p>数据类型</p><p>nil、boolean、number、string、function、table、type函数</p><p>变量</p><p>声明变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> var_name = var_value</span><br><span class="line">#数组</span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;c++&#x27;</span>&#125;</span><br><span class="line">#map</span><br><span class="line"><span class="keyword">local</span> map = &#123;name = <span class="string">&#x27;Jack&#x27;</span>,age = <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>访问数组，下标从一开始arr[1]</p><p>访问Map，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">map.name</span><br></pre></td></tr></table></figure><p>循环遍历</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;lua&#x27;</span>,<span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index,value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">    prinr(key,value)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name</span><span class="params">(para)</span></span></span><br><span class="line">    <span class="comment">---</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>条件控制</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    <span class="comment">---</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">---</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="多级缓存">多级缓存</h2><h3 id="配置nginx">配置nginx</h3><ol><li><p>OpenResty是基于Nginx的高性能Web平台</p></li><li><p>OpenResty使用流程类似于Nginx的使用</p></li><li><p>监听路径类似于Response<br>Lua文件类似于Service层</p></li><li><p>请求参数处理，不同参数格式有相应解析代码</p></li></ol><h3 id="nginx查询Tomcat">nginx查询Tomcat</h3><p>小规律：服务器前三位地址相同，第四位换为1</p><p>nginx提供了内部API用以发送http请求</p><p>Tomcat集群的负载均衡</p><p>保证缓存一直生效，同一路径访问同一服务器</p><p>修改负载均衡算法由轮询改为Hash算法来直接匹配</p><h3 id="添加Redis缓存">添加Redis缓存</h3><p>冷启动：服务器初启动时，没有缓存，此时查询会都导向数据库，带来较大的数据库压力</p><p>缓存预热：利用大数据统计热点数据，将热点数据存到缓存</p><h3 id="实现nginx优先查询Redis缓存：">实现nginx优先查询Redis缓存：</h3><p>OpenResty如何操作Redis？</p><p>OpenResty提供了操作Redis的模块，大概模块如下：</p><ul><li><p>封装函数，从Redis读取数据并返回</p></li><li><p>引入Redis模块，并初始化Redis模块</p></li><li><p>封装函数，释放Redis连接，其实是放入连接池</p></li></ul><h3 id="Nginx本地缓存">Nginx本地缓存</h3><p>利用shared dict开启词典</p><p>修改查询逻辑，加入缓存业务</p><h2 id="缓存同步">缓存同步</h2><p>三种方式</p><ol><li>设置有效期</li><li>同步双写，在修改数据的同时直接修改缓存</li><li>异步通知，改数据库时发事件通知，相关服务进行监听到通知后修改缓存</li></ol><p>监听mysql，使用MQ/canal实现</p><p>canal基于mysql的主从模式，canal伪装为mysql的一个slave节点完成通知</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis之多级缓存——亿级流量方案&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;传统缓存问题：&lt;/p&gt;
&lt;p&gt;传统缓存一般是请求到达Tomcat后，Tomcat先查询Redis缓存，如果&lt;strong&gt;未命中&lt;/strong&gt;则查询数据库。存在下面问题：&lt;/</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://cv-elevation.github.io/tags/Redis/"/>
    
    <category term="lua" scheme="http://cv-elevation.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存——Redis高级篇</title>
    <link href="http://cv-elevation.github.io/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    <id>http://cv-elevation.github.io/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/</id>
    <published>2025-07-20T16:55:44.000Z</published>
    <updated>2025-07-20T16:58:49.844Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式缓存——Redis高级篇</h1><p>单节点Redis问题</p><ol><li>数据丢失问题：实现Redis数据持久化</li><li>并发能力问题：搭建主从集群，实现读写分离</li><li>故障恢复问题：Redis哨兵，实现健康检测和自动恢复</li><li>存储能力问题：搭建分片集群，利用插槽机制实现动态扩容</li></ol><h2 id="一、持久化">一、持久化</h2><h3 id="方式之一：RDB持久化">方式之一：RDB持久化</h3><p>RDB全称RedisDatabaseBackup file（Redis数据备份文件）</p><p>有两个命令可以进行RDB持久化</p><ol><li>save命令：由主进程执行RDB，会阻塞所有命令</li><li>bgsave命令：开子进程执行RDB，避免主进程受影响</li></ol><p>默认Redis停机时会执行一次RDB</p><p>（停机≠宕机）</p><p>可以通过修改redis.conf文件来配置相关的RDB参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="comment">#900秒内由1次修改，就会执行bgsave。参数可以进行修改</span></span><br><span class="line"><span class="comment">#是否压缩，建议不开启，压缩也会消耗CPU，磁盘的话相对不值钱</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment">#RDB文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment">#文件保存的路径目录</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure><p><strong>bgsave流程</strong></p><p>bgsave开始时会fork主进程得到子进程（在fork过程中主进程会被阻塞），子进程共享主进程的内存数据。fork后主进程可以正常读写，子进程会读取内存数据并写入RDB文件。</p><p>如果只是这样可能会有脏数据的问题，就是说在子进程读的时候主进程可能更改了数据。</p><p>要理解这个问题，需要理解内存结构。</p><p><img src="https://cdn.jsdelivr.net/gh/CV-Elevation/imgHub/article_img/image-20250719194405703.png" alt="image-20250719194405703"></p><p>如图是我参考课程使用visio绘制的fork框图，下面结合这个来解释一下fork的流程。</p><p>首先是关于linux的结构，在linux中，进程都是不能直接更改物理内存的，它在虚拟内存中，通过一个页表来维护关系，进程通过修改页表修改内存中的数据。</p><p>当使用bgsave的时候，首先会进行fork，会开启子进程，子进程复制主进程的页表，复制完后，为避免脏读的情况，会将数据A和数据B设为只读的共享内存，这样子进程在存储RDB时就不会被主进程干扰。</p><p>相应的主进程要更改数据，数据B会被拷贝为数据B的副本，主进程通过修改副本实现修改的功能。</p><p>因为内存进行了拷贝，所以极限情况下可能会占用两倍的内存，这也就是为什么使用Redis都要预留一定的内存空间。</p><p>RDB缺点：</p><ol><li>RDB间隔较长，两次RDB间由数据丢失风险</li><li>fork子进程、压缩写出RDB比较耗时</li></ol><h3 id="方式二：AOF持久化">方式二：AOF持久化</h3><p>AOF全程Append Only File（追加文件），可以看成命令日志文件</p><p>可以通过redis.conf配置文件开启和配置AOF</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">&quot;名字&quot;</span></span><br><span class="line"><span class="comment">#频率</span></span><br><span class="line">appendfsync always<span class="comment">#每执行一次命令，立即写到AOF</span></span><br><span class="line">appendfsync everysec<span class="comment">#写命令执行完先放入AOF缓冲区，每隔一秒将缓冲数据写到AOF</span></span><br><span class="line">appendfsync no<span class="comment">#写命令执行完先放入AOF缓冲区，由操作系统决定什么时候将缓冲数据写到AOF</span></span><br></pre></td></tr></table></figure><p><strong>AOF体积压缩</strong></p><p>因为AOF记录的是每条命令，多条命令叠加下可能很多命令是无效的，所以体积会很大。</p><p>可以使用bgrewriteaof命令将AOF文件进行重写以减小体积</p><p>什么时候进行重写？</p><p>可以在redis.conf文件中配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto<span class="literal">-aof-rewrite-percentage</span> <span class="number">100</span><span class="comment">#AOF文件增长超过多少百分比触发重写</span></span><br><span class="line">auto<span class="literal">-aof-rewrite-min-size</span> <span class="number">64</span>mb<span class="comment">#AOF文件体积最小多大以上触发重写</span></span><br></pre></td></tr></table></figure><h3 id="RDB和AOF对比">RDB和AOF对比</h3><p>各有优缺点，如果对数据安全性要求较高，在实际开发中往往会将两种方式结合起来使用</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高</td></tr></tbody></table><h2 id="二、主从集群">二、主从集群</h2><ul><li>搭建主从架构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CV-Elevation/imgHub/article_img/image-20250721000603573.png" alt="image-20250721000603573"></p><p>开启主从关系</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof/slaveof(<span class="number">5.0</span>之前) host port(主节点的)</span><br></pre></td></tr></table></figure><p>开启后主从搭建就完成了，主节点写，从节点只读</p><ul><li>数据同步原理</li></ul><p>全量同步</p><p>首次请求进行全量同步</p><p><img src="https://cdn.jsdelivr.net/gh/CV-Elevation/imgHub/article_img/image-20250721003505684.png" alt="image-20250721003505684"></p><p>增量同步</p><p>在上边全量同步的流程中，如果发现replid一致，就会进行增量同步。主节点会从log文件中获取offset以后的数据，发送offset之后的命令给从节点。</p><p>上边暂存的lrepl_baklog可以理解为是一个环形的结构，而这个环形的结构是有存储上限的。当slave和master之间差的offset超过repl——baklog的大小时，不能进行增量同步</p><p>优化：</p><ol><li>在master中配置repl-diskless-sunc yes，启用无磁盘复制，避免全量同步时的磁盘IO</li><li>Redis单节点的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>提高log的大小，发现slave宕机时尽快恢复，尽可能避免全量同步</li><li>限制一个master的slave数量，如果是在太多可以使用主从从结构</li></ol><h2 id="三、Redis哨兵">三、Redis哨兵</h2><h3 id="哨兵的作用：">哨兵的作用：</h3><ul><li>监控：Sentinel会不断检查您的master和slave是否按预期工作</li><li>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master，当故障实例恢复后也会以新的master为主</li><li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端</li></ul><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令</p><p>主观下线：如果Sentinel节点发现某实例未在规定时间内响应，则认为该实例主观下线</p><p>客观下线：若超过指定数量（quorum）的Sentinel都认为该实例主观下线，则该实例客观下线。quorum的值最好超过Sentinel实例数量的一半。</p><p>选择新的master的优先级：</p><ol><li>断开时间长短</li><li>slave-priority</li><li>offset</li><li>运行id，越小优先级越高</li></ol><h3 id="故障转移流程">故障转移流程</h3><ol><li>选择新的master，执行slave of no one</li><li>其他节点slave of新的master</li><li>修改故障节点配置，添加slave of新的master</li></ol><h3 id="搭建哨兵集群">搭建哨兵集群</h3><ol><li>新建sentinel.conf</li><li>配置ip、主从集群、目录</li></ol><h3 id="RedisTemplate的哨兵模式">RedisTemplate的哨兵模式</h3><ol><li>导入依赖</li><li>在yaml文件中配置sentinel集群地址</li><li>配置主从读写分离</li></ol><h2 id="四、Redis分片集群">四、Redis分片集群</h2><p>分片集群的作用：</p><p>海量数据存储</p><p>高并发写操作</p><p>分片集群说明：</p><ul><li>集群中有多个master</li><li>每个master都有多个slave</li><li>master之间通过ping监测批次的健康状态</li><li>客户端请求可访问集群的任意节点，最终都会被转发到正确节点</li></ul><h3 id="搭建">搭建</h3><p><code>redis-cli –-cluster create --cluster-replicas 1 X X X Y Y Y</code></p><p>因为设置每个master的slave个数为1，所以前三个为master，后三个是slave</p><h3 id="散列插槽">散列插槽</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hashslot）上，查看集群信息就能看到</p><p>数据key不是与节点绑定，而是与插槽绑定，redis会根据key的有效部分计算插槽值，分两种情况</p><ul><li>key中含有”{}“且{}中至少包含一个字符，则{}内的部分有效</li><li>key不是不含{}，整个key有效</li></ul><p>计算方法是有CRC16算法的一个hash值，然后对16384取余。</p><p>如何将同一类数据固定的保存在同一个Redis实例？</p><p>使用相同的有效部分，也就是{}内的部分相同</p><h3 id="添加一个节点到集群">添加一个节点到集群</h3><p>例：想集群中添加一个master节点，向其中添加一个num=10数据</p><ol><li>添加 使用addnode指令</li><li>插槽分配 使用<code>redis-cli —cluster reshard host port</code></li></ol><h3 id="故障转移">故障转移</h3><p>当集群中有一个master宕机会发生什么？</p><p>自动故障转移：</p><ol><li>该实例失去连接</li><li>疑似宕机</li><li>确定下线，自动提升一个slave为新的master</li></ol><p>如果想要手动更换master节点，使用failover指令进行故障转移</p><p>具体流程如下：</p><ol><li>slave节点告诉master节点拒绝任何客户端请求</li><li>master返回当前的数据offset给slave</li><li>slave等待offset与master一致</li><li>slave、master开始故障转移</li><li>slave标记自己为master，广播故障转移的结果</li><li>原master收到广播，开始处理客户端读的请求</li></ol><p>failover有3种模式：</p><ol><li>缺省，就是上述的默认模式</li><li>force，省略一致性检验的过程</li><li>takeover，直接执行步骤5</li></ol><h3 id="RedisTemplate访问分片集群">RedisTemplate访问分片集群</h3><p>与哨兵的配置类似</p><p>只是在yaml文件的配置不同</p><p>今天试了试用图床来插入图片，我已经受够了糟糕的mermaid流程图，还是visio画着舒服❤</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式缓存——Redis高级篇&lt;/h1&gt;
&lt;p&gt;单节点Redis问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据丢失问题：实现Redis数据持久化&lt;/li&gt;
&lt;li&gt;并发能力问题：搭建主从集群，实现读写分离&lt;/li&gt;
&lt;li&gt;故障恢复问题：Redis哨兵，实现健康检测和自动恢复&lt;/l</summary>
      
    
    
    
    
    <category term="Redis 分布式缓存" scheme="http://cv-elevation.github.io/tags/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架</title>
    <link href="http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/"/>
    <id>http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/</id>
    <published>2025-07-18T08:53:50.000Z</published>
    <updated>2025-07-18T08:54:55.694Z</updated>
    
    <content type="html"><![CDATA[<h1>Spring Framework</h1><p>Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=3">Spring-01-初识Spring_哔哩哔哩_bilibili</a></p><p>要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Spring源码的部分进一步学习。</p><p><strong>Spring系统架构</strong></p><img src="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/image-20250614224253416.png" alt="image-20250614224253416" style="zoom:30%;"><p><strong>IoC（Inversion of Control）控制翻转</strong></p><p>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象的创建控制权由程序转移到外部，这个思想就是<strong>控制翻转</strong>。</p><p>IoC、Bean和DI：</p><ul><li><p>Spring提供了一个容器，称为IoC容器，用来充当Ioc思想中的“外部”</p></li><li><p>IoC容器负责对象的创建、初始化的一系列工作，被创建或管理的对象在IoC容器中统称为<strong>Bean</strong></p></li><li><p>DI（依赖注入）在容器中建立起bean与bean之间的关系</p></li></ul><p>我们这样做的目的是充分解耦，具体做法可以概括如下：</p><ul><li>使用IoC容器管理bean（IoC）</li><li>在IoC容器中将有依赖关系的bean进行关系绑定（DI）</li></ul><h2 id="bean管理">bean管理</h2><h3 id="bean作用范围">bean作用范围</h3><p>bean的作用范围对应着scope属性，主要就是控制其是否为单例。</p><p>为什么bean默认为单例？</p><ul><li>IoC容器就适合管理单例的对象，这样才能有效地提高效率。</li></ul><p>适合交给容器管理的bean</p><ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul><p>不适合交给容器管理的bean</p><ul><li>封装实体的域对象、</li></ul><h3 id="bean的实例化">bean的实例化</h3><ol><li>构造方法（常用）</li></ol><p>提供可访问的构造方法</p><p>配置</p><ul><li>无参构造器如果不存在，会抛出BeanCreationException</li></ul><ol start="2"><li>静态工厂（了解）</li><li>实例工厂（了解）</li><li>使用FactoryBean实例化，其中有三个方法，用来得到Bean实例、设定Bean类型、设定是否为单例（实用）</li></ol><h3 id="bean的生命周期">bean的生命周期</h3><ul><li>bean生命周期：bean从创建到销毁的整体过程</li><li>bean生命周期控制：在bean创建后到销毁前做的一些事情</li></ul><p><strong>生命周期控制</strong></p><ul><li>配置的方式</li><li>接口控制</li></ul><p><strong>bean的生命周期</strong></p><p>初始化容器</p><ol><li>创建对象（内存分配）</li><li>执行构造方法</li><li>执行属性注入（set操作）</li><li>执行bean初始化方法</li></ol><p>使用bean</p><ol><li>执行业务操作</li></ol><p>关闭/销毁容器</p><ol><li>执行bean销毁方法</li></ol><p><strong>bean销毁</strong></p><p>容器关闭前触发bean的销毁</p><p>关闭容器方式：</p><ul><li>手动关闭容器，ConfigurableApplicationContext接口close()操作</li><li>注册关闭<strong>钩子</strong>，在虚拟机退出前先关闭容器再退出虚拟机，ConfigurableApplicationContext接口registerShutdownHook()操作</li></ul><h3 id="总结">总结</h3><p>bean相关标签属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;dao bookDaoImpl daoImpl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;com.itheima.factory.BookDaoFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>id</code>: bean的Id</li><li><code>name</code>: bean别名</li><li><code>class</code>: bean类型，静态工厂类，FactoryBean类</li><li><code>scope</code>: 控制bean的实例数量</li><li><code>init-method</code>: 生命周期初始化方法</li><li><code>destroy-method</code>: 生命周期销毁方法</li><li><code>autowire</code>: 自动装配类型，实际开发一般用注解，该属性一般不用</li><li><code>factory-method</code>: bean工厂方法，应用于静态工厂或实例工厂</li><li><code>factory-bean</code>: 实例工厂bean</li><li><code>lazy-init</code>: 控制bean延迟加载</li></ul><h2 id="依赖注入">依赖注入</h2><h3 id="手动装配">手动装配</h3><ul><li>setter注入</li></ul><p>引用类型使用ref配置</p><p>简单类型：使用property标签value属性进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>构造器注入</li></ul><p>使用constructor-arg标签ref属性注入引用类型对象</p><p>依赖注入方式选择</p><p>如果使用第三方bean，如果其同时提供了构造器注入和setter注入，使用setter注入。没有setter注入就只能使用构造器注入。自己开发推荐使用setter注入。</p><h3 id="自动装配">自动装配</h3><p>自动装配方式：</p><ol><li>按类型</li><li>按名称</li><li>构造器</li><li>不使用自动装配</li></ol><p>通过属性autowire进行自动装配的配置</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于手动注入</li></ul><h3 id="集合注入">集合注入</h3><p>数组、list、set、map、properties</p><p>格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="容器">容器</h2><h3 id="创建容器">创建容器</h3><p>方式1，使用ClassPathXmlApplicationContext</p><p>方式2，使用FileSystemXmlApplicationContext</p><h3 id="获取bean">获取bean</h3><p>方式1，按名称</p><p>方式2，按类型</p><p>方式3，按名称并按类型</p><h3 id="容器类层次结构">容器类层次结构</h3><p><img src="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/image-20250618151923608.png" alt="image-20250618151923608"></p><h3 id="总结-2">总结</h3><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口初始化类<ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h2 id="加载propertis文件">加载propertis文件</h2><h3 id="开启命名空间的方式">开启命名空间的方式</h3><p>1.开context命名空间</p><p>2.使用context空间加载propertie文件</p><p>3.使用属性占位符${}读取properties文件中的属性</p><h3 id="加载propertis文件几种方式">加载propertis文件几种方式</h3><ul><li><p>不加载系统属性</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载多个properties文件</p></li><li><p>加载所有properties文件</p></li><li><p>加载properties文件标准格式</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>从类路径或jar包中搜索并加载properties文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpathE*:*.properties&quot;</span></span></span><br></pre></td></tr></table></figure><p>前三种格式都不规范，推荐使用后两种</p><h2 id="注解开发">注解开发</h2><h3 id="注解开发定义bean">注解开发定义bean</h3><p>使用注解的形式代替原来在配置文件中写的<code>&lt;bean&gt;</code>标签。具体方法是：在相应bean的类那里使用@Component注解。</p><p>为了能让Spring容器找到这个<strong>组件</strong>，还要在配置中添加扫描标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.dao.impl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>同时@Component还有三个衍生注解@Controller、@Service、@Repository</p><h3 id="纯注解开发">纯注解开发</h3><p>Spring3.0升级了纯注解开发模式</p><p>创建一个配置类，添加@Configuration、@ComponentScan注解，就可以完全代替配置文件</p><p>相对应的，应用程序的使用也要改变，需要使用AnnotationConfigApplicationContext的实现类创建容器，其相应参数传入我们的配置类。</p><p>总之，核心思想就是通过一个类及其注解代替配置文件</p><h3 id="bean管理-2">bean管理</h3><p>bean作用范围</p><p>@Scope</p><p>bean生命周期</p><p>@PostConstruct</p><p>@PreDestroy</p><h3 id="依赖注入-2">依赖注入</h3><p><strong>引用类型</strong></p><p>自动装配@Autowired按照类型自动装配。</p><ul><li>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法</li><li>注意：自动装配建议使用无参构造方法（默认），如果不提供对应构造方法，请提供唯一的构造方法</li></ul><p>关于有多个同类型的类的情况下如何解决，在SpringBoot的依赖注入部分我已经总结过<a href="https://kuoz.top/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/">SpringBoot入门 | KuoZ’s blog</a></p><p><strong>简单类型</strong></p><p>使用@Value()进行值的注入，这样直接注入是静态的，实际上没什么意义，关键是如何动态注入。</p><p>如何动态进行注入？</p><p>方法：</p><ol><li><p>在properties配置文件中写相应的属性名及其值</p></li><li><p>在配置类中添加@PropertySource(“配置文件名”)注解</p></li><li><p>然后在基本类型的@Value注解中用${属性名}进行替换</p></li></ol><p>注意：要添加多个配置文件，要用数组的形式进行配置，@PropertySource({“配置文件名1”,“配置文件名2”,…})</p><h3 id="第三方bean管理">第三方bean管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个问题，这个bean实在配置类中写的，可能会有很多第三方bean，如果都写在SpringConfig配置类中就会很臃肿，所以要写新的配置类。接下来的问题是如何将这个新的配置类加载起来，方法是在SpringConfig配置类中使用@Import()注解，同样的，有多个配置类时，要用数组的形式写如@Import的属性。</p><p>第三方bean依赖注入</p><ul><li>引用类型：方法形参</li><li>简单类型：成员变量，使用@Value进行注入即可</li></ul><h3 id="总结-3">总结</h3><p>XML和注解配置的对比</p><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">XML配置</th><th style="text-align:left">注解</th></tr></thead><tbody><tr><td style="text-align:left">定义bean</td><td style="text-align:left"><code>&lt;bean&gt;</code>标签</td><td style="text-align:left"><code>@Component</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>id</code>属性</td><td style="text-align:left">- <code>@Controller</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>class</code>属性</td><td style="text-align:left">- <code>@Service</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <code>@Repository</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>@ComponentScan</code></td></tr><tr><td style="text-align:left">设置依赖注入</td><td style="text-align:left">setter注入（set方法）</td><td style="text-align:left"><code>@Autowired</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- 引用/简单类型</td><td style="text-align:left">- <code>@Qualifier</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">构造器注入（构造方法）</td><td style="text-align:left"><code>@Value</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- 引用/简单类型</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">自动装配</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">配置第三方bean</td><td style="text-align:left"><code>&lt;bean&gt;</code>标签</td><td style="text-align:left"><code>@Bean</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">静态工厂、实例工厂、<code>FactoryBean</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">作用范围</td><td style="text-align:left"><code>scope</code>属性</td><td style="text-align:left"><code>@Scope</code></td></tr><tr><td style="text-align:left">生命周期</td><td style="text-align:left">标准接口</td><td style="text-align:left"><code>@PostConstruct</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>init-method</code></td><td style="text-align:left"><code>@PreDestroy</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>destroy-method</code></td><td style="text-align:left"></td></tr></tbody></table><h2 id="整合">整合</h2><h3 id="Spring整合MyBatis">Spring整合MyBatis</h3><p>如何整合MyBatis？</p><ul><li>通过MyBatis的实现代码可以看出，MyBatis的核心实现类是SqlSessionFactory，所以整合的核心也是sqlSessionFactory对象</li></ul><p>简略地说，只有两个bean需要配置</p><ul><li>SqlSessionFactoryBean</li><li>MapperScannerConfigurer</li></ul><h3 id="Spring整合JUnit">Spring整合JUnit</h3><p>在pom中导入JUnit依赖和Spring整合测试依赖</p><p>在test包下创建测试类，为其添加注解</p><ul><li>@RunWith(SpringJUnit4ClassRunner.class)</li><li>@ContextConfiguration(classes = SpringConfig.class)</li></ul><h2 id="AOP">AOP</h2><p>在介绍AOP之前，我想先来介绍一下代理模式，这样可以利于理解AOP</p><h3 id="代理模式">代理模式</h3><p>动态代理</p><p>什么是动态代理？</p><p>就是一种无侵入式地修改代码、添加功能</p><p>这个功能的实现就依赖于代理对象。</p><p>什么是代理对象？</p><p>代理对象就相当于是一个中间对象，它介于目标对象和调用者之间，通过反射的方式间接调用目标对象的方法，同时还可以添加增强的功能。</p><p>下一个问题，如何创建代理对象？</p><p>jdk中为我们提供了一个类：java.lang.reflect.Proxy类，提供了为对象产生代理对象的方法：<code>newProxyInstance()</code></p><p>该方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="keyword">new</span> <span class="title class_">ProxyInstance</span>(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数1：用于指定用哪个类加载器去加载生成的代理类，一般固定</span></span><br><span class="line"><span class="comment">*参数2：指定接口，指明有哪些方法</span></span><br><span class="line"><span class="comment">*参数3：生成的代理对象要干什么事（一般是匿名实现类的匿名对象，不懂的可以去看面向对象高级里的接口）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="AOP-2">AOP</h3><ul><li><p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</p></li><li><p>作用：在不惊动原始设计的基础上为其进行功能增强</p></li></ul><p><strong>AOP的重要概念</strong></p><p>连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法</p><ul><li>在SpringAOP中，理解为方法的执行</li></ul><p>切入点（Pointcut）：匹配连接点的式子</p><ul><li><p>在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法</p><ul><li><p>一个具体方法：</p></li><li><p>匹配多个方法：</p></li></ul></li></ul><p>通知（Advice）：在切入点处执行的操作，也就是共性功能</p><ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul><p>通知类：定义通知的类</p><p>切面（Aspect）：描述通知与切入点的对应关系</p><p><strong>AOP开发</strong></p><p>比如在服务层的若干连接点，在这些方法前执行一个共性方法</p><ol><li>导入aspect依赖、spring-aop依赖（依赖于Context依赖，导入Context后会自动导入）</li><li>定义dao接口和实现类</li><li>定义通知类，为这个类添加<code>@Component、@Aspect</code>，</li><li>定义切入点，写一个私有空方法（比如<code>private void pt()&#123;&#125;</code>），在上边添加<code>@Pointcut(“execution()”)</code>绑定切入点，参数是切入点的返回类型+包名.类名.方法名</li><li>绑定切入点与通知关系，<code>@Before(“pt()”)</code></li><li>为配置类添加@EnableAspectJAutoProxy</li></ol><p><strong>AOP工作流程</strong></p><p>工作流程：</p><ol><li>Spring容器启动</li><li>读取所有切面配置的切入点（注意一定是使用了的切入点才会被读取）</li><li>初始化bean，判定bean对应的类中的方法是否匹配到了任意切入点<ul><li>匹配失败，创建对象</li><li>匹配成功，创建目标对象的代理对象</li></ul></li><li>获取bean的执行方法<ul><li>获取bean，调用方法并执行，完成操作</li><li>根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ul></li></ol><p>AOP的本质就是<strong>代理模式</strong></p><p><strong>AOP切入点表达式</strong></p><p>切入点表达式和切入点是完全不同的概念</p><p>语法格式：</p><p>没什么好讲的，大概给个标准格式吧，稍微看一点就会了</p><p><code>动作关键字(权限修饰符（可省略） 返回值类型 包名.类/接口名.方法名（形参列表）异常名)</code></p><p>通配符：</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>可以独立出现，也可以作为前缀或者后缀（如find*）（用在方法参数中一个只表示一个任意参数）</td></tr><tr><td>…</td><td>多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</td></tr><tr><td>+</td><td>专用于匹配子类类型</td></tr></tbody></table><p>下面给几个例子，来体验一下切入点表达式的书写</p><p>书写技巧：</p><ol><li>按照编程的命名规范编程，否则技巧全部无用</li><li>通常描述切入点时描述到接口而不写实现类</li><li>一般省略修饰符</li><li>对于返回值，增删改类使用精准类型加速匹配，查询类使用*通配符快速描述</li><li>包名尽量不用…匹配，效率太低，常用*作为单个包匹配，或者精准匹配</li><li>接口名采用*匹配，如：<code>*Service</code>，绑定业务层接口名</li><li>方法名动词精准匹配，名词用*，如<code>getBy*</code></li><li>参数规则较复杂，据业务方法灵活调整</li><li>不使用异常方法做匹配规则</li></ol><p>AOP通知类型</p><p>五种类型：</p><ul><li>前置通知@Before</li><li>后置通知@After</li><li><strong>环绕通知@Around</strong>（重点）</li><li>@AfterReturning（不常用）</li><li>@AfterThrowing（不常用）</li></ul><p>环绕通知的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(pt)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;切入点前执行...&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed; </span><br><span class="line">    System.out.println(<span class="string">&quot;切入点后执行...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于@Around的通知类型的注意：</p><ul><li>通知中未使用ProceedingJoinPoint对原始方法进行调用，则会跳过原始方法</li><li>对原始方法的调用可以不接收返回值，通知方法返回值类型设为void即可，如果接收，则必须设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设定为void，也可以设定成Object</li><li>由于无法预知原始方法是否会抛出异常，所以通知方法要抛出异常</li></ul><p>AOP通知获取数据</p><p>获取参数</p><p>环绕类型直接使用ProceedingJoinPoint参数获取参数</p><p>其他类型使用JoinPoint参数获取参数</p><p>获取返回值</p><p>使用returning注解属性获取返回值</p><p>获取异常</p><p>使用throwing注解属性获取返回值</p><h2 id="Spring事务属性">Spring事务属性</h2><p>Spring事务，在数据层、业务层保障一系列数据库操作同成功同失败</p><h3 id="Spring事务的添加">Spring事务的添加</h3><ol><li>在业务层接口上加@Transactional注解</li><li>在配置中添加事务管理器</li><li>开启事务控制@EnableTransactionManagement</li></ol><h3 id="Spring事务角色">Spring事务角色</h3><p>Spring事务会让数据层接口的事务加入Spring事务，从而保证一致性</p><p>有两个角色</p><p>事务管理员：发起事务方，在Spring中代指业务层开启事务的方法</p><p>事务协调员：加入事务方，在Spring中代指数据层方法也可以是业务层方法</p><h3 id="Spring事务属性-2">Spring事务属性</h3><p>事务相关配置</p><p>在@Transactionnal注解属性中可以更改readonly、timeout等属性，最重要的还是rollbackFor属性</p><p>为什么需要rollbackFor属性？</p><p>因为默认情况下只有遇到Error、运行时异常，事务才会回滚。如果想在其他异常时也同样回滚，就需要设置rollbackFor属性。</p><p>例如<code>@Transactional(rollbackFor=IOException.class)</code></p><p>日志模块</p><p>日志模块要求无论转账成功与否，都要在数据库中添加记录</p><p>这就涉及到事务的传播行为，来设定事务的处理态度</p><p>通过@Transactional注解的Propagation设定</p><p>总共有如下取值</p><table><thead><tr><th>Propagation</th><th>事务管理员</th><th>事务协调员</th></tr></thead><tbody><tr><td>REQUIRED</td><td>开启T</td><td>加入T</td></tr><tr><td></td><td>无</td><td>新建T2</td></tr><tr><td>REQUIRES_NEW</td><td>开启T</td><td>新建T2</td></tr><tr><td></td><td>无</td><td>新建T2</td></tr><tr><td>SUPPORTS</td><td>开启T</td><td>加入T</td></tr><tr><td></td><td>无</td><td>无</td></tr><tr><td>NOT_SUPPORTED</td><td>开启T</td><td>无</td></tr><tr><td></td><td>无</td><td>无</td></tr><tr><td>MANDATORY</td><td>开启T</td><td>加入T</td></tr><tr><td></td><td>无</td><td>ERROR</td></tr><tr><td>NEVER</td><td>开启T</td><td>ERROR</td></tr><tr><td></td><td>无</td><td>无</td></tr></tbody></table><p>还有一个是NESTED，设置savePoint，一旦事务回滚，事务将回滚到savaPoint，交由客户响应提交/回滚</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Spring Framework&lt;/h1&gt;
&lt;p&gt;Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门&lt;a href=</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://cv-elevation.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-反射</title>
    <link href="http://cv-elevation.github.io/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/"/>
    <id>http://cv-elevation.github.io/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/</id>
    <published>2025-07-16T07:11:44.000Z</published>
    <updated>2025-07-16T08:22:19.990Z</updated>
    
    <content type="html"><![CDATA[<p>学到Spring框架发现自己JavaSE的反射还没学，就滚过来学反射了。</p><p>黑马的这个课讲的真不错，比尚硅谷的那个要简练一些，很轻松就能听懂了。</p><h1>反射</h1><blockquote><p>Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p></blockquote><p>官方对反射的描述：反射允许以编程方式访问已加载类的字段、方法和构造函数的信息，并在安全限制范围内使用反射字段、方法和构造函数来操作其底层对应项。</p><p>总之反射就是要获取某个类的Class文件，并解剖出它的成员变量、成员方法和构造方法。</p><h2 id="反射第一步：获取class">反射第一步：获取class</h2><p>要获取class，总共有三种方法</p><ol><li><code>Class.forName(&quot;全类名&quot;)</code></li><li><code>类名.class</code></li><li><code>对象.getClass()</code></li></ol><p>说明：</p><ul><li>1中的全类名指的是包名+类名，一般可以直接复制粘贴</li><li>3的getClass方法是Object里的方法，所以所有对象都可以调用</li><li>三种方法虽然都可以获取class，但是对应的阶段不同<ul><li>1对应的是源代码阶段</li><li>2对应的是加载到内存的阶段，一般作参数传递</li><li>3对应的是运行时阶段，只有这个类的对象创建时才能使用</li></ul></li></ul><h2 id="反射第二步：获得并使用构造方法、属性、成员方法">反射第二步：获得并使用构造方法、属性、成员方法</h2><p>Java中有一个重要的思想就是万事万物皆对象，相应的，构造方法、属性和成员方法也有其对应的类</p><p>属性（Field类）、成员方法（Method类）、构造方法（Constructor）</p><h3 id="1-获得并使用构造方法">1.获得并使用构造方法</h3><ol><li>Class类中的方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstrutors();</span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstrutors();</span><br><span class="line">Constructor&lt;?&gt; getConstrucor(参数列表（注意传参数对应的class对象）);</span><br><span class="line">Constructor&lt;?&gt; getDeclaredConstrucor(参数列表（注意传参数对应的class对象）);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用Constructor类的方法，获得修饰符、名字、形参、对象创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;<span class="comment">//获得权限修饰符</span></span><br><span class="line">getName();</span><br><span class="line">getParameters();<span class="comment">//获取参数列表</span></span><br></pre></td></tr></table></figure><p>（IDEA底层的代码提示其实就是用的反射）</p><p>关于modifiers()</p><table><thead><tr><th style="text-align:left">变量和类型</th><th style="text-align:left">常量字段</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>ABSTRACT</code></td><td style="text-align:left"><code>1024</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>FINAL</code></td><td style="text-align:left"><code>16</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>INTERFACE</code></td><td style="text-align:left"><code>512</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>NATIVE</code></td><td style="text-align:left"><code>256</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>PRIVATE</code></td><td style="text-align:left"><code>2</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>PROTECTED</code></td><td style="text-align:left"><code>4</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>PUBLIC</code></td><td style="text-align:left"><code>1</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>STATIC</code></td><td style="text-align:left"><code>8</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>STRICT</code></td><td style="text-align:left"><code>2048</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>SYNCHRONIZED</code></td><td style="text-align:left"><code>32</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>TRANSIENT</code></td><td style="text-align:left"><code>128</code></td></tr><tr><td style="text-align:left"><code>public static final int</code></td><td style="text-align:left"><code>VOLATILE</code></td><td style="text-align:left"><code>64</code></td></tr></tbody></table><p>使用暴力反射进行对象的创建：</p><p>对于私有构造器的使用，注意使用<code>setAccessible(true)</code>跳过权限验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">System.out.println(cons.getModifiers());</span><br><span class="line">cons.setAccessible(<span class="literal">true</span>);<span class="comment">//设定权限验证</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) cons.newInstance(<span class="string">&quot;wangpeng&quot;</span>);</span><br><span class="line">System.out.println(user.toString());</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span><span class="comment">//输出的权限修饰符，以int表示，2表示private</span></span><br><span class="line">User&#123;userName=<span class="string">&#x27;wangpeng&#x27;</span>, id=<span class="number">0</span>, gender=<span class="string">&#x27;null&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，虽然构造器是私有的，但是我们通过暴力反射的方式也一样创建了对象</p><h3 id="2-获取成员变量">2.获取成员变量</h3><ol><li>Class类的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field&lt;?&gt;[] getFields();</span><br><span class="line">Field&lt;?&gt;[] getDeclaredFields();</span><br><span class="line">Field&lt;?&gt; getField(参数列表（注意传参数对应的class对象）);</span><br><span class="line">Field&lt;?&gt; getDeclaredField(参数列表（注意传参数对应的class对象）);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用Field类的方法获取修饰符、名字、获取类型、获取/设定值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj,Object value)</span>;</span><br><span class="line">Object <span class="title function_">get</span><span class="params">(Object obj)</span>;</span><br><span class="line">Class&lt;?&gt; getType();</span><br></pre></td></tr></table></figure><p>对于私有属性的使用，注意使用<code>setAccessible(true)</code>跳过权限验证</p><h3 id="3-获取成员方法">3.获取成员方法</h3><ol><li>Class类的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method&lt;?&gt;[] getMethods();<span class="comment">//包含父类的所有public方法</span></span><br><span class="line">Method&lt;?&gt;[] getDeclaredMethods();<span class="comment">//不包含父类方法</span></span><br><span class="line">Method&lt;?&gt; getMethod(String name,参数列表（注意传参数对应的class对象）);</span><br><span class="line">Method&lt;?&gt; getDeclaredMethod(String name,参数列表（注意传参数对应的class对象）);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用Method类的方法获得修饰符、名字、形参、返回值、注解、抛出异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getModifiers();</span><br><span class="line">getName();</span><br><span class="line">getParameters();</span><br><span class="line">getExceptionTypes();</span><br></pre></td></tr></table></figure><ol start="3"><li>方法运行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj,Objetc...args)</span>;</span><br></pre></td></tr></table></figure><h2 id="反射的应用">反射的应用</h2><ol><li>保存任意对象数据</li><li>动态创建对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学到Spring框架发现自己JavaSE的反射还没学，就滚过来学反射了。&lt;/p&gt;
&lt;p&gt;黑马的这个课讲的真不错，比尚硅谷的那个要简练一些，很轻松就能听懂了。&lt;/p&gt;
&lt;h1&gt;反射&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Reflection allows programm</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC之登录校验</title>
    <link href="http://cv-elevation.github.io/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/"/>
    <id>http://cv-elevation.github.io/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/</id>
    <published>2025-07-13T07:21:29.000Z</published>
    <updated>2025-07-13T10:18:47.125Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringMVC之登录校验</h1><p>登录功能的实现比较简单，只需要根据输入的用户名和密码，或者其他登录验证形式，到数据库查询是否有这条数据就可以了。</p><p>但实际上这是一个伪登录的功能。因为HTTP协议是一种无状态的协议，所以在后续的访问中无法记录登录状态。也就是<strong>登录校验</strong>功能没有实现，下边来详细讲解一下该功能的实现。</p><pre><code class="highlight mermaid">graph LR浏览器--&gt;|请求|拦截器拦截器--&gt;|响应|浏览器拦截器--&gt;login拦截器--&gt;Controller接口login--&gt;|存|登录标记登录标记--&gt;|取|拦截器</code></pre><p>上图展示了登录验证这一业务的实现流程</p><ul><li><p>实现登录标记：会话技术</p></li><li><p>实现统一拦截：过滤器(filter)、拦截器(interceptor)</p></li></ul><p>下边介绍这些技术</p><h2 id="会话技术">会话技术</h2><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要多次请求是否来自于同一浏览器，以便在同一次会话的多次请求之间能够<strong>共享数据</strong></li></ul><h3 id="Cookie">Cookie</h3><p>客户端会话跟踪技术</p><p>服务端在响应的响应头里携带Set-Cookie：name=value</p><p>之后浏览器在请求时请求头里携带Cookie：name=value</p><p>优点：</p><ul><li>HTTP协议中支持的技术，浏览器自动进行</li></ul><p><strong>缺点：</strong></p><ul><li><p>在移动端无法使用Cookie</p></li><li><p>不安全，用户可以自己禁用Cookie</p></li><li><p>Cookie不能<strong>跨域</strong></p></li></ul><h3 id="session">session</h3><p>服务器会话跟踪技术,是基于Cookie实现的</p><p><strong>缺点</strong></p><ul><li><p>服务器集群环境下无法使用session</p></li><li><p>cookie的缺点：因为底层就是用cookie实现的</p></li></ul><h3 id="令牌技术">令牌技术</h3><p>优点：</p><ul><li><p>支持PC端和移动端，因为现在不需要把令牌存储在Cookie中，其他的存储空间也是可以的</p></li><li><p>解决集群环境下的认证问题</p></li><li><p>减轻服务器端的存储压力</p></li></ul><p>后边在redis还会详细讲解其实现</p><p><strong>JWT令牌：（令牌的一种形式）</strong></p><p>JSON Web Token（<a href="https://jwt.io">https://jwt.io</a>）</p><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全传输信息。由于数字签名的存在，这些信息是可靠的。</p><p><strong>JWT令牌的组成：</strong></p><p>第一部分：Header（头），记录令牌类型、签名算法等。</p><p>第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。</p><p>第三部分：Signature（数字签名），防止Token被篡改，确保安全性。融入header、payload，并加入指定秘钥，通过指定签名算法计算而来。</p><p>介绍一下Base64编码：是一种基于64个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式。</p><p><strong>JWT校验：</strong></p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的</li><li>如果JWT令牌解析时报错，则说明JWT令牌被篡改或失效了，令牌非法</li></ul><p>JWT校验需要使用统一拦截的技术，下面将会讲解统一拦截的实现方式</p><h2 id="统一拦截">统一拦截</h2><h3 id="过滤器">过滤器</h3><p>过滤器(Filter)是JavaWeb三大组件（Filter、Servlet、Listener）之一。</p><p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊功能</p><p>过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等</p><p><strong>Filter快速入门：（并不重要）</strong></p><p>定义：实现Filter接口</p><p>配置：</p><p>在实现类上加上@WebFilter(urlPatterns=“/*”)表示拦截路径</p><p>Filter并不是SpringBoot的组件，所以需要在启动类上加上@ServletComponentScan</p><p><strong>过滤器的执行流程</strong></p> <pre><code class="highlight mermaid">graph LR浏览器--&gt;|请求|Filtersubgraph Filter1.放行前逻辑2.放行4.放行后逻辑endFilter--&gt;3.Web资源3.Web资源--&gt;Filter</code></pre><p>Filter的执行流程如图所示，按照1234的顺序执行。访问Web资源后还会回到Filter中执行放行后逻辑。</p><p><strong>过滤器链</strong></p><p>一个Web应用中可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。</p><p>优先级：注解配置的Filter，是按照过滤器的类名（字符串）自然排序执行的。</p><p><strong>登录校验Filter的业务流程：</strong></p><pre><code class="highlight mermaid">graph请求--&gt;A[获取请求路径]A--&gt;B[判断是否为登录请求]B--&gt;|是|C[放行]B--&gt;|否|D[获取请求头token]D--&gt;E[判断是否有token]E--&gt;|有|F[校验token]E--&gt;|无|GF--&gt;|校验通过|CF--&gt;|校验不通过|G[返回未登录结果]</code></pre><h3 id="拦截器">拦截器</h3><p>拦截器（Interceptor）与过滤器类似，是一种动态拦截方法调用的机制。是Spring框架提供的，用来动态拦截控制器方法的执行。</p><p><strong>拦截器的一般架构：</strong></p><p>1.定义拦截器,实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line">     <span class="comment">// 在业务处理器处理请求之前被调用，返回true表示放行，返回false表示不放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在业务处理器处理请求完成之后，生成视图之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在DispatcherServlet完全处理完请求之后被调用，可用于清理资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.注册拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径配置详解：</p><p>在配置类中，关于配置的路径：</p><p>使用<code>.addPathPatterns</code>添加需要拦截的资源，使用<code>.excludePathPatterns</code>添加不需要拦截的资源</p><p>具体拦截路径：</p><p><code>/*</code>：拦截一级路径</p><p><code>/**</code>：拦截任意级路径</p><p>拦截器的执行流程</p><pre><code class="highlight mermaid">graph LRFilter--&gt;Dispatchersubgraph SpringDispatcher--&gt;InterceptorInterceptor--&gt;控制层end</code></pre><p>Filter作为Tomcat服务器的一部分，是先于Spring框架执行的。</p><p>使用拦截器实现统一拦截：</p><p>业务逻辑与Filter完全一致</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SpringMVC之登录校验&lt;/h1&gt;
&lt;p&gt;登录功能的实现比较简单，只需要根据输入的用户名和密码，或者其他登录验证形式，到数据库查询是否有这条数据就可以了。&lt;/p&gt;
&lt;p&gt;但实际上这是一个伪登录的功能。因为HTTP协议是一种无状态的协议，所以在后续的访问中无法记录登录状</summary>
      
    
    
    
    
    <category term="会话技术" scheme="http://cv-elevation.github.io/tags/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Token" scheme="http://cv-elevation.github.io/tags/Token/"/>
    
    <category term="Filter" scheme="http://cv-elevation.github.io/tags/Filter/"/>
    
    <category term="Intercetor" scheme="http://cv-elevation.github.io/tags/Intercetor/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://cv-elevation.github.io/2025/07/04/Redis/"/>
    <id>http://cv-elevation.github.io/2025/07/04/Redis/</id>
    <published>2025-07-04T10:00:54.000Z</published>
    <updated>2025-07-06T04:05:55.468Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis基础部分</h1><h2 id="介绍">介绍</h2><p>Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p>特征：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li><strong>单线程</strong>，每个命令具备原子性</li><li>低延迟，速度快（基于<strong>内存</strong>、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="redis安装">redis安装</h2><p>关于redis，这里推荐装linux版的。</p><p>所以建议先学习安装linux和它的常用vi命令。这里做几点建议：</p><ul><li>win10及以上可以直接使用自带的wsl2来安装linux子系统，具体教程b站上有。我使用的是Ubuntu，并且没有什么问题</li><li>redis的安装和测试可以参考这个教程<a href="https://developer.aliyun.com/article/764565">如何在 Ubuntu 20.04 上安装和配置 Redis-阿里云开发者社区</a></li></ul><h2 id="redis常用的命令">redis常用的命令</h2><p>命令不用死记，建议去redis官网查询命令</p><p>又或者，你也可以在命令行中使用help [command]来查询,例如：</p><p><img src="/2025/07/04/Redis/image-20250703191308454.png" alt="image-20250703191308454"></p><p>下边总结常用的命令</p><ul><li><p>KEYS：查看符合模版的所有key，<strong>不建议在生产环境设备上使用</strong>，因为效率过低</p></li><li><p>DEL：删除一个指定的key</p></li><li><p>EXISTS：判断key是否存在</p></li><li><p>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p>TTL：查看一个key的剩余有效期</p></li></ul><h3 id="String类型">String类型</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：string、int、float</p><p>String的常见命令</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的value</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY：让一个整型的key自增并指定步长</li><li>INCRYBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并指定有效值</li></ul><p>Key的层级格式：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用‘:’隔开，这样就会形成层级结构。</p><h3 id="Hash类型">Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/2025/07/04/Redis/image-20250703211510016.png" alt="image-20250703211510016"></p><p>Hash的常见命令：</p><ul><li>HSET key field value：添加或修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field值</li><li>HMSET：批量添加多个hash类型key的field值</li><li>HMGET：获取获取多个hash类型key的field值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有field</li><li>HVALS：获取一个hash类型的key中的所有value</li><li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="List类型">List类型</h3><p>Redis中的List类型与Java中的LinkedList基本一致</p><p>List的常见命令：</p><ul><li>LPUSH key element…：想列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element…：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key start end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p>如何利用List结构模拟一个栈?</p><ul><li>入口和出口在同一边</li></ul><p>如何利用List结构模拟一个队列？</p><ul><li>入口和出口在不同边</li></ul><p>如何利用List结构模拟一个阻塞队列？</p><ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul><h3 id="Set类型">Set类型</h3><p>Redis的Set结构和Java中的HashSet类似，可以看做是一个value为null的HashMap。</p><p>Set的常见指令：</p><ul><li>SADD key member …：向Set中添加一个或多个元素</li><li>SREM key member …：移除set中的指定元素</li><li>SCARD key：返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2…：求key1与key2的交集</li><li>SDIFF key1 key2…：求key1与key2的差集</li><li>SUNION key1 key2…：求key1与key2的并集</li></ul><h3 id="SortedSet类型">SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member：获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><h2 id="Redis的Java客户端">Redis的Java客户端</h2><h3 id="Jedis">Jedis</h3><p>简单好上手，直接使用redis命令作为方法名。</p><p>使用Jedis的流程</p><ol><li>引入依赖</li><li>创建Jedis依赖，建立连接</li></ol><h3 id="SpringDataRedis">SpringDataRedis</h3><p>使用步骤：</p><ol><li>引入SpringDataRedis的依赖</li><li>在配置文件中配置redis信息</li><li>注入RedisTemplate依赖</li></ol><p>序列化</p><p>默认为jdk序列化方式，这不好</p><p>自动序列化：</p><p>定义RedisTemplate</p><p>key使用String序列化</p><p>value使用json序列化</p><blockquote><p>这里插入一个debug记录：在添加对象的时候，我遇到了一个离谱的问题，那就是lombok使用不了的问题。也在这里记录一下：</p></blockquote><p>问题描述：</p><p><img src="/2025/07/04/Redis/image-20250704165357899.png" alt="image-20250704165357899"></p><p>在传对象的时候，使用全参构造器新创建一个对象，然后作为value进行传输，报了如上的错误。</p><p>经过分析问题应该是lombok注解添加的全参构造器没有生效。然后去问了ai这个问题，给了一些常见的原因，经过排查都没能解决。</p><p>最后我去对比了之前的工程，对比之后发现可能是SpringBoot版本的问题。</p><p>因为在前边写配置文件的时候，课程相对比较老，老师用的是SpringBoot2版本，为了一致，我就也改成了SpringBoot2版本。</p><p>我将SpringBoot改成了3.4.6版本，lombok版本是1.18.38。然后又配置了配置文件，这里注意配置redis之前的层级要加上data。之后就能正常增加数据了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><p>问题总结：</p><p>这个问题真的让人很难排查，因为idea认为我们的编写是没有问题的，编译时不会报错误，但是一运行就挂。总之在看这些相对老点的课程一定要优先关注版本问题。</p><p>手动序列化：</p><p>ObjectMapper手动序列化：</p><p>直接使用Spring提供的<code>StringRedisTemplate</code>类，这个提供了key和value都直接用String序列化的方法。</p><p>字符串类型可以直接使用set、get来存储和读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stringTest</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于对象需要手动序列化：</p><p>使用ObjectMapper来进行手动序列化为JSON，并手动反序列化读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;miku&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>,json);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> objectMapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis存储的数据：</p><p><img src="/2025/07/04/Redis/image-20250704175717830.png" alt="image-20250704175717830"></p><p>客户端读取到的数据：</p><p><img src="/2025/07/04/Redis/image-20250704175736214.png" alt="image-20250704175736214"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis基础部分&lt;/h1&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。&lt;/p&gt;
&lt;p&gt;特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键值（</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://cv-elevation.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis入门</title>
    <link href="http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/"/>
    <id>http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/</id>
    <published>2025-06-08T12:02:16.000Z</published>
    <updated>2025-07-01T09:29:27.924Z</updated>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>2025-06-28 修改了部分错误，优化了文档结构</li><li>2025-07-01 修复了代码块sql语句无法高亮的问题</li></ul><h1>Mybatis入门</h1><img src="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/Mybatis.jpg" width="40%"><h2 id="0-序">0.序</h2><p>Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;<a href="https://www.bilibili.com/video/BV1m84y1w7Tb?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=117">Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili</a>。</p><h2 id="1-入门">1.入门</h2><p><strong>快速入门</strong></p><p>开启一个模版程序，实现使用Mybatis查询所有用户数据</p><ol><li>准备工作（创建springboot文件，定义实际类User，数据库表user）</li><li>添加mybatis相关依赖，配置mybatis（数据库连接信息）</li><li>编写SQL语句（注解/XML）</li></ol><p>具体操作流程如下：</p><ul><li><p>创建springboot文件：与springboot入门中的创建方法基本一致，注意要勾选Mybatis Framework和MySQL Driver依赖。</p></li><li><p>定义实际类：实际类要与数据库中user的字段保证一致，常见的几种类型对应：int-&gt;Integer，varchar-&gt;String，tinyint-&gt;Short，主要使用其包装类。同时声明相应的getset方法、构造器、toString方法。</p></li><li><p>在properties配置文件中加入以下内容，格式比较固定，url要根据相应的数据库名称确定，密码设定为自己的密码</p></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><ul><li>编写SQL语句（注解/XML）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//在运行时，MyBatis会扫描这个接口，并为其生成一个实现类对象（代理对象），并交给IOC管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//springboot整合单元测试的注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后的文件结构如图</p><img src="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/module.png" width="50%"><p><strong>配置SQL提示</strong></p><p>在上边的SQL语句中，如果没有配置，那么就不会显示相应的提示，即使写错了也不会提醒，这对于开发是非常不利的。好在Idea中可以为其配置MySQL数据库连接。</p><ul><li>选中SQL语句，右键，配置为MySQL语句</li><li>点击右侧边栏的数据库选项，点击加号，数据源选择MySQL，填写host、port、用户和密码、数据库</li></ul><p><strong>数据库连接池</strong></p><ul><li>数据库连接池是个容器，负责分配、管理数据库连接</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>能够释放空闲时间超过最大空闲时间的连接，避免因为没有释放连接引起的数据库连接遗漏</li><li>好处：资源重用 提升系统响应速度 避免数据库连接遗漏</li></ul><p>标准接口：DataSource</p><ul><li>官方提供的数据库连接池接口，由第三方组织实现此接口</li><li>功能：获取连接</li></ul><p>常见产品：C3P0、DBCP、Druid、Hikari</p><p><strong>lombok</strong></p><p>在入门-快速入门的实际类编写中我们自己手动构造了getset、toString等方法，较为繁琐。改进方法就是使用lombok。lombok是一个实用Java类库，能通过注解的形式自动生成getset方法、构造器、toString等方法，并可以自动化生成日志日志变量，简化Java开发、提高效率。</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter、@Setter</td><td>提供getset方法</td></tr><tr><td>@ToString</td><td>提供tostring方法</td></tr><tr><td>@EqualsAndHashCode</td><td>重写equals和hashCode方法</td></tr><tr><td>@Data</td><td>上边三个的整合</td></tr><tr><td>@NoArgsConstructor</td><td>无参构造器</td></tr><tr><td>@AllArgsConstructor</td><td>含参构造器</td></tr></tbody></table><p>直接添加注解是会报错的，还需要导入lombok的依赖，可以写注解然后根据IDEA自动导入依赖。</p><h2 id="2-CRUD操作">2.CRUD操作</h2><p>CRUD操作是mybatis使用的核心，这一部分以实操为主</p><p>首先进行工程的<strong>准备工作</strong>，和入门的工程基本一致。</p><p>关于实体类的创建的注意点：</p><ul><li>注意在数据库表结构中字段名是使用下划线分隔的，但是在实体类中我们采用驼峰命名</li></ul><h3 id="在mybatis中实现删除操作">在mybatis中实现删除操作</h3><p>根据主键删除</p><p>在Mapper接口中编写如下方法和语句，#{…}是占位符，用于将方法的参数提取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id =#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><h3 id="日志输出">日志输出</h3><p>在配置文件中添加</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis的日志，指定输出到控制台</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>再次运行程序，控制台中日志的输出如下</p><p><code>==&gt;  Preparing: delete from user where id =? ==&gt; Parameters: 9(Integer) &lt;==    Updates: 1</code></p><p>可以看到输出的SQL语句带有“？”，这个就被称为<strong>预编译SQL</strong>。</p><p>它有两大优势：</p><ul><li>性能更高</li><li>更安全（防止SQL注入）</li></ul><p><strong>为什么性能更高？</strong></p><p>需要从SQL语句具体的执行过程来分析</p><p>SQL语句执行</p><pre><code class="highlight mermaid">graph LR    A[Java] ==&gt; B(SQL语法解析检查)        subgraph SQL处理流程[缓存]        B ==&gt; C(优化SQL)        C ==&gt; D(编译SQL)    end        D ==&gt; E(执行SQL)</code></pre><p>对比两种方式</p><p>第一种</p><p><code>delete from user where id =1</code></p><p><code>delete from user where id =2</code></p><p><code>delete from user where id =3</code></p><p>第二种</p><p><code>delete from user where id = ?</code></p><p><code>1</code></p><p><code>2</code></p><p><code>3</code></p><p>这两种性能的差别就是因为这个缓存的过程，在Java发送SQL语句之后，会先经过检查、优化、编译，然后被缓存起来，之后再发送的时候会先检查缓存种是否有这个SQL语句，如果有就直接执行了。</p><p>第一种的话由于三条SQL语句每条都不相同，所以需要编译三次，而第二种的话由于是预编译的形式，所以只用编译一次，后边三条SQL语句就可以直接执行。</p><p>由此我产生一个问题，使用多态性是否也同样能提高Java的效率？</p><p><strong>为什么更安全？</strong></p><p>这里主要是与另一种占位符作对比</p><p>#{…}</p><ul><li><p>执行SQL时，会将#{…}替换为？，生成预编译SQL，会自动设置参数值</p></li><li><p>使用时机：参数传递，都使用#{…}</p></li></ul><p>${…}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：很少使用，如果对表名、列表进行动态设置时使用</li></ul><p>SQL注入：通过操作输入的数据来修改实现定义好的SQL语句，以达到执行代码对服务器进行攻击的方法</p><p>举个栗子🌰</p><p>账户的登录操作其实就是查询数据库中用户表的相应username和password是否都存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;miku&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果count(*)&gt;=1，那么我们就认为密码正确，就可以放行了。</p><p><strong>若使用的是${…}</strong></p><p>那么就是直接拼接的形式，如果传入的是这样的(“miku”,”‘ ’ or ‘1’=‘1”)</p><p>SQL语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;miku&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样就是一个恒成立的条件，那么也会直接放行。</p><p>这里只是举个例子，实际上现在是个网站都会防SQL注入，渗透也没有这么简单。</p><p><strong>若使用的是#{…}</strong></p><p>那么就会直接传递给？，就会直接拿传递的参数去数据库查询，不会更改SQL的基本逻辑。</p><h3 id="在mybatis中实现新增操作">在mybatis中实现新增操作</h3><p><strong>基本插入</strong></p><p>最简单的插入，不含占位符，无参数传递， <s>也最没有用</s></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(user.username, user.name, user.gender, user.age) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;values(&#x27;test&#x27;,&#x27;测试插入SQL&#x27;,1, 18)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>使用占位符传递，注意与实用类的属性名保持一致，使用小驼峰命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(id,user.username, user.name, user.gender, user.age) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;values(#&#123;id&#125;,#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><p><strong>获取主键</strong></p><p>在@Insert注解上添加注解@Options(keyProperty = “id”,useGeneratedKeys = true)会自动将生成的主键值，赋值给emp对象的id属性</p><h3 id="在mybatis中实现更新操作">在mybatis中实现更新操作</h3><p>很简单，会SQL语句就会更新操作</p><p>直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update user set username=#&#123;username&#125;&quot;+</span></span><br><span class="line"><span class="meta">&quot;, name=#&#123;name&#125;,gender=#&#123;gender&#125;, age=#&#123;age&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><h3 id="在mybatis中实现查询操作">在mybatis中实现查询操作</h3><p><strong>根据Id查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p>代码比较简单，就是设置一个传参的SQL语句就可以了</p><p>但是有一个问题，比如日期update_time这些MySQL和Java命名规范不一样的字段，是不会进行自动封装的，也就是说直接查是查不到的。相应有三种解决方案：</p><ul><li>配置自动映射</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>这是最简单也是最推荐的一种方案，只要保证符合命名规范，就能够自动封装</p><ul><li>使用别名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select update_time updateTime from user where id = #&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure><ul><li>使用@Results注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;updateTime&quot;, column = &quot;update_time&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;entryDate&quot;, column = &quot;entry_date&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure><p>后两种都比较繁琐，很少用</p><p><strong>条件查询</strong></p><p>考虑下面一个需求：</p><p>查询员工，根据员工的姓名、性别、入职时间搜索满足条件的员工信息。要求：员工姓名支持模糊匹配，性别精确匹配，入职时间进行范围查询。对查询的结果根据最后修改时间进行倒序排序。</p><p>编写出的SQL语句应该是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> entry_date <span class="keyword">between</span> </span><br><span class="line"><span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>用Mybatis实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and entry_date between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name ,Short gender,LocalDate begin,LocalDate end)</span>; </span><br></pre></td></tr></table></figure><p>注意，在这里使用了concat (‘%’,#{name},‘%’)函数，这是因为如果直接替换为‘%#{name}%’，是不合法的，因为?占位符不能出现在引号内，只能使用${…}，可是这样就会有性能低、安全性低的问题。那么就使用了SQL的函数concat，它用于将多个字符串拼接起来，这样就解决了问题。</p><p><strong>参数名说明</strong></p><p>在SpringBoot1.X版本，参数名前必须要加上@Param(“字段名”)，才能进行传递，这是因为在这个版本是不会把形参名保留下来，所以就必须要加上注解。</p><h2 id="3-XML映射文件">3.XML映射文件</h2><p>定义规范</p><ul><li>XML的文件名称与Mapper接口的名称一致，并且放置在相同包下（同包同名）</li><li>XML的namespace属性与Mapper接口的全限定名一致</li><li>XML中SQL语句的id与Mapper接口中的方法名一致，有返回值的要写resultType属性，这个是单条记录所封装的类型（也就是说如List结构，要写他的单挑记录的数据类型）</li></ul><h2 id="4-动态SQL">4.动态SQL</h2><p>学习动态SQL就是要学习其响应的标签</p><p>1.<if></if></p><ul><li>用判断条件是否成立，如果条件为true，则拼接SQL</li><li>形式：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.<where></where></p><ul><li>where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句开头的and或or</li></ul><p>3.<set></set></p><ul><li>动态地在行首插入set关键字，并会删除额外的逗号。（用在update语句中）</li></ul><p>4.<foreach></foreach></p><ul><li>SQL语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure><ul><li>接口方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBytes</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure><ul><li>XML映射文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBytes&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签属性说明：</p><p>collection：集合名称</p><p>item：集合遍历出来的元素/项，与下边占位符名称一致</p><p>separator：每一次遍历使用的分隔符</p><p>open：遍历开始前拼接的片段</p><p>close：遍历结束后拼接的片段</p><p>5.<sql> <include></include></sql></p><p>为提高复用性，可以将sql用<sql>标签记录，并使用<include>标签调用</include></sql></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--纪录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line">    select id,username,name,gender,age from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改历史：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2025-06-28 修改了部分错误，优化了文档结构&lt;/li&gt;
&lt;li&gt;2025-07-01 修复了代码块sql语句无法高亮的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Mybatis入门&lt;/h1&gt;
&lt;img src=&quot;/2025/06/08/</summary>
      
    
    
    
    
    <category term="Mybatis" scheme="http://cv-elevation.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="http://cv-elevation.github.io/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>http://cv-elevation.github.io/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/</id>
    <published>2025-06-03T14:30:09.000Z</published>
    <updated>2025-06-28T10:03:04.470Z</updated>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>增加了Web入门的基础知识，完善了结构</li></ul><h1>SpringBoot入门</h1><h2 id="0-概述">0.概述</h2><p>本篇只是对springboot的基本使用的总结，学习视频-&gt;<a href="https://www.bilibili.com/video/BV1m84y1w7Tb?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=67">Day05-01. 请求响应-概述_哔哩哔哩_bilibili</a>，使用postman进行调试。</p><h2 id="1-Web入门">1.Web入门</h2><h3 id="HTTP协议">HTTP协议</h3><p><strong>概述</strong></p><p>HTTP协议（HyperTextTransferProtocol），超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><p>特点：</p><ol><li>TCP协议：面向连接，安全</li><li>基于请求-响应模型：一次请求对应一次响应</li><li>HTTP是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的<ul><li>缺点：多次请求无法共享数据</li><li>优点：速度快</li></ul></li></ol><p><strong>请求协议</strong></p><p>请求数据包括三个部分：</p><p>请求行：请求数据第一行（请求方式，资源路径、协议）</p><p>请求头：第二行开始，格式key: value</p><p>请求体：POST请求，存放请求参数</p><p>两种请求方式对比：</p><ul><li><p>请求方式-get：请求参数在请求行中，没有请求体。get请求大小是有限制的。</p></li><li><p>请求方式-post：请求参数在请求体中，post请求大小是没有限制的。</p></li></ul><p><strong>响应协议</strong></p><p>响应数据包括三部分：</p><ul><li><p>响应行：相应数据第一行（协议、状态码、描述）</p></li><li><p>响应头：key: value</p></li><li><p>响应体：存放响应数据</p></li></ul><p>常见状态码：</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">响应中</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">客户端错误-处理发生错误，责任在客户端。如请求了不存在的资源、客户端未被授权、禁止访问</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">服务器错误-处理发生错误，责任在服务端。如程序抛出异常</td></tr></tbody></table><p>目前主要了解：200 处理成功，404 请求资源不存在，500 服务器端异常</p><p>更多状态码见网站：</p><p><a href="https://cloud.tencent.com/developer/chapter/13553">状态 | Status - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云</a></p><p><strong>协议解析</strong></p><p>服务器端要做的事情，一方面是要根据请求协议，解析浏览器发送的请求；另一方面是要根据响应协议，发送响应数据。</p><p>这种解析的工作较为固定，有不少<strong>Web服务器</strong>已经完成了这些工作，这样后端就只用关注业务逻辑的实现。常见的Web服务器有：Tomcat、IBM、jetty、WebLogic等</p><h3 id="Tomcat服务器">Tomcat服务器</h3><p>具体内容暂时不用详细了解，SpringBoot已经内嵌了Tomcat服务器，所以不用专门下载。介绍在此省略</p><h2 id="2-请求">2.请求</h2><p>此处请求的含义：后端接收来自浏览器端的请求指令，进行解析</p><h3 id="简单参数">简单参数</h3><p>请求：</p><p>GET指令：<code>http://localhost:8080/simpleParam?name=miku&amp;age=16</code></p><p>POST指令：<code>http://localhost:8080/simpleParam</code>请求体：<code>name=Miku&amp;age=16</code></p><p>Java代码：</p><p>原始方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在原始的Web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);<span class="comment">//需要与请求参数的key保持一致</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);<span class="comment">//需要与请求参数的key保持一致</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);</span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//繁琐，并且需要进行手动类型转换</span></span><br></pre></td></tr></table></figure><p>SpringBoot方式：</p><p>简单参数，参数名与<strong>形参列表名</strong>相同，定义形参即可接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(<span class="type">int</span> age,String name)</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;:&quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果形参名和请求参数名不一致，可以使用@RequestParam进行映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(<span class="type">int</span> age,<span class="meta">@RequestParam(name=&quot;name&quot;,required = true)</span> String username)</span> &#123;</span><br><span class="line">    System.out.println(username + <span class="string">&quot;:&quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解@RequestParam中有两个属性，一个是重定向，一个是required属性，第二个参数如果不写默认为true，即参数是必须的，如果缺少该参数会报400的状态码，表明客户端请求错误。</p><h3 id="实体参数">实体参数</h3><p>简单实体对象，请求参数名与形参对象属性名相同，定义POJO接收即可</p><p>请求：<code>http://localhost:8080/simplePojo?name=miku&amp;age=16</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simplePojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要创建User对象，声明相应属性、getset方法、toString方法</p><p>复杂实体对象，请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><p>请求：<code>http://localhost:8080/complexPojoname=miku&amp;age=16&amp;address.city=Tokyo&amp;address.country=Japan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/complexPojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(User1 user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组参数">数组参数</h3><p>请求参数名与形参数组名相同且请求参数为多个，定义数组类型形参即可接收参数</p><p>请求：<code>http://localhost:8080/arrayParam?friend=Miku&amp;friend=Kurumi&amp;friend=Marin</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(String[] friend)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String f : friend) &#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合参数">集合参数</h3><p>请求参数名与形参集合名称相同且请求参数为多个，@RequestParam绑定参数关系</p><p>请求：<code>http://localhost:8080/arrayParam?friend=Miku&amp;friend=Kurumi&amp;friend=Marin</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; friend)</span> &#123;</span><br><span class="line">    Iterator&lt;String&gt; iterator = friend.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日期参数">日期参数</h3><p>使用@DateTimeFormat注解完成日期参数格式转换</p><p>请求：<code>http://localhost:8080/dateParam?updateTime=2025-06-03 17:47:55</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateRequest</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Update Time: &quot;</span> + updateTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="json参数">json参数</h3><p>json参数根据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用@RequestBodt标识</p><p>请求：</p><p>请求行<code>http://localhost:8080/jsonParam</code></p><p>请求体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Miku&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span><span class="string">&quot;Japan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jsonParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonRequest</span><span class="params">(<span class="meta">@RequestBody</span> User1 user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User: &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径参数">路径参数</h3><p>通过请求URL直接传递该参数，使用{…}来表示该路径参数，需要使用@PathVariable获取路径参数</p><p>请求：<code>http://localhost:8080/path/1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ID: &quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取多个路径参数：</p><p>请求：<code>http://localhost:8080/path/1/Miku</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,<span class="meta">@PathVariable</span> String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-响应">3.响应</h2><p>@Response注解</p><p>位置：Controller类上或者方法上</p><p>作用：将方法返回值直接响应，若返回值是实体对象/集合，转为JSON格式响应</p><p>统一响应结果：</p><p>Result(code、msg、data)</p><h2 id="4-分层解耦">4.分层解耦</h2><h3 id="三层架构">三层架构</h3><p>三层架构包括控制层（Controller）、业务逻辑层（Service）、数据访问层（Dao）</p><pre><code class="highlight mermaid">graph LR浏览器==&gt;ControllerController==&gt;ServiceService==&gt;Dao</code></pre><ul><li><p>Controller：控制层，接收前端发送的请求，（对请求进行处理），进行响应</p></li><li><p>Service：业务逻辑层，处理具体的业务逻辑</p></li><li><p>Dao：数据访问层（持久层），负责数据的访问操作</p></li></ul><p>介绍完三层架构之后，那么就该谈到它的实现了，如果说只是用程序进行控制，那么就很容易会产生耦合，使得代码的拓展性大大降低。好在Spring给我们提供了IOC，我们可以通过Spring容器来对 <em>Bean对象</em> 进行控制，这样不同层的代码就相互独立起来。</p><h3 id="IOC（控制反转）">IOC（控制反转）</h3><p>涉及到四个注解：</p><p>@Component、@Controller、@Service、@Repository</p><p>后边三个都是@Component的衍生注解，实际功能与@Component类似，但是推荐使用后三个，当某一个部分不属于后三个中的任何一个的时候再使用@Component。</p><ul><li>声明bean的时候，可以使用value属性指定bean的名字，如果没用，则默认为类名的首字母小写形式</li><li>不只是建议：在使用springboot集成的web开发中，声明控制器bean只能用@Controller</li></ul><p>Bean组件扫描</p><p>上边的四大注解要想生效，还必须经过Bean组件扫描，使用的是@ComponentScan注解，该注解在启动类的声明注解中已经包含，默认范围是启动类所在包及其子包。可以通过在启动类的注解中加上重写的@ComponentScan来更改扫描路径，但是不推荐更改。</p><h3 id="DI（依赖注入）">DI（依赖注入）</h3><p>Spring中，依赖注入是通过@Autowired注解完成的，最简单的的情况下，就在Controller声明Service对象处或者Service声明Dao对象处加上@Autowired注解，就会根据<strong>类型自动匹配</strong>。</p><p>那么如果有多个业务逻辑呢？（以业务逻辑为例）</p><p>如果不进行处理，就会存在多个业务逻辑可供选择，直接就会报错。</p><p>有三个注解可以用来解决这个问题</p><ul><li>@Primary：见名知意，就是给不同的Service提供一个优先级，那么就会优先注入Primary的依赖</li><li>@Qualified：通过在@Autowired的地方加这个注解，通过其value属性指定相应的Service</li><li>@Resource：不使用@Autowired注解，使用名字进行注入，使用<code>@Resource(name = &quot;empServiceA&quot;)</code>进行注入，因为是根据名字进行注入的，也就不存在冲突</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改历史：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加了Web入门的基础知识，完善了结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;SpringBoot入门&lt;/h1&gt;
&lt;h2 id=&quot;0-概述&quot;&gt;0.概述&lt;/h2&gt;
&lt;p&gt;本篇只是对springboot的基本使用的总结，学习视频-&amp;gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://cv-elevation.github.io/tags/SpringBoot/"/>
    
    <category term="三层架构" scheme="http://cv-elevation.github.io/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-网络编程</title>
    <link href="http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2025-05-27T10:21:16.000Z</published>
    <updated>2025-06-03T08:31:39.953Z</updated>
    
    <content type="html"><![CDATA[<h1>网络编程</h1><p>软件架构：</p><p>CS架构：客户端-服务器</p><p>BS架构：浏览器-服务器</p><p>不过现在的很多软件都是一种<strong>混合开发</strong>，就是将CS架构和BS架构融合起来。</p><h2 id="网络编程三要素">网络编程三要素</h2><p>如何准确定位一台或多态主机：使用IP地址</p><p>如何定位主机上的特定的应用：使用端口号</p><p>如何可靠、高效地进行数据传输：规范通信协议</p><h3 id="IP地址">IP地址</h3><p>IP地址：网络中的一台计算机设备做唯一编号</p><p>IP地址分类：</p><p>分类方式一：</p><p>IPv4：占用4个字节，表示为<strong>a.b.c.d</strong>的形式，以点分十进制表示</p><p>IPv6：占用16个字节</p><p>分类方式二：</p><p>公网地址（万维网使用）和私网地址（局域网使用）192.168.开头的就是私有地址</p><p>本地回路地址：127.0.0.1</p><p>域名：便捷地记录ip地址</p><p><a href="http://www.baidu.com">www.baidu.com</a> kuoz.top</p><p>域名使用中通过DNS解析成IP再进行访问的</p><h3 id="端口号">端口号</h3><p>端口号可以唯一标识主机中的进程</p><p>不同的进程分配不同的端口号</p><p>范围：0~65535</p><h3 id="网络通信协议">网络通信协议</h3><p>OSI模型：过于理想化，没能实现</p><p>TCP/IP：分为应用层、传输层、网络层、物理+数据链路层</p><h2 id="InetAddress类">InetAddress类</h2><p>InetAddress类的一个实例就代表一个具体的ip地址</p><p>实例化方式：</p><p>InetAddress getByName(String host)</p><p>InetAddress getLocalHost()</p><h2 id="TCP协议和UDP协议">TCP协议和UDP协议</h2><p>计算机网络的重要重要指示，在此处简要了解。</p><h2 id="TCP的Socket网络编程">TCP的Socket网络编程</h2><p>网络上具有唯一标识的IP地址和端口号的组合，唯一可识别的标识符套接字（Socket）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建Socket实例</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;10.10.208.62&quot;</span>);</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(address, port);</span><br><span class="line">    <span class="comment">//通过Socket创建输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    os.write(<span class="string">&quot;嗨嗨嗨, 服务器我来辣!&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">//关闭Socket及相关流</span></span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建serverSocket实例</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    <span class="comment">//接收来自于客户端的Socket</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端连接成功，等待接收数据...&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;收到了来自&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;的连接&quot;</span>);</span><br><span class="line">    <span class="comment">//通过Socket创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//读写过程</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//当byte太小时，这里中文会因为中间被截断而出乱码，通过baos来解决</span></span><br><span class="line">        <span class="comment">//String message = new String(buffer, 0, len);</span></span><br><span class="line">        <span class="comment">//解决方法</span></span><br><span class="line">        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(baos.toString());</span><br><span class="line">    System.out.print(<span class="string">&quot;\n接收完毕&quot;</span>);</span><br><span class="line">    <span class="comment">//关闭Socket和相关流</span></span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端需要接收服务器发送的回复信息时出现的死锁问题：</p><p>客户端向服务器发送数据后，服务器向客户端<strong>回复信息</strong>，客户端接收服务器的接受信息。</p><p>如果直接在客户端创建输入流并打印出来，而不进行操作，那么服务器端会因为认为Socket没有终止发送信息而不回复<strong>回复信息</strong>，客户端没有接收到数据，那么也不会关闭Socket，这样就相互锁在了一起。</p><p>解决方法是在客户端发送数据后<code>socket.shutdownOutput();</code>来表示已经发送完毕。</p><h2 id="UDP网络编程">UDP网络编程</h2><p>TCP有三次握手，建立连接，是可靠的</p><p>UDP不需要建立连接，是不可靠的</p><h2 id="URL编程">URL编程</h2><p>URL(Uniform Resource Locator)：统一资源定位符</p><p>一个具体的URL就对应着互联网上某一资源的地址</p><p>URL的格式：</p><p>http://        127.0.0.1:8080/…？name=Tom</p><p>应用层协议 ip地址 端口号 资源地址 参数列表</p><p>URL类</p><p>Java中提供了URL类来进行URL的相关操作</p><p>常见的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取相应的url值</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProtocol</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPort</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFile</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getQuery</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//建立与服务器的连接</span></span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection;</span><br><span class="line"><span class="comment">//通过connection创建输入流并进行相应的读写......</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;网络编程&lt;/h1&gt;
&lt;p&gt;软件架构：&lt;/p&gt;
&lt;p&gt;CS架构：客户端-服务器&lt;/p&gt;
&lt;p&gt;BS架构：浏览器-服务器&lt;/p&gt;
&lt;p&gt;不过现在的很多软件都是一种&lt;strong&gt;混合开发&lt;/strong&gt;，就是将CS架构和BS架构融合起来。&lt;/p&gt;
&lt;h2 id=&quot;网络编程三</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
    <category term="TCP" scheme="http://cv-elevation.github.io/tags/TCP/"/>
    
    <category term="Socket" scheme="http://cv-elevation.github.io/tags/Socket/"/>
    
    <category term="URl" scheme="http://cv-elevation.github.io/tags/URl/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="http://cv-elevation.github.io/2025/05/25/Maven/"/>
    <id>http://cv-elevation.github.io/2025/05/25/Maven/</id>
    <published>2025-05-25T12:43:27.000Z</published>
    <updated>2025-06-02T12:52:30.520Z</updated>
    
    <content type="html"><![CDATA[<h1>Maven</h1><h2 id="概述">概述</h2><p>Maven是一款管理和构建Java项目的工具。基于POM（项目对象模型）的概念，通过一小段描述来管理项目</p><p><strong>Maven坐标</strong>，唯一标识和定位一个项目</p><p>groupId：组织</p><p>artifactId：模块名称</p><p>version：版本</p><p><strong>仓库</strong>：用于存储资源，管理jar包</p><p>本地仓库：自己计算机上的一个目录</p><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><p>远程仓库：一般由公司团队搭建的私有仓库</p><p>使用顺序：本地仓库&gt;远程仓库&gt;中央仓库</p><h2 id="依赖管理">依赖管理</h2><p>依赖：指当前项目运行所需的jar包</p><h3 id="配置依赖（在IDEA中）">配置依赖（在IDEA中）</h3><ol><li>在pom.xml中编写<dependencyies>标签</dependencyies></li><li>在<dependencyies>标签中使用<dependency>引入坐标</dependency></dependencyies></li><li>定义坐标的groupId，artifactId，version</li><li>点击刷新按钮，引入最新加入的坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递">依赖传递</h3><p>依赖具有传递性</p><ul><li><p>直接依赖：在当前项目中通过依赖配置建立的关系</p></li><li><p>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p></li><li><p>排除依赖：主动断开依赖的资源，被排除的资源无需指定版本</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="依赖范围">依赖范围</h3><table><thead><tr><th style="text-align:center">scope值</th><th style="text-align:center">主程序</th><th style="text-align:center">测试程序</th><th style="text-align:center">打包（运行）</th><th style="text-align:center">范例</th></tr></thead><tbody><tr><td style="text-align:center">compile(默认)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">log4j</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">junit</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">servlet-api</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">jdbc驱动</td></tr></tbody></table><p>可以通过下面的xml标签来设置依赖范围</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期">生命周期</h3><p>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。（运行后面的阶段，前面的阶段也会运行）</p><p>生命周期阶段（常见）</p><table><thead><tr><th>常见生命周期阶段</th><th></th></tr></thead><tbody><tr><td>clean</td><td>移除上一次构建生成的文件</td></tr><tr><td>compile</td><td>编译项目源代码</td></tr><tr><td>test</td><td>使用合适的单元测试框架运行测试</td></tr><tr><td>package</td><td>将编译后的文件打包，如：jar、war等</td></tr><tr><td>install</td><td>安装项目到本地仓库</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Maven&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;Maven是一款管理和构建Java项目的工具。基于POM（项目对象模型）的概念，通过一小段描述来管理项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maven坐标&lt;/strong&gt;，唯一标识和定位一个项目&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Maven" scheme="http://cv-elevation.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://cv-elevation.github.io/2025/05/24/MySQL/"/>
    <id>http://cv-elevation.github.io/2025/05/24/MySQL/</id>
    <published>2025-05-24T13:58:00.000Z</published>
    <updated>2025-07-03T08:55:10.651Z</updated>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>2025-07-01 修复了sql语句的代码快无法高亮的问题</li></ul><h1>MySQL-基础</h1><p>数据库管理系统DBMS</p><p>MySQL数据模型</p><p>客户端-&gt;DBMS-&gt;多个数据库-&gt;多个二维表</p><h2 id="SQL语句">SQL语句</h2><p>DDL(Data Definition Language)数据定义语言（数据库、表、字段）</p><p>DML(Data Manipulation Language)数据操作语言</p><p>DQL(Data Query Language)数据查询语言</p><p>DCL(Data Control Language)数据控制语言，管理数据库用户，控制数据库的访问权限</p><h3 id="DDL-数据定义">DDL-数据定义</h3><p><strong>数据库操作</strong></p><table><thead><tr><th style="text-align:center">大类</th><th style="text-align:center">语句</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">查询</td><td style="text-align:center">show databases</td><td style="text-align:center">查询所有数据库</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select database()</td><td style="text-align:center">查询当前数据库</td></tr><tr><td style="text-align:center">创建</td><td style="text-align:center">create database [if not exists] 数据库名</td><td style="text-align:center">（如果不存在）创建一个数据库</td></tr><tr><td style="text-align:center">使用</td><td style="text-align:center">use 数据库名;</td><td style="text-align:center">使用数据库</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">drop database [if exists] 数据库名</td><td style="text-align:center">删除数据库</td></tr></tbody></table><p><strong>表操作-查询</strong></p><table><thead><tr><th>语句</th><th>作用</th></tr></thead><tbody><tr><td>show tables;</td><td>查询当前数据库所有表</td></tr><tr><td>desc 表名;</td><td>查询表结构</td></tr><tr><td>show create table 表名;</td><td>查询指定表的建表语句</td></tr></tbody></table><p><strong>表操作-创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">    ……</span><br><span class="line">    字段n 字段类型 [约束] [comment 字段<span class="number">1</span>注释]</span><br><span class="line">)[comment 表注释];</span><br></pre></td></tr></table></figure><p>关于约束：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段所有数据唯一</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>字段未指定值则用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接</td><td>foreign key</td></tr></tbody></table><p>字段数据类型</p><p>数值</p><table><thead><tr><th>类型</th><th>大小（byte）</th><th>描述</th></tr></thead><tbody><tr><td>tinyint</td><td>1</td><td>小整数值</td></tr><tr><td>smallint</td><td>2</td><td>大整数值</td></tr><tr><td>mediumint</td><td>3</td><td>大整数值</td></tr><tr><td>int</td><td>4</td><td>大整数值</td></tr><tr><td>bigint</td><td>8</td><td>极大整数值</td></tr><tr><td>float</td><td>4</td><td>单精度浮点数</td></tr><tr><td>double</td><td>8</td><td>双精度浮点数</td></tr><tr><td>decimal</td><td></td><td>小数值（精确定点数)</td></tr></tbody></table><p>例如double,需使用double(整个数的长度，小数部分长度)</p><p>字符串</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>定长字符串</td></tr><tr><td>varchar</td><td>变长字符串</td></tr><tr><td>tinyblob</td><td>不超过255个字符的二进制数据</td></tr><tr><td>tinytext</td><td>短文本字符串</td></tr><tr><td>blob</td><td>二进制形式的长文本数据</td></tr><tr><td>text</td><td>长文本数据</td></tr><tr><td>midiumblob</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>midiumtext</td><td>中等长度文本数据</td></tr><tr><td>longblob</td><td>二进制形式的极大文本数据</td></tr><tr><td>longtext</td><td>极大文本数据</td></tr></tbody></table><p>日期时间</p><table><thead><tr><th></th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>1000-01-01至9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>time</td><td>3</td><td>-838:59:59至838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>year</td><td>1</td><td>1901至2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>datatime</td><td>8</td><td>1000-01-01 00:00:00至9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>timestamp</td><td>4</td><td>1970-01-01 00:00:01至2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p>修改、删除表结构</p><p>语言可以不掌握，但是要会图形化操作</p><h3 id="DML-数据操作">DML-数据操作</h3><p>添加数据：</p><p>insert into 表名(字段1，字段2，……) values(值1,值2,……);</p><ul><li>字符串应该和日期型数据应该包含在引号内</li><li>插入的数据大小，应该在字段的规定范围内</li></ul><p>修改数据</p><p>update 表名 set 字段名1=值1,字段名2=值2,…[where 条件]</p><p>删除数据</p><p>delete from 表名 [where 条件]</p><h3 id="DQL-数据查询">DQL-数据查询</h3><p><strong>基本查询：</strong></p><p>基本查询<br>select 字段列表 from 表名;<br>select * from 表名;（不建议在开发中使用这种方式，因为不直观）</p><p>起别名<br>select 字段 as ‘别名’ from 表名;as可省略</p><p>去重<br>select distinct 字段名称 from 表名;</p><p><strong>条件查询：</strong></p><p>select 字段列表 from 表名 where 条件列表;</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt; &gt;= &lt; &lt;= = !=或&lt;&gt;</td><td>比较</td></tr><tr><td>between…and …</td><td>在某个范围之内（含最小值、最大值）</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配（_ 匹配单个字符，%匹配任意个字符）</td></tr><tr><td>is  null</td><td>是null</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>and或&amp;&amp;</td><td>并且</td></tr><tr><td>or或||</td><td>或</td></tr><tr><td>not或！</td><td>非</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;初音未来&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">&gt;</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">NOT null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">!=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">&gt;=</span><span class="number">2</span> <span class="operator">&amp;&amp;</span> job<span class="operator">&lt;=</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">&gt;=</span><span class="number">2</span> <span class="keyword">and</span> job<span class="operator">&lt;=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">in</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;____&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%三&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>聚合函数：</strong></p><p>select 聚合函数(字段列表) from 表名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="comment">-- 统计数量</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(image) <span class="keyword">from</span> emp;<span class="comment">-- null值不参与运算</span></span><br><span class="line"><span class="comment">-- 统计平均值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 统计最大值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 统计最小值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 统计和</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(age) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>分组查询：</strong></p><p>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</p><p>where与having区别</p><ul><li>执行时间不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤；</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>执行顺序：where &gt; 聚合函数 &gt; having</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他的字段毫无意义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据性别分组，统计男性员工和女性员工的数量</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 根据性别分组，统计男性员工和女性员工的平均年龄</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">avg</span>(age) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 查询年龄小于15的员工，并根据性别进行分组，获取员工数量大于等于2的性别(对聚合函数判断，要用having)</span></span><br><span class="line"><span class="keyword">select</span> gender <span class="string">&#x27;性别&#x27;</span>,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="string">&#x27;gendersum&#x27;</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">15</span> <span class="keyword">group</span> <span class="keyword">by</span> gender <span class="keyword">having</span> gendersum<span class="operator">&gt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>排序查询：</strong></p><p>select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方式;</p><p>排序方式：</p><p>ASC：升序（默认值）</p><p>DESC：降序</p><p>如果多字段排序，当第一个字段值相同的时候，才会根据第二个字段进行排序</p><p><strong>分页查询：</strong></p><p>select 字段列表 from 表名 limit 起始索引,查询记录数;</p><ul><li>起始索引从0开始，起始索引=（查询页码-1）*每页显示记录数；</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL是limit；</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。</li></ul><p>顺序</p><ul><li>编写顺序：select&gt;from&gt;where&gt;group by&gt;order by&gt;limit</li><li>执行顺序：from&gt;where&gt;group by&gt;select&gt;order by&gt;limit</li></ul><h3 id="DCL-数据控制">DCL-数据控制</h3><p><strong>管理用户：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询用户</span></span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;<span class="comment">-- 可以在任意主机访问该数据库</span></span><br><span class="line"><span class="comment">-- 修改用户密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span><span class="string">&#x27;1234&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>权限控制：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询权限</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> db01.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 撤销权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> db01.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>多个权限之间，用逗号分隔；</li><li>授权时，数据库名和表名可以使用*进行通配，代表所有。</li></ul><h2 id="函数">函数</h2><h3 id="字符串函数">字符串函数</h3><p>concat(s1,s2,s3,…,sn)字符串拼接</p><p>lower(str)转大写</p><p>upper(str)转小写</p><p>lpad(str,n,pad)用pad左填充</p><p>rpad(str,n,pad)用pad右填充</p><p>trim(str)去除头部和尾部的空格</p><p>substring(str,start,len)截取字符串，索引从1开始</p><h3 id="数值函数">数值函数</h3><p>ceil向上取整</p><p>floor向下取整</p><p>mod(x,y)求x/y的模</p><p>rand0~1之间的随机数</p><p>round(x,y)对x四舍五入后保留y位小数</p><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 产生一个6位数的随机验证码</span></span><br><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>,<span class="number">0</span>),<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="日期函数">日期函数</h3><p>curdate()返回当前的日期</p><p>curtime()返回当前的时间</p><p>now()返回当前的日期和时间</p><p>year(date)返回日期的年份</p><p>month(date)返回日期的月份</p><p>day(date)返回日期的天数</p><p>date_add(date,interval expr type)返回一个推移指定时间长度后的日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(now(),<span class="type">interval</span> <span class="number">70</span> <span class="keyword">day</span>);</span><br></pre></td></tr></table></figure><p>datediff(date1,date2)求取两个日期之间的天数，前边减后边的</p><h3 id="流程函数">流程函数</h3><p>if(value,t,f)如果value为true，返回t，为false则返回f</p><p>ifnull()如果第一个值为null，则返回第二个值；如果第一个值非null，则返回第一个值</p><p>case when [value1] then [res1]… else [default] end如果value1为true，返回res1,…否则返回default</p><p>case [expr] when [val1] then [res1]… else [default] end如果expr的值为val1则返回res1,…否则返回default</p><h2 id="约束">约束</h2><h3 id="约束-概述">约束-概述</h3><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段所有数据唯一</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>字段未指定值则用默认值</td><td>default</td></tr><tr><td>检查约束(8.0.16版本之后)</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接</td><td>foreign key</td></tr></tbody></table><h3 id="约束-外键约束">约束-外键约束</h3><p>外键约束是让两张表之间的数据建立连接，从而保证数据的一致性。</p><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign key</span>(外键字段名) <span class="keyword">references</span> 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span>(外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign key</span> 外键名称;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter table</span> emp <span class="keyword">add constraint</span> fk_dept_id <span class="keyword">foreign key</span>(dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign key</span> fk_dept_id;</span><br></pre></td></tr></table></figure><h3 id="外键删除更新行为">外键删除更新行为</h3><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>no action</td><td>当在父表中删除/更新对应记录时，首先检查该记录中是否有对应外键，如果有则不允许更改</td></tr><tr><td>restrict</td><td>当在父表中删除/更新对应记录时，首先检查该记录中是否有对应外键，如果有则不允许更改</td></tr><tr><td>cascade</td><td>当在父表中删除/更新对应记录时，首先检查该记录中是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td></tr><tr><td>set null</td><td>当在父表中删除对应记录时，首先检查该记录中是否有对应外键，如果有则设置为null（前提是允许为null）</td></tr><tr><td>set default</td><td>父表有变更时，子表将外键设置成一个默认的值（Innodb不支持）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span>(外键字段) <span class="keyword">references</span> 主表(主表列名) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure><h2 id="多表查询">多表查询</h2><h3 id="多表关系">多表关系</h3><p><strong>一对多</strong></p><p>通常在多的一方添加外键，关联到一的一方的主键</p><p><strong>多对多</strong></p><p>建立第三方中间表，中间表至少包含两个外键，分别关联两方主键</p><p><strong>一对一</strong></p><p>通常用于单表查询，或者将其拆分，并在任意一方加入外键来关联。注意在外键中添加unique约束以保证一对一</p><h3 id="连接查询">连接查询</h3><p><strong>内连接</strong></p><p>隐式内连接：select 字段列表 from  表1,表2 where 条件…；<br>显示内连接：select 字段列表 from  表1 [inner] join 表2 on 连接条件…；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> emp.name,dept.name <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 如果为表起了别名，那么就不能通过表名限制字段</span></span><br><span class="line"><span class="keyword">select</span> e.name,d.name <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"><span class="comment">-- 显式内连接</span></span><br><span class="line"><span class="keyword">select</span> emp.name,dept.name <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><ul><li>内连接查询的是两张表交集的部分</li></ul><p><strong>外连接</strong></p><p>左外连接</p><p>select 字段列表 from 表1 left [outer] join 表2 on 条件…;</p><p>相当于查询表1（左表）的所有数据包括交集部分的数据</p><p>右外连接</p><p>select 字段列表 from 表1 right [outer] join 表2 on 条件…;</p><p>相当于查询表2（右表）的所有数据包括交集部分的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>,dept.name <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">select</span> dept.<span class="operator">*</span>,emp.<span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 使用左外连接实现右外连接</span></span><br><span class="line"><span class="keyword">select</span> dept.<span class="operator">*</span>,emp.<span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><p>常用左外连接实现</p><p><strong>自连接</strong></p><p>自连接查询使用内连接查询和外连接查询均可，重点是要给一张表<strong>起两个不同的别名</strong></p><p>内连接查询（例）</p><p>select 字段列表 from 表A 别名A join 表 A 别名B on 条件…;</p><p>外连接查询（例）</p><p>select 字段列表 from 表A 别名A left join 表 A 别名B on 条件…;</p><h3 id="联合查询">联合查询</h3><p>对于联合查询实际上就是将多次查询的结果合并起来，形成一个新的查询结果集，要使用到关键字union，union all。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A…</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B…；</span><br></pre></td></tr></table></figure><ul><li>对于联合查询的多张表的列数和字段类型需要保持一致</li><li>union all会将全部的数据直接贴合在一起，union会对合并之后的数据去重</li></ul><h3 id="子查询">子查询</h3><p><strong>标量子查询</strong></p><p>子查询的结果是单个的值，就称为标量子查询</p><p>例如如下的需求，查询某某部门的所有员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分步查询</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;<span class="comment">-- 查询某部门（假设为研发部）的对应id</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;<span class="comment">-- 由得到的id查询员工信息</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>);<span class="comment">-- 直接将第一个结果替换id进行查询</span></span><br></pre></td></tr></table></figure><p><strong>列子查询</strong></p><p>查询的结果为一列多行，就称为列子查询</p><p>常用的操作符</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>not in</td><td>不在指定的集合范围之内</td></tr><tr><td>any</td><td>子查询返回的列表中，有一个满足即可</td></tr><tr><td>some</td><td>等同于any</td></tr><tr><td>all</td><td>子查询返回的列表的所有值必须满足</td></tr></tbody></table><p><strong>行子查询</strong></p><p>查询的结果为一行多列，就称为列子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与“张无忌”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>表子查询</strong></p><p>查询的结果为多行多列，就称为表子查询。通常将表子查询的结果作为一个新的表进行多表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与“鹿杖客”，“宋远桥”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary)<span class="keyword">in</span> (<span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> &quot;鹿杖客&quot; <span class="keyword">or</span> name <span class="operator">=</span>&quot;宋远桥&quot;);</span><br><span class="line"><span class="comment">-- 查询入职日期是&quot;2006-01-01&quot;之后的员工信息，及其部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate<span class="operator">&gt;</span><span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id<span class="operator">=</span>d.id</span><br></pre></td></tr></table></figure><h2 id="事务">事务</h2><p>事务是一组操作的集合，这组操作，要么全部执行成功，要么全部执行失败</p><h3 id="事务操作">事务操作</h3><p>第一种方式</p><ul><li>查看/设置事务提交方式<br>select @@autocommit;<br>set @@autocommit=1;</li><li>提交事务<br>commit;</li><li>回归事务<br>rollback;</li></ul><p>第二种方式</p><ul><li>开启事务<br>start transaction或begin;</li><li>提交事务<br>commit;</li><li>回归事务<br>rollback;</li></ul><h3 id="事务的四大特性ACID">事务的四大特性ACID</h3><p>原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么<br>全部失败回滚</p><p>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态</p><p>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p><p>持久性：一旦事务提交，则其所做的修改会永久保存到数据库</p><h3 id="并发事务问题">并发事务问题</h3><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">一个事务读到另一个事物还没有提交的数据</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">一个事务按条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="事务隔离级别">事务隔离级别</h3><p>事务的隔离级别就是来解决并发事务问题的，下表表示解决情况。√表示未解决，×表示解决</p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read uncommitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Read committed</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Repeatable Read(默认)</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>查看事务的隔离级别</p><p>select @@transaction_isolation;</p><p>设置事务的隔离级别</p><p>set [global/session] transaction isolation level [隔离级别];</p><h1>MySQL-进阶</h1><h2 id="存储引擎">存储引擎</h2><h3 id="MySQL体系结构">MySQL体系结构</h3><ul><li>连接层</li><li>服务层</li><li>引擎层</li><li>存储层</li></ul><h3 id="简介">简介</h3><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型</p><p>创建表时指定存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 [comment 注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [comment 注释]</span><br><span class="line">)engine<span class="operator">=</span>存储引擎名[comment 表注释];</span><br></pre></td></tr></table></figure><h3 id="存储引擎的特点和选择">存储引擎的特点和选择</h3><p>特点</p><ul><li><p>InnoDB：</p><ul><li><p>MySQL目前默认的存储引擎；</p></li><li><p>支持<strong>事务、外键、行级锁</strong>；</p></li><li><p>默认每张表对应与磁盘中的一个.ibd文件。</p></li></ul></li></ul><p>InnoDB的逻辑存储结构：在InnoDB的逻辑存储结构中，Page是操作的最小单元，Extent的大小固定为1M，Page大小固定为16K</p><p><img src="/2025/05/24/MySQL/image-20250629154012042.png" alt="image-20250629154012042"></p><ul><li><p>MyISAM：</p><ul><li>MySQL早期的默认存储引擎；</li><li>不支持事务、外键，支持表锁不支持行锁，访问速度快；</li><li>文件：sdi：存储表结构的信息，MYD：存储数据，MYI：存储索引</li></ul></li><li><p>MEMORY：</p><ul><li>数据存放在内存中，由于受到硬件的问题、断电问题的影响，只能将这些表作为临时表或缓存使用</li><li>内存存放、hash索引（默认）</li><li>.sdi文件：存储表结构的信息</li></ul></li></ul><p><strong>存储引擎的选择：</strong></p><ul><li><p>InnoDB：是MySQL的默认存储引擎，支持<strong>事务、外键</strong>。如果应用对<strong>事务的完整性</strong>又比较高的要求，在并发条件下要求<strong>数据的一致性</strong>，数据操作除了插入和查询之外，还包含很多的<strong>更新、删除操作</strong>，那么InnoDB存储引擎是比较合适的选择。</p></li><li><p>MyISAM：如果应用是以读取和插入为主，很少有更新、删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎比较合适。</p></li><li><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保证数据的安全性。</p></li></ul><p>说是这么说，但是实际上主要用的就是InnoDB了，MyISAM的使用场景基本被nosql系列的数据库取代了，而MEMORY的场景被Redis取代了。</p><h2 id="索引">索引</h2><h3 id="概述">概述</h3><p>索引（index）本质上一种数据结构，是为了帮助数据库高效获取数据。</p><p><strong>索引的优势</strong>：提高数据<strong>检索的效率</strong>，降低数据库的IO成本；通过索引列对数据进行排序，降低数据<strong>排序</strong>的成本，降低CPU的消耗。</p><p>索引的劣势：占用空间；降低了更新表操作insert、update、delete的效率</p><p>索引大大提高了查询效率，却也降低了insert、update、delete的效率，不过一般主要业务都是查询，所以瑕不掩瑜。</p><h3 id="索引的结构">索引的结构</h3><p><strong>B+Tree索引:</strong></p><p>MySQL常用（默认）的结构就是<strong>B+Tree（多路平衡搜索树）</strong></p><ul><li>每一个节点，可以存储<strong>多个key</strong></li><li>所有的数据存储在叶子节点，非叶子节点仅用于索引数据</li><li>叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询</li></ul><p>这种结构就像一个矮胖的树，避免了二叉树容易<strong>层级过深</strong>的问题。</p><p><strong>Hash索引：</strong></p><p>Hash索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><p>如果两个（或多个）键值，映射到一个相同的键位，他们就产生了hash冲突（也称hash碰撞），可以通过链表来解决。</p><p><strong>特点</strong></p><ol><li>Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常高于B+Tree索引</li></ol><p><strong>存储引擎支持</strong></p><p>在MySQL中，支持hash索引的是MEMORY引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p><p><strong>思考：为什么InnoDB采用B+Tree索引？</strong></p><ul><li>相对于二叉树，层级更少，搜索效率更高</li><li>对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量的数据，只能增加树的高度，导致性能降低</li><li>相对于hash索引，hash索引不支持范围匹配及排序操作而B+Tree支持</li></ul><p>其他的还有R-tree空间索引、Full-text全文索引。之后如果没有特别说明，索引都是指B+Tree索引</p><h3 id="索引的分类">索引的分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td><strong>主键索引</strong></td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td><strong>唯一索引</strong></td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td><strong>常规索引</strong></td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td><strong>全文索引</strong></td><td>查找文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><p><strong>聚集索引（Clustered Index）</strong></p><ul><li>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</li><li>必须有，而且只有一个</li></ul><p><strong>二级索引（Secondary Index）</strong></p><ul><li>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</li><li>可以存在多个</li></ul><p><strong>聚集索引的选取规则：</strong></p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li><li>如果没有主键也没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><p>结构如图所示：</p><p><img src="/2025/05/24/MySQL/image-20250629214044891.png" alt="image-20250629214044891"></p><p>有趣的问题：InnoDB的主键索引的B+Tree高度为多高？</p><p>假设，一行的数据为1K，那么一页（16K），就能存放16行这样的数据。InnoDB的指针占用6个字节的空间，主键类型如果为bigint，就占用8个字节的空间。</p><p>先算出一页中有多少个主键，设为x，则$x*8+(n+1)<em>6=16</em>1024$，得x约为1170，那么就有1171个指针</p><p>如果树的高度为2：</p><p>那么存放数据有：$1171*16=18736$</p><p>如果树的高度为3：</p><p>那么存放的数据有：$1171^2*16=21939856$</p><h3 id="索引的语法">索引的语法</h3><ul><li>创建索引</li></ul><p>create [unique] index 索引名 on 表名(字段名,…);</p><ul><li>查看索引</li></ul><p>show index from 表名</p><ul><li>删除索引</li></ul><p>drop index 索引名 on 表名;</p><ul><li>建表时如果添加了主键约束，那么就会自动创建主键索引，是性能最高的</li><li>建表时添加唯一约束，本质就是添加了唯一索引</li></ul><h3 id="SQL性能分析">SQL性能分析</h3><p><strong>SQL执行频率</strong></p><p>通过如下指令，可以查看当前数据库的Insert、update、delete、select的访问频次</p><p><code>show global status like 'Com_______'</code></p><p><strong>慢查询日志</strong></p><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启MySQL慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#设置慢查询时间为2s，SQL语句执行时间超过2s，就会被视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><p>慢日志文件记录在/var/lib/mysql/localhost-slow.log</p><p><strong>profile详情</strong></p><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p><p><code>SELECT @@have_profiling；</code></p><p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：</p><p><code>SET profiling = 1;</code></p><p>执行一系列的业务SQL操作，然后通过以下指令可以查看指令的执行耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line">#查看特定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line">#查看指定uery_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>explain执行计划</strong></p><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>语法：</p><p>直接在select语句之前加上关键字 explain / desc</p><p><code>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件；</code></p><p>EXPLAIN 执行计划各字段含义：</p><p>➢ id</p><p>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</p><p>➢ select_type</p><p>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。</p><p>➢ <strong>type</strong></p><p>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。</p><p>➢ <strong>possible_keys</strong></p><p>显示可能应用在这张表上的索引，一个或多个</p><p>➢ <strong>key</strong><br>实际使用的索引，如果为NULL，则没有使用索引。</p><p>➢ <strong>key_len</strong><br>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p><p>➢ <strong>rows</strong><br>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</p><p>➢ filtered<br>表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。</p><p>加粗的是需要重点关注的</p><h3 id="索引的使用">索引的使用</h3><p><strong>最左前缀法则</strong></p><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指查询从索引最左列开始，并且不跳过索引中的列。如果跳跃了某一列，索引将部分失效（后面的字段索引失效）</p><p><strong>范围查询</strong></p><p>联合索引中，出现范围查询（&gt;,&lt;），范围查询右侧的列索引失效</p><p>因此，在业务允许的范围内，尽量使用&gt;=,&lt;=这样的范围查询</p><p><strong>索引列运算</strong></p><p>不要在索引列上进行运算操作，<strong>索引将失效</strong>。</p><p><strong>字符串不加引号</strong></p><p>字符串类型字段使用时，不加引号，<strong>索引将失效</strong>。</p><p><strong>模糊查询</strong></p><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>因此在大数据量的情况下，要尽量避免头部模糊匹配的情况。</p><p><strong>or连接的条件</strong></p><p>用or分割开的条件，如果or前的条件中的列有索引，而后边的列没有索引，那么涉及的索引都不会用到。</p><p>解决办法：针对没有索引的列添加索引即可。</p><p><strong>数据分布影响</strong></p><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><strong>SQL提示</strong></p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化的目的。</p><p>指令：</p><p>use index：</p><p><code>explain select * from 表名 use index(索引名字) where profession = ‘软件工程’</code></p><p>ignore index：</p><p><code>explain select * from 表名 ignore index(索引名字) where profession = ‘软件工程’</code></p><p>force index：</p><p><code>explain select * from 表名 force index(索引名字) where profession = ‘软件工程’</code></p><p><strong>覆盖索引</strong></p><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到），减少select *。</p><ul><li>关于Extra的参数：</li></ul><p>using index condition：查找使用了索引，但是需要回表查询数据</p><p>using where；using index：查找使用了索引，但是需要的数据在索引列中能够找到，所以不需要回表查询数据</p><p>所以后者的性能更高</p><ul><li>SQL优化问题：一张表，有四个字段（id,username,password,status）由于数据量大，需要对以下SQL语句进行优化，如何才是最优方案？<br><code>select id,username,password from tb_user where username='itcast'</code></li><li>答：需对username和password两个字段创建联合索引</li></ul><p><strong>前缀索引</strong></p><p>当字段类型是字符串（varchar、text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样就可以大大节约索引空间，从而提高索引效率。</p><ul><li>语法<br><code>create index idx_xxx on table_name(column(n))</code></li><li>前缀长度<br>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询的效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br><code>select count(distinct email)/count(*) from tb_user;</code><br><code>select count(distinct substring(email,1,5))/count(*) from tb_user;</code></li></ul><p>前缀索引的查询流程</p><p><img src="/2025/05/24/MySQL/image-20250630163104143.png" alt="image-20250630163104143"></p><p><strong>单列索引与联合索引</strong></p><p>单列索引：即一个索引只包含单个列</p><p>联合索引：即一个索引包含了多个列</p><p>在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议使用联合索引，而非单列索引。</p><p>例如：</p><ul><li>单列索引情况：</li></ul><p><code>explain select id,phone,name from tb_user where phone = '1111111323' and name ='xxx'</code></p><p>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</p><ul><li>联合索引情况：</li></ul><p><code>create unique index idx_phone_name on tb_user(phone,name)</code></p><p>由于创建的是联合索引，索引字段列表的顺序会有影响，参见<strong>最左前缀法则</strong>。</p><p><strong>索引设计原则</strong></p><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。  （几百万条）</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><h2 id="SQL优化">SQL优化</h2><h3 id="插入数据">插入数据</h3><p><strong>insert优化</strong></p><ul><li><p>批量插入<br><code>insert into tb_test values(1,'Tom),(2,'Cat)...</code></p></li><li><p>手动提交事务</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom),(2,&#x27;</span>Cat<span class="string">&#x27;)...;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">commit;</span></span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入</p></li></ul><p><strong>大批量数据插入</strong></p><p>如果一次性需要插入大量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端连接上服务器时，加上参数 —local-infile</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">--local-infile -u root -p</span></span><br><span class="line"><span class="comment">#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="attr">set</span> <span class="string">global local_infile=1;</span></span><br><span class="line"><span class="comment">#执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line"><span class="attr">load</span> <span class="string">data local infile &#x27;/root/sql1.log&#x27; into table `tb_user` field terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="主键优化">主键优化</h3><p><strong>数据组织方式</strong></p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table <strong>IOT</strong>）。</p><p><strong>页分裂</strong></p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据（如果一行数据太大，会行溢出），根据主键排列。</p><p><strong>页合并</strong></p><p>当删除一行记录时，实际上记录没有被物理删除，只是被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><p>当页中删除的记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（左或右）看看是否可以将两个页合并以优化空间使用。</p><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><h3 id="order-by优化">order by优化</h3><ol><li><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p></li><li><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p></li></ol><p><strong>创建索引时指定升降序的指令：</strong></p><p><code>create index idx_user_age_phone_aa on tb_user(age asc/desc, phone asc/desc);</code></p><p>如果没有指定，默认为降序。</p><p><strong>总结</strong></p><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li></ol><h3 id="group-by优化">group by优化</h3><p><strong>总结</strong></p><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h3 id="limit优化">limit优化</h3><p>一个常见的问题就是当limit的起始索引非常大时，此时MySQL需要排序起始索引前的记录，仅仅返回起始索引后的部分记录，其他记录废弃，查询排序的代价非常大。</p><p>优化思路：</p><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询的形式进行优化。</p><h3 id="count优化">count优化</h3><p>对比MyISAM和InnoDB：</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li><li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p><strong>count的几种用法</strong></p><ul><li>count是一个聚合函数，对于结果的返回集，一行行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值。</li><li>用法：count(*)，count(主键)、count(字段)、count(1)</li></ul><p><strong>几种用法的对比</strong></p><p>count（主键）<br>InnoDB 引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)。</p><p>count（字段）<br>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p><p>count（1）<br>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字&quot;1&quot;进去，直接按行进行累加。</p><p>count（*）<br>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p><p>按照效率排序的话，count(字段) &lt; count(主键id) &lt; count(1) ≈ count( * )，所以尽量使用count( * )。</p><h3 id="update优化">update优化</h3><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁，导致并发性能的降低。</p><h2 id="存储对象">存储对象</h2><h3 id="视图">视图</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p><strong>基本语法</strong></p><ul><li><p>创建视图<br><code>CREATE [OR REPLACE] VIEW 视图名称(列名列表) AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]</code></p></li><li><p>查询视图<br>查看创建视图语句：<code>SHOW CREATE VIEW 视图名称;</code><br>查看视图数据：<code>SELECT * FROM 视图名称……;</code></p></li><li><p>修改视图<br>方式一：<code>CREATE [OR REPLACE] VIEW 视图名称(列名列表) AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]</code><br>方式二：<code>ALTER VIEW 视图名称(列名列表) AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]</code></p></li><li><p>删除视图<br><code>DROP VIEW [IF EXISTS] 视图名称 [视图名称] …</code></p></li></ul><p><strong>视图的检查选项</strong></p><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行（如插入、更新、删除），以确保其符合视图的定义。MySQL允许基于另一个视图创建视图，并会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：CASCADED 和 LOCAL，默认值为 CASCADED。</p><ul><li>cascaded</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v3 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> v2 <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>CASCADED选项会级联检查所有底层视图的条件，可以认为在依赖的视图v1上也添加了with cascaded check option</li><li>在示例中，v2视图会同时检查v1和v2自身的条件</li><li>v3视图由于没有指定WITH CHECK OPTION，不会检查自身的条件，但是会检查v1和v2的条件</li></ol><ul><li>local</li></ul><p>使用local，会递归地去检查依赖的视图是否要进行检查，如果依赖的视图有with check option则也要进行检查。</p><p><strong>视图的更新</strong></p><ol><li><p>视图的更新要求视图中的行与基础表中的行之间存在一对一的关系。</p></li><li><p>如果视图包含以下任何一项，则该视图不可更新：</p><ul><li><p>聚合函数或窗口函数（如 SUM()、MIN()、MAX()、COUNT() 等）</p></li><li><p>DISTINCT</p></li><li><p>GROUP BY</p></li><li><p>HAVING</p></li><li><p>UNION 或 UNION ALL</p></li></ul></li></ol><p><strong>视图的作用</strong></p><ol><li>简单<ul><li>视图可以简化用户对数据的理解和操作。</li><li>常用的查询可以定义为视图，避免用户每次操作时重复指定全部条件。</li></ul></li><li>安全<ul><li>数据库可以授权，但无法精确到特定行或列。</li><li>通过视图，用户只能查询和修改他们被允许访问的数据。</li></ul></li><li>数据独立<ul><li>视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ul></li></ol><h3 id="存储过程">存储过程</h3><p><strong>介绍</strong></p><p>存储过程（procedure）是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p><p><strong>特点</strong></p><ul><li>封装，复用</li><li>可以接收参数，也可以返回数据</li><li>减少网络交互，效率提升</li></ul><p><strong>基本语法</strong></p><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- SQL语句;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 存储过程名称();</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;数据库名字&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名字;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> 存储过程名字;</span><br></pre></td></tr></table></figure><p>注意：在命令行中创建存储过程时，需要通过关键字delimiter指定SQL语句的结束符。</p><p>格式就是<code>delimiter 指定结束符;</code></p><p><strong>变量</strong></p><blockquote><p>系统变量<br>MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p></blockquote><ul><li>查看系统变量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables;<span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;...&#x27;</span>;<span class="comment">-- 模糊匹配查找变量</span></span><br><span class="line"><span class="keyword">select</span> @@[session.<span class="operator">|</span>global.]系统变量名;<span class="comment">-- 查看指定变量的值</span></span><br></pre></td></tr></table></figure><ul><li>设置系统变量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[session.<span class="operator">|</span>global.]系统变量名 <span class="operator">=</span> 值; </span><br></pre></td></tr></table></figure><p>注意：如果没有指定session/global，默认是session，会话变量。</p><p>MySQL服务重启后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf中配置。</p><blockquote><p>用户定义变量</p><p>用户根据需要自己定义的变量，用户变量不用提前声明在用的时候用“@变量名”使用就可以。其作用域为当前连接。</p></blockquote><ul><li>赋值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以使用=也可以使用:=，推荐使用:=</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr[,<span class="variable">@var_name2</span><span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr[,<span class="variable">@var_name2</span>:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="comment">-- 第二种方法，使用select语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr[,<span class="variable">@var_name2</span><span class="operator">=</span>expr]...;</span><br><span class="line"><span class="comment">-- 将查询的字段赋值给变量</span></span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure><p>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p><blockquote><p>局部变量</p><p>根据需要定义的在局部生效的变量，访问之前，需要使用declare声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的begin…end块。</p></blockquote><ul><li>声明</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型[<span class="keyword">default</span> ...];</span><br></pre></td></tr></table></figure><ul><li>赋值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p><strong>if判断</strong></p><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>作为输入参数，调用时需要传入值</td><td>默认类型</td></tr><tr><td>OUT</td><td>作为输出参数，可作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可作输入参数，也可作输出参数</td><td></td></tr></tbody></table><ul><li>用法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span> 参数名称 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- sql语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><strong>case</strong></p><p>语法一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">    <span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">    [<span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">    [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>语法二</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">    [<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">    [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>语法一通过比较固定的 <code>case_value</code> 与 <code>when_value</code> 进行匹配。</li><li>语法二通过判断条件表达式 <code>search_condition</code> 执行对应的逻辑。</li></ul><p><strong>循环</strong></p><blockquote><p>while</p><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判断条件，如果条件为true，则执行逻辑，否则不执行逻辑</span></span><br><span class="line">while 条件 do</span><br><span class="line"><span class="keyword">sql</span>逻辑...</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><blockquote><p>repeat</p><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p></blockquote><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先执行一次循环，如果满足条件，则退出，如果不满足则继续执行循环</span></span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">sql</span>逻辑...</span><br><span class="line">until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure><blockquote><p>loop</p><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。l</p></blockquote><p>loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环。</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:]loop</span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">end</span> loop [end_label];</span><br><span class="line">leave 标记;<span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">iterate 标记;<span class="comment">-- 直接进入下一次循环</span></span><br></pre></td></tr></table></figure><p><strong>游标</strong></p><ol><li><p>游标（CURSOR）</p><ul><li>用于存储查询结果集的数据类型，在存储过程和函数中可对结果集进行循环处理。</li></ul></li><li><p>游标的使用步骤</p><ul><li><p>声明游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句；  </span><br></pre></td></tr></table></figure></li><li><p>打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称；  </span><br></pre></td></tr></table></figure></li><li><p>获取游标记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量 [,变量]；  </span><br></pre></td></tr></table></figure></li><li><p>关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称；  </span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>条件处理程序</strong></p><p>条件处理程序(Handler)可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><p>具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value[,condition_value]... statement;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handler_action</span><br><span class="line">continue:继续执行当前程序</span><br><span class="line">exit:终止执行当前程序</span><br><span class="line">condition_value</span><br><span class="line"><span class="keyword">SQLSTATE</span> sqlstate_value:状态码，如<span class="number">02000</span></span><br><span class="line"><span class="keyword">SQLWARNING</span>:所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line"><span class="keyword">NOT</span> FOUND:所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line"><span class="keyword">SQLEXCEPTION</span>:所有没有被<span class="keyword">SQLWARNING</span>或<span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure><p>状态码可以参考mysql的官方文档：</p><p><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">MySQL :: MySQL 8.0 Error Reference :: 2 Server Error Message Reference</a></p><h3 id="存储函数">存储函数</h3><p>存储函数（function）是有返回值的存储过程，存储函数的参数只能是IN类型。</p><p>具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称()</span><br><span class="line"><span class="keyword">returns</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL：不包含SQL语句</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</li></ul><p>存储函数并不常用，因为它能完成的事情，存储过程都能完成，但是存储函数还要求必须有返回值，并不普适。</p><h3 id="触发器">触发器</h3><p>介绍</p><ol><li>触发器（trigger）是与表有关的数据序列，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</li><li>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</li></ol><table><thead><tr><th>触发器类型</th><th>NEW/OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tbl_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name;<span class="comment">-- 如果没有指定schema_name，默认为当前数据库</span></span><br></pre></td></tr></table></figure><h2 id="锁">锁</h2><h3 id="概述-2">概述</h3><p><strong>介绍</strong></p><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤为重要，也更加复杂。</p><p><strong>分类</strong></p><p>MySQL中的锁，按照锁的力度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ol><h3 id="全局锁">全局锁</h3><p><strong>介绍</strong></p><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取<strong>一致性</strong>视图，保证数据的完整性。</p><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>一般的备份操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 itcast&gt;itcast.sql</span><br></pre></td></tr></table></figure><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ol><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ol><p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p123456 itcast&gt;itcast.sql</span><br></pre></td></tr></table></figure><h3 id="表级锁">表级锁</h3><p><strong>介绍</strong></p><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ol><p><strong>表锁</strong></p><p>对于表锁，又可以分为两类：</p><ol><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ol><p>语法</p><ol><li>加锁：lock tables 表名… read/write</li><li>释放锁：unlock tables/客户端断开连接</li></ol><p>读锁示意图：</p><p><img src="/2025/05/24/MySQL/image-20250702220250532.png" alt="image-20250702220250532"></p><p>加读锁后两个客户端都只能进行查询操作</p><p>写锁示意图：</p><p><img src="/2025/05/24/MySQL/image-20250702220304768.png" alt="image-20250702220304768"></p><p>加写锁后只有加锁客户端既可以读又可以写，其他客户端既不能读也不能写</p><p><strong>元数据锁</strong></p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong></p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read / write</td><td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>查看元数据锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure><p><strong>意向锁</strong></p><p>意向锁主要解决的问题是在InnoDB引擎中加的行锁和表锁加锁冲突的问题</p><ol><li>意向共享锁（IS）：由语句 select … lock in share mode添加。</li><li>意向排他锁（IX）：由insert、update、delete、select … for update 添加。</li></ol><p>兼容性</p><ol><li>意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</li><li>意向排他锁（IX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</li></ol><p>查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_scema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="行级锁">行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ol><p><strong>行锁</strong></p><p>InnoDB实现了以下两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><table><thead><tr><th>当前锁类型|请求锁类型</th><th>S (共享锁)</th><th>X (排他锁)</th></tr></thead><tbody><tr><td>S (共享锁)</td><td>兼容</td><td>冲突</td></tr><tr><td>X (排他锁)</td><td>冲突</td><td>冲突</td></tr></tbody></table><p>执行SQL语句时加的锁类型：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p><strong>间隙锁/临键锁</strong></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止<strong>幻读</strong>。</p><ol><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁。</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ol><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改历史：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2025-07-01 修复了sql语句的代码快无法高亮的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;MySQL-基础&lt;/h1&gt;
&lt;p&gt;数据库管理系统DBMS&lt;/p&gt;
&lt;p&gt;MySQL数据模型&lt;/p&gt;
&lt;p&gt;客户端-&amp;gt;DBMS-&amp;gt;多个</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://cv-elevation.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-Java8的两个重要特性</title>
    <link href="http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/"/>
    <id>http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/</id>
    <published>2025-05-06T13:14:11.000Z</published>
    <updated>2025-06-28T12:38:45.145Z</updated>
    
    <content type="html"><![CDATA[<h1>jdk8 新特性</h1><h2 id="函数式接口：">函数式接口：</h2><p>函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface)</p><p>为什么要有函数式接口？因为只有给函数式接口创建对象时，才可以使用lambda表达式。</p><p>java8中声明的函数式接口所在包：java.util.function</p><p>4个基本的函数式接口：（直接copy宋的课件）</p><table><thead><tr><th>函数式接口</th><th>称谓</th><th>参数类型</th><th>用途</th></tr></thead><tbody><tr><td><code>Consumer&lt;T&gt;  </code></td><td>消费型接口</td><td>T</td><td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)  </code></td></tr><tr><td><code>Supplier&lt;T&gt;  </code></td><td>供给型接口</td><td>无</td><td>返回类型为T的对象，包含方法：<code>T get()  </code></td></tr><tr><td><code>Function&lt;T, R&gt;  </code></td><td>函数型接口</td><td>T</td><td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)  </code></td></tr><tr><td><code>Predicate&lt;T&gt;  </code></td><td>判断型接口</td><td>T</td><td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)  </code></td></tr></tbody></table><h2 id="lambda表达式">lambda表达式</h2><p>lambda表达式怎么用？</p><p>语法规则：</p><p>-&gt;的左边：lambda的形参列表，参数的类型都可以省略。如果形参列表只有一个，则一对()也可以省略。</p><p>-&gt;的右边：lambda体，只有一行执行语句时，则一对{}可以省略，如果有return，则也要省略。</p><p>写法举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (o1 , o2) -&gt; Integer.compara(o1,o2);</span><br></pre></td></tr></table></figure><p>lambda表达式的本质：</p><p>一方面，lambda表达式作为接口实现类的对象；另一方面，lambda表达式是匿名函数。</p><h2 id="方法引用">方法引用</h2><ul><li><p>方法引用可以看作是lambda表达式的进一步刻画。</p></li><li><p>当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。</p><ul><li>当满足一定的条件是，我们还可以使用方法引用或构造器引用替换lambda表达式。</li></ul></li></ul><p>方法引用作为了函数式接口的实例。</p><p>格式：</p><ol><li>对象 :: 实例方法<br>要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。<br>注意此方法b是非静态方法，需要对象调用。</li><li>类 :: 静态方法<br>要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个静态方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。<br>注意此方法b是静态方法，需要类调用。</li><li>类 :: 实例方法<br>要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第一个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。<br>注意此方法b是非静态方法，需要对象调用。但是形式上，写出对象a所属的类。</li></ol><p><strong>构造器引用</strong></p><p>格式：<code>类名 :: new</code></p><p>调用了类名对应的类中某一个确定的构造器。具体调用的是类中的哪一个构造器，取决于函数式接口的抽象方法的形参列表。</p><p><strong>数组引用</strong></p><p>格式：<code>数组名 :: new</code></p><h2 id="StreamAPI">StreamAPI</h2><p>Stream使用的流程</p><ol><li>实例化</li><li>一系列的中间操作</li><li>执行终止操作</li></ol><p><strong>实例化：</strong></p><p>三种方法：</p><p>方法一：通过集合</p><p>例如：对于List结构，直接使用<code>list.stream()</code>就能创建stream实例</p><p>方法二：通过数组</p><p>类似方法一，使用Arrays的静态方法stream()<code>Arrays.stream(arr)</code></p><p>方法三：streamof</p><p><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) </code>: 返回一个流</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>中间操作：</strong></p><p>筛选与切片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建Stream</span></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">//filter(Predicate p) 过滤</span></span><br><span class="line">    stream.filter(e -&gt; e.getAge() &gt; <span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//limit(long maxSize) 限制元素个数</span></span><br><span class="line">    list.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//skip(long n) 跳过前n个元素</span></span><br><span class="line">    list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//distinct() 去掉重复元素</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">22</span>,<span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//map(Function f) 映射</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//        list.stream().map(s -&gt; s.toUpperCase()).forEach(System.out::print);</span></span><br><span class="line">        list.stream().map(String :: toUpperCase).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//sorted(Comparator c) 排序</span></span><br><span class="line">    Integer [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.stream(arr).sorted((o1, o2) -&gt; o2-o1).forEach(System.out::print);</span><br><span class="line"></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    list.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>终止操作：</strong></p><p>匹配与查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    <span class="comment">//allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line">    System.out.println(list.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">20</span>));</span><br><span class="line">    <span class="comment">//anyMatch(Predicate p) 检查是否至少匹配一个元素</span></span><br><span class="line">    System.out.println(list.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="number">20</span>));</span><br><span class="line">    <span class="comment">//findFirst() 返回第一个元素</span></span><br><span class="line">    System.out.println(list.stream().findFirst());</span><br><span class="line">    <span class="comment">//forEach(Consumer c) 迭代</span></span><br><span class="line">    list.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归约</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    <span class="comment">//reduce(T identity, BinaryOperator b) 归约</span></span><br><span class="line">    System.out.println(list.stream().map(Employee::getAge).reduce(<span class="number">0</span>,Integer::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    <span class="comment">//collect(Collectors.toList()) 收集到List</span></span><br><span class="line">    List&lt;Integer&gt; list1 = list.stream().map(Employee::getAge).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//collect(Collectors.toSet()) 收集到Set</span></span><br><span class="line">    Set&lt;Integer&gt; set = list.stream().map(Employee::getAge).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//collect(Collectors.toMap()) 收集到Map</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = list.stream().map(Employee::getAge).collect(Collectors.toMap(e -&gt; e, e -&gt; e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaSE学习先到这里，中间跳了集合源码、网络编程、反射的内容，之后的考试是真的有点多（光电你罪该万死，数电、单片机、量子力学、热统都让我一个学期考还一堆实验课Щ(◣д◢)Щ），后续打算边用边学，保持写代码的习惯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;jdk8 新特性&lt;/h1&gt;
&lt;h2 id=&quot;函数式接口：&quot;&gt;函数式接口：&lt;/h2&gt;
&lt;p&gt;函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface)&lt;/p&gt;
&lt;p&gt;为什么要有函数式接口？因为只有给函数式接口创建对象时</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-File类与IO流</title>
    <link href="http://cv-elevation.github.io/2025/05/05/JavaSE-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/"/>
    <id>http://cv-elevation.github.io/2025/05/05/JavaSE-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/</id>
    <published>2025-05-05T08:23:19.000Z</published>
    <updated>2025-05-05T08:23:56.051Z</updated>
    
    <content type="html"><![CDATA[<h1>File类与IO流</h1><h2 id="File类的实例化">File类的实例化</h2><p>File类位于java.io包下，本章中涉及到的相关流也都声明在java.io包下。</p><p>File类的一个对象，对应于操作系统下的一个文件或文件目录（或文件夹）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/*相对路径：相对于某一个文件目录来讲的相对位置。在IDEA中</span></span><br><span class="line"><span class="comment">      * 在IDEA中，如果使用单元测试方法，相对路径是相对于当前的module</span></span><br><span class="line"><span class="comment">      *          如果使用main方法，相对路径是相对于当前的project</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/io/test.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;iotest&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public File(String parent, String child)</span></span><br><span class="line"><span class="comment">//参数1：一定是一个文件目录</span></span><br><span class="line"><span class="comment">//参数2：文件目录或者是一个文件</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/io&quot;</span>, <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">      <span class="comment">//public File(File parent, String child)</span></span><br><span class="line"><span class="comment">//参数1：一定是一个文件目录</span></span><br><span class="line"><span class="comment">//参数2：文件目录或者是一个文件</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file1,<span class="string">&quot;file3.txt&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="IO流">IO流</h2><p>流(Stream)的分类：</p><ul><li>流向不同：输入流、输出流</li><li>处理单位不同：字符流、字节流</li><li>角色不同：节点流、处理流</li></ul><table><thead><tr><th style="text-align:center">（抽象基类）</th><th style="text-align:center">输入流</th><th style="text-align:center">输出流</th></tr></thead><tbody><tr><td style="text-align:center">字节流</td><td style="text-align:center">InputStream</td><td style="text-align:center">OutputStream</td></tr><tr><td style="text-align:center">字符流</td><td style="text-align:center">Reader</td><td style="text-align:center">Writer</td></tr></tbody></table><h3 id="FIleReader、FileWriter：">FIleReader、FileWriter：</h3><p>步骤：</p><ol><li>创建读写的File对象</li><li>创建输入流或输出流</li><li>具体读入或写出<ul><li>读入：read(char[] cbuffer)</li><li>写出：write(String str)/write(char[] cbuffer,0,len)</li></ul></li><li>关闭流资源，防止内存泄露</li></ol><p>使用举例：复制hello.txt文件到hello_copy.txt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello_copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(dest);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] cbuffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读入字符个数</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(cbuffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭流资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>) fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>) fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileInputStream、FIleOutputStream">FileInputStream、FIleOutputStream</h3><p>对于字符流，只能用来操作文本文件，不能用来操作非文本文件。</p><p>对于字节流，通常用来处理非文本文件。但是如果是要进行文本文件的复制操作，也可以用字节流处理。</p><p>文本文件：.txt、.java、.c、.cpp、.py等</p><p>非文本文件：.doc、.xls、.jpg、.mp3等</p><p>参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;guest.png&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;guest_copy.png&quot;</span>);</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流">缓冲流</h3><p>作用：提升文件读写的效率</p><p>对应关系</p><table><thead><tr><th style="text-align:center">节点流</th><th style="text-align:center">处理流</th><th>使用方法</th></tr></thead><tbody><tr><td style="text-align:center">FileOutputStream</td><td style="text-align:center">BufferedOutputStream</td><td>write(byte[] buffer,0,len)、flush()</td></tr><tr><td style="text-align:center">FileInputStream</td><td style="text-align:center">BufferedInputStream</td><td>read(byte[] buffer)</td></tr><tr><td style="text-align:center">FIleReader</td><td style="text-align:center">BufferedReader</td><td>read(char[] cbuffer）、readLn()</td></tr><tr><td style="text-align:center">FileWriter</td><td style="text-align:center">BufferedReader</td><td>write(char[] cbuf,0,len)、write(String str)、flush()</td></tr></tbody></table><p>实现步骤：</p><ol><li>创建File对象、流的对象（文件流、缓冲流）</li><li>使用缓冲流实现读取数据或写出数据<ul><li>读取：int read(char[] cbuf/byte[] buffer)每次将数据读入到cbuf或buffer数组中，并返回读入到数组中元素的个数</li><li>写出：void write(String str)/write(char[] cbuf)：将str或cbuf写出到文件中void write(byte[] buffer)将byte[]写出到文件中</li></ul></li><li>关闭资源</li></ol><p>参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用bufferinputstream和bufferoutputstream来复制一个图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四暗刻单骑.mp4&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四暗刻单骑2.mp4&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">50</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭外层流,由于外层流的关闭会自动关闭内层流，所以可以省略内层流关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;复制文件耗时：&quot;</span> + (endTime - beginTime) +</span><br><span class="line">                       <span class="string">&quot;ms&quot;</span>);<span class="comment">//67ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换流">转换流</h3><p>实现字符与字节之间的转换</p><p>InputStreamReader：将一个输入型的字节流转换为输入型的字符流</p><p>OutputStreamReader：将一个输出型的字符流转换为输出型的字节流</p><p>编码、解码程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *使用InputStreamReader来读取文件</span></span><br><span class="line"><span class="comment"> * 1.解码gbk编码的文件</span></span><br><span class="line"><span class="comment"> * 2.使用utf-8编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//create File object</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;toUTF8.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//create FileInputStream</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="comment">//create InputStreamReader, declare charset parameter</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//create FileOutputStream</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line">    <span class="comment">//create OutputStreamWriter, declare charset parameter</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//read and write</span></span><br><span class="line">    <span class="type">char</span>[] cBuffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cBuffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//close stream</span></span><br><span class="line">    osw.close();</span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象流">对象流</h3><p><strong>API</strong></p><p>ObjectInputStream</p><p>ObjectOutputStream</p><p><strong>对象的序列化机制：</strong></p><p>序列化过程：ObjectOutputStream，将内存中的Java对象保存在文件中或通过网络传输出去。</p><p>反序列化过程：ObjectInputStream，将文件中或通过网络传输过来的数据还原为内存中的Java对象。</p><p><strong>自定义类要想实现序列化要求：</strong></p><ol><li>自定义类要实现接口Serializable；</li><li>要求自定类要声明一个全局常量：static final long serialVersionUID；</li><li>自定义类的各个属性也必须可序列化，基本数据类型本身就可以序列化，引用数据类型要满足1、2。</li></ol><ul><li>如果不声明一个UID，系统会自动声明一个，如果修改类的话，这个标识会改变，从而无法正常反序列化。</li><li>如果类中的属性声明为transient或static，则相应属性不会被序列化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;File类与IO流&lt;/h1&gt;
&lt;h2 id=&quot;File类的实例化&quot;&gt;File类的实例化&lt;/h2&gt;
&lt;p&gt;File类位于java.io包下，本章中涉及到的相关流也都声明在java.io包下。&lt;/p&gt;
&lt;p&gt;File类的一个对象，对应于操作系统下的一个文件或文件目录（或文件夹</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-泛型</title>
    <link href="http://cv-elevation.github.io/2025/05/04/JavaSE-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://cv-elevation.github.io/2025/05/04/JavaSE-%E6%B3%9B%E5%9E%8B/</id>
    <published>2025-05-04T12:55:08.000Z</published>
    <updated>2025-05-04T12:56:07.527Z</updated>
    
    <content type="html"><![CDATA[<h1>泛型</h1><h2 id="泛型在集合、比较器中的使用">泛型在集合、比较器中的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型在List中的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//举例：将学生成绩保存在ArrayList中</span></span><br><span class="line">    <span class="comment">//标准写法：</span></span><br><span class="line">    <span class="comment">//ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//jdk7的新特性：类型推断</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">56</span>); <span class="comment">//自动装箱</span></span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">88</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    <span class="comment">//当添加非Integer类型数据时，编译不通过</span></span><br><span class="line">    <span class="comment">//list.add(&quot;Tom&quot;);//编译报错</span></span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//不需要强转，直接可以获取添加时的元素的数据类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型在Map中的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">67</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jim&quot;</span>,<span class="number">56</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Rose&quot;</span>,<span class="number">88</span>);</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        map.put(67,&quot;Jack&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历key集</span></span><br><span class="line">    Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String str:keySet)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历value集</span></span><br><span class="line">    Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = values.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历entry集</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleComparator1</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Circle&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Circle o1, Circle o2)</span> &#123;</span><br><span class="line">        <span class="comment">//不再需要强制类型转换，代码更简洁</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.getRadius(), o2.getRadius());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHasGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CircleComparator1</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleComparator1</span>();</span><br><span class="line">        System.out.println(com.compare(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(com.compare(&quot;圆1&quot;, &quot;圆2&quot;));</span></span><br><span class="line">        <span class="comment">//编译错误，因为&quot;圆1&quot;, &quot;圆2&quot;不是Circle类型，是String类型，编译器提前报错，</span></span><br><span class="line">        <span class="comment">//而不是冒着风险在运行时再报错。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在创建集合对象的时候，可以指明泛型的类型。</p><p>具体格式为：List<Integer> list = new ArrayList<Integer>();</Integer></Integer></p></li><li><p>JDK7.0时，有新特性，可以简写为：</p><p>List<Integer> list = new ArrayList&lt;&gt;(); //类型推断</Integer></p></li><li><p>泛型，也称为泛型参数，即参数的类型，只能使用引用数据类型进行赋值。（不能使用基本数据类型，可以使用包装类替换）</p></li><li><p>集合声明时，声明泛型参数。在使用集合时，可以具体指明泛型的类型。一旦指明，类或接口内部，凡是使用泛型参数的位置，都指定为具体的参数类型。如果没有指明的话，看做是Object类型。</p></li></ul><h2 id="自定义泛型">自定义泛型</h2><ul><li>声明类或接口时，在类名或接口名后面声明泛型类型，我们把这样的类或接口称为<code>泛型类</code>或<code>泛型接口</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名&lt;类型变量列表&gt; [extends 父类] [implements 接口名]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">[修饰符] interface 接口名&lt;类型变量列表&gt; [implements 接口名]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ul><li>声明方法时，在【修饰符】与返回值类型之间声明类型变量，我们把声明了类型变量的方法，称为泛型方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] &lt;类型变量列表&gt; 返回值类型 方法名([形参列表])[<span class="keyword">throws</span> 异常列表]&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：java.util.Arrays类中的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型在继承上的体现">泛型在继承上的体现</h2><p>继承必须要泛型一致才算。</p><p>下面代码就是想表达这个意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//泛型不同</span></span><br><span class="line">ArrayList&lt;Object&gt; list = <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//        list=list1;//编译不通过</span></span><br><span class="line">        <span class="comment">//泛型相同</span></span><br><span class="line">        List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">        list2 = list3;<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure><h2 id="通配符">通配符</h2><h3 id="通配符的使用">通配符的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    list = list1;<span class="comment">//编译通过</span></span><br><span class="line">    list = list2;<span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有通配符的泛型的读写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//允许读取，读取的值的类型为Object类型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//不允许写入（除了null）</span></span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有限制条件的通配符">有限制条件的通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;     <span class="comment">//(无穷小 , Number]</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number子类的引用调用</span></span><br><span class="line"></span><br><span class="line">&lt;? <span class="built_in">super</span> Number&gt;      <span class="comment">//[Number , 无穷大)</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number父类的引用调用</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;泛型&lt;/h1&gt;
&lt;h2 id=&quot;泛型在集合、比较器中的使用&quot;&gt;泛型在集合、比较器中的使用&lt;/h2&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-集合框架</title>
    <link href="http://cv-elevation.github.io/2025/05/04/JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://cv-elevation.github.io/2025/05/04/JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2025-05-04T08:48:30.000Z</published>
    <updated>2025-05-04T08:49:39.775Z</updated>
    
    <content type="html"><![CDATA[<h1>集合框架</h1><h2 id="Java集合框架体系">Java集合框架体系</h2><p>java.util.Collection：存储一个一个的数据</p><ul><li>子接口：List：存储有序、可重复的数据（“动态”数组）<ul><li>ArrayList(主要实现类)、LinkedList、Vector</li></ul></li><li>子接口：Set：存储无序、不可重复的数据（中学数学中的集合）<ul><li>HashSet(主要实现类)、LinkedHashSet、TreeSet</li></ul></li></ul><p>java.util.Map：存储一对一对的数据（key-value键值对，类似于中学数学的函数）</p><ul><li><ul><li>HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties</li></ul></li></ul><h2 id="Collection接口">Collection接口</h2><h3 id="常用方法">常用方法</h3><p>Collection中有15个常用的方法，其实现类可以使用</p><h3 id="集合和数组的转换">集合和数组的转换</h3><p>集合–&gt;数组toArray</p><p>数组–&gt;集合调用Arrays的静态方法asList</p><p>向Collection中添加元素的要求：元素所属类一定要重写equals方法</p><p>因为Collection的相关方法（contains、remove）在使用时要调用equals方法</p><h3 id="遍历">遍历</h3><p>iterator迭代器：</p><p>iterator迭代器常用来遍历集合元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());<span class="comment">//next()指针下移，将下移以后的元素返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（补充）增强for循环：</p><p>作用：遍历数组和集合</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(要遍历的集合或数组的元素类型 临时变量 : 要遍历的集合或数组变量)&#123;</span><br><span class="line">    操作临时变量输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>针对于集合来讲，增强for循环底层仍使用的是迭代器</li><li>增强for循环执行的过程中，是将集合或数组中的元素依次赋值给临时变量，注意，循环体中对临时变量的修改，可能不会导致原有集合或数组元素的修改</li></ul><h2 id="List接口">List接口</h2><h3 id="常用方法-2">常用方法</h3><p>第一部分：</p><p>Collection中声明的15个方法</p><p>第二部分：因为LIst是有序的，所以会增加一些索引方法</p><p>常用方法大致可分为：增、删、改、查、插、长度、遍历</p><table><thead><tr><th style="text-align:left">方法声明</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">add(Object ele)</td><td>添加ele元素</td></tr><tr><td style="text-align:left">addAll(Collection eles)</td><td>将eles中的所有元素添加进来</td></tr><tr><td style="text-align:left">remove(Object ele)</td><td>删除指定索引的元素，并返回此元素</td></tr><tr><td style="text-align:left">remove(int index)</td><td>删除指定索引的元素，并返回此元素</td></tr><tr><td style="text-align:left">set(int index , Object ele)</td><td>设置指定索引位置的元素为ele</td></tr><tr><td style="text-align:left">get(int index)</td><td>获取指定索引元素</td></tr><tr><td style="text-align:left">add(int index , Object ele)</td><td>在指定索引插入ele元素</td></tr><tr><td style="text-align:left">addAll(int index , Collection eles)</td><td>从指定索引开始将eles中的所有元素插入进来</td></tr><tr><td style="text-align:left">size()</td><td>获取长度</td></tr><tr><td style="text-align:left">interator()</td><td>遍历</td></tr><tr><td style="text-align:left">增强for循环</td><td>遍历</td></tr></tbody></table><h3 id="List接口不同实现类的对比">List接口不同实现类的对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">使用情况</th><th style="text-align:center">线程安全性</th><th style="text-align:center">数据结构</th><th style="text-align:center">添加、查找效率</th><th style="text-align:center">插入、删除效率</th></tr></thead><tbody><tr><td style="text-align:center">ArrayList</td><td style="text-align:center">主要实现类</td><td style="text-align:center">线程不安全</td><td style="text-align:center">Object[]</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">LinkedList</td><td style="text-align:center">———</td><td style="text-align:center">———</td><td style="text-align:center">双向链表</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">Vector</td><td style="text-align:center">基本被抛弃</td><td style="text-align:center">线程安全</td><td style="text-align:center">Object[]</td><td style="text-align:center">低</td><td style="text-align:center">低</td></tr></tbody></table><h2 id="Set接口">Set接口</h2><p>相较于List、Map，Set的使用频率相对较低。常用来过滤重复数据。</p><p>理解：</p><ul><li><p>无序性：</p><ul><li><p>与添加的元素的位置有关，不像ArrayList是依次紧密排列的。这里是根据添加元素的哈希值，计算的其在数组中的存储位置，表现为无序性；</p></li><li><p>不等于随机性；</p></li><li><p>不等于添加的元素的顺序和遍历元素的顺序不一致。</p></li></ul></li><li><p>不可重复性：</p><ul><li>添加到Set中的元素是不能相同的。比较的标准，需要根据hashCode()得到的哈希值以及equals方法得到的boolean型的结果。哈希值相同且equals方法返回true则相同。</li></ul></li></ul><p>添加到HashSet和LinkedSet的元素的要求：重写equals和hashCode，二者结果尽量保持一致性。</p><p><strong>TreeSet实现类</strong></p><p>添加元素的要求：</p><ul><li>添加到TreeSet中的元素必须是同一个类型的对象；</li><li>添加的元素需要考虑排序。</li></ul><p>注意：</p><ul><li>判断数据相同的标准，不再是hashCode和equals方法，也就意味着不用再重写这两个方法；</li><li>比较元素大小或者是否相同的标准就是自然排序或定制排序中comparaTo或compare的返回值。如果相等，则认为两个对象相等，则后一个相等的元素就不能添加到TreeSet中。</li></ul><h3 id="常用方法-3">常用方法</h3><p>即为Collection中声明的15个抽象方法，没有新增的方法。</p><h3 id="Set接口不同实现类的对比">Set接口不同实现类的对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">关系</th><th style="text-align:center">数据结构</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">HashSet</td><td style="text-align:center">主要实现类</td><td style="text-align:center">Hashmap</td><td style="text-align:center">———</td></tr><tr><td style="text-align:center">LinkedHashSet</td><td style="text-align:center">HashSet的子类</td><td style="text-align:center">Hashmap+双向链表</td><td style="text-align:center">便于频繁的查询操作</td></tr><tr><td style="text-align:center">TreeSet</td><td style="text-align:center">———</td><td style="text-align:center">红黑树</td><td style="text-align:center">可按元素的指定属性的大小顺序遍历</td></tr></tbody></table><h2 id="Map接口">Map接口</h2><p><strong>HashMap中元素的特点</strong></p><ul><li><p>HashMap中的所有key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。–&gt;key所在的类要重写hashCode和equals</p></li><li><p>HashMap中的所有value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。–&gt;value所在的类要重写equals</p></li><li><p>HashMap中的一个key-value，就构成了一个entry。</p></li><li><p>HashMap中的所有entry彼此之间是不可重复的、无序的。所有的entry就构成一个Set集合。</p></li></ul><p><strong>TreeMap实现类</strong></p><p>TreeMap和TreeSet底层接口一致，使用上只要将TreeSet中元素的地位替换为TreeMap中的Key的地位即可。也就是说，对TreeSet元素的要求都更换为对key的要求。</p><h3 id="常用方法-4">常用方法</h3><table><thead><tr><th>增</th><th>删</th><th>改</th><th>查</th><th>长度</th><th>遍历</th></tr></thead><tbody><tr><td>put(Object key,Object value)</td><td>Object remove(Object Key)返回value</td><td>put(Object key, Object value)</td><td>Object get(Object key)获取key对应的value</td><td>size()</td><td>遍历key集：Set keySet()</td></tr><tr><td>putAll(Map m)</td><td></td><td>putAll(Map m)</td><td></td><td></td><td>遍历value集：Collection values()</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>遍历entry集：Set entrySet()</td></tr></tbody></table><h3 id="Map接口及其实现类的对比">Map接口及其实现类的对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">关系</th><th>线程安全性</th><th style="text-align:center">效率</th><th style="text-align:center">健壮性</th><th style="text-align:center">数据结构</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">HashMap</td><td style="text-align:center">主要实现类</td><td>线程不安全</td><td style="text-align:center">高</td><td style="text-align:center">好，可以添加null</td><td style="text-align:center">数组+单向链表+红黑树</td><td style="text-align:center">———</td></tr><tr><td style="text-align:center">LinkedHashMap</td><td style="text-align:center">HashMap子类</td><td>———</td><td style="text-align:center">———</td><td style="text-align:center">———</td><td style="text-align:center">HashMap+双向链表</td><td style="text-align:center">便于频繁的遍历操作</td></tr><tr><td style="text-align:center">TreeMap</td><td style="text-align:center">———</td><td>———</td><td style="text-align:center">———</td><td style="text-align:center">———</td><td style="text-align:center">红黑树</td><td style="text-align:center">可按元素的指定属性的大小顺序遍历</td></tr><tr><td style="text-align:center">Properties</td><td style="text-align:center">———</td><td>———</td><td style="text-align:center">———</td><td style="text-align:center">———</td><td style="text-align:center">———</td><td style="text-align:center">键值对是String类型</td></tr><tr><td style="text-align:center">Hashtable</td><td style="text-align:center">类似HashMap，但是废弃</td><td>线程安全</td><td style="text-align:center">低</td><td style="text-align:center">不好，不可添加null</td><td style="text-align:center">数组+单向链表</td><td style="text-align:center">———</td></tr></tbody></table><h3 id="Collections工具类">Collections工具类</h3><p>Collections是一个操作List、Set、Map等集合的工具类—&gt;v162</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;集合框架&lt;/h1&gt;
&lt;h2 id=&quot;Java集合框架体系&quot;&gt;Java集合框架体系&lt;/h2&gt;
&lt;p&gt;java.util.Collection：存储一个一个的数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子接口：List：存储有序、可重复的数据（“动态”数组）
&lt;ul&gt;
&lt;li&gt;Array</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-常用类与基础API</title>
    <link href="http://cv-elevation.github.io/2025/05/03/JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API/"/>
    <id>http://cv-elevation.github.io/2025/05/03/JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API/</id>
    <published>2025-05-03T12:33:05.000Z</published>
    <updated>2025-06-28T13:01:20.006Z</updated>
    
    <content type="html"><![CDATA[<h1>常用类与基础API</h1><h2 id="String类的深入认识">String类的深入认识</h2><p><strong>类的声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,</span><br><span class="line">               Constable, ConstantDesc</span><br></pre></td></tr></table></figure><p>以上是java源码中对于String类的声明，我们可以注意到：</p><p>final：String是不可继承的<br>Serializable：可序列化的接口。凡是实现此接口的类的对象就可以通过网络或本地流进行数据的传输<br>comparable：凡是实现此接口的类，其对象都可以比较大小</p><p><strong>内部声明的属性</strong></p><p>jdk8及之前：private final char value[]；//存储字符串的容器<br>final：指明此value数组一旦初始化，其地址就不可变</p><p>jdk9开始，为节省内存空间做了优化：private final byte value[]//存储字符串的容器</p><p><strong>字符串常量的存储位置</strong></p><ul><li>字符串常量都存储在字符串常量池(StringTable)中</li><li>字符串常量池不允许存储两个相同的常量</li><li>内存上，jdk7之前存放在方法区，jdk7之后存放在堆空间</li></ul><p><strong>String的不可变性</strong></p><ol><li>当对字符串进行重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有的位置修改</li><li>当对现有的字符串进行拼接时，需要重新开辟空间以保存拼接以后的字符串，不能在原有位置修改</li><li>当调用字符串的replace()替换现有的某个字符时，需要重新开辟空间保存修改以后的字符串，不能在原有位置修改</li></ol><p><strong>String实例化的两种方式</strong></p><p>第一种：<code>String s1 = &quot;hello&quot;</code></p><p>第二种：<code>String s2 = new String(&quot;hello&quot;)</code></p><p>连接符：</p><ol><li>常量+常量，存储在字符串常量池，返回字面量的地址。注：此时的常量可能是字面量，也可能是final修饰的常量</li><li>常量+变量或者变量+变量，通过new创建一个新的字符串，返回堆空间中此字符串对象的地址</li><li>调用字符串的intern()返回的是字符串常量池中<strong>字面量的地址</strong></li><li>concat()：不管是常量还是变量，都返回一个新new的对象</li></ol><h3 id="String类构造器">String类构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造（但实际无意义，因为 String 是不可变的）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 通过字符串字面量构造（实际很少直接使用）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span>;</span><br><span class="line"><span class="comment">// 通过字节数组构造（使用平台默认字符集解码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span>[] bytes)</span>;</span><br><span class="line"><span class="comment">// 通过字节数组构造（指定字符集解码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span>[] bytes, String charsetName)</span>;</span><br><span class="line"><span class="comment">// 通过字节数组的指定范围构造（offset 起始位置，length 长度）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span>[] bytes, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="comment">// 通过字符数组构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span>[] value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span>[] value, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="Stirng类与常见的其它结构之间的转换"><strong>Stirng类与常见的其它结构之间的转换</strong></h3><ol><li>Stirng和基本数据类型之间的转换在包装类中已经写过，在此省略，详见 <em>面向对象（高级）-包装类</em></li><li>String和char[]的转换<ul><li>String–&gt;char[]：调用toCharArray()，<code>char[] arr = str.toCharArray()</code></li><li>char[]–&gt;String：调用String的构造器</li></ul></li><li>String和byte[]的转换<ul><li>编码：String–&gt;byte[]：调用getBytes()，()内可以用&quot;字符集名称&quot;指明字符集，不写则使用默认字符集</li><li>关于字符集：utf-8中汉字占3个字节，一个字母使用1个字节；gbk中一个汉字占2个字节，一个字母占1个字节。两者都向下兼容ascii码。</li><li>解码：byte[]–&gt;String：使用构造器，如果需要也要指定字符集</li><li>编码和解码指定字符集要相同，否则会乱码。</li></ul></li></ol><h3 id="String常用的方法"><strong>String常用的方法</strong></h3><p>String类包含有查找、截取、字符/字符数组、开头结尾、替换等常用API，内容很多且很啰嗦，建议在使用中学习，在此省略。</p><p>详细内容参见<a href="https://www.runoob.com/java/java-string.html">Java String 类 | 菜鸟教程</a></p><h2 id="StringBuffer和StringBuilder类">StringBuffer和StringBuilder类</h2><p>对比：</p><p>String:不可变的字符序列；</p><p>StringBuffer:可变的字符序列；线程安全，效率低</p><p>StringBuilder:可变的字符序列；线程不安全，效率高</p><h3 id="理解">理解</h3><p>声明的内部属性：</p><p>char[] value 存储的字符序列</p><p>int count 记录有效字符的个数</p><p>构造器：</p><p><code>StringBuffer str = new StringBuffer()</code>空参构造器则会生成一个容量为16的字符数组</p><p><code>StringBuffer str = new StringBuffer(&quot;abc&quot;)</code>带字符串的构造器则会生成一个字符串长度+16长度的字符数组</p><p>扩容：如果使用append()添加字符串，如果count要超过value.length，就需要扩容，默认扩容为原有容量的2倍+2，并将原有value数组中的元素复制到新的数组中。</p><p>如果开发中大体确定需要操作的字符个数，建议使用带int capacity参数的构造器，避免频繁扩容。</p><h3 id="常用方法">常用方法</h3><p>增：</p><p>append(xx)</p><p>删：</p><p>StringBuffer delete(int start, int end)：删除[start,end)之间字符<br>StringBuffer deleteCharAt(int index)：删除[index]位置字符</p><p>改：</p><p>StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str</p><p>void setCharAt(int index, char c)：替换[index]位置字符</p><p>查：</p><p>char charAt(int index)：查找指定index位置上的字符</p><p>插：</p><p>StringBuffer insert(int index, xx)：在[index]位置插入xx</p><p>长度：</p><p>int length()：返回存储的字符数据的长度</p><h2 id="日期时间的API">日期时间的API</h2><p>jdk8之前的API：</p><p>System.currentTimeMillis()：与1970.1.1日0时0分0秒之间的毫秒数<br>两个Date类：sql和util的两个Data类<br>SimpleDateFormat类：用于日期时间的格式化和解析<br>Calendar抽象类： 1.实例化，通过Calendar的静态方法2. 常用方法</p><h4 id="jdk8及之后的API">jdk8及之后的API</h4><p><strong>LocalDate、LocalTime、LocalDateTime：</strong></p><p>实例化：</p><p>now()获取当前时间的实例</p><p>of()根据指定日期、时间创建对象</p><p>常用方法：getXXX()、withDayOfMonth()、plusXxx()、minusXxx()</p><p><strong>瞬时：Instant</strong></p><p>实例化：</p><p>now()当前时间</p><p>ofEpochMilli()指定时间</p><p>方法：toEpochMilli()</p><p><strong>DateTimeFormatter</strong></p><p>用于格式化和解析LocalDate、LocalTime、LocalDateTime</p><p>ofPattern(“指定格式”)</p><h2 id="Java比较器">Java比较器</h2><h3 id="自然排序">自然排序</h3><p>方式：实现Comparable接口的方式</p><ol><li>具体的类实现Comparable类的接口</li><li>实现Comparable接口中的comparaTo方法，在此方法中指明类A对象的大小的标准</li><li>创建类A的实例，进行大小的比较或排序</li></ol><h3 id="定制排序">定制排序</h3><p>方式：实现Comparater接口的方式</p><ol><li>创建一个实现了Comparator接口的实现类；</li><li>实现类要求实现Compator接口的抽象方法compara(Object o1,Object o2)，在此方法中指明要比较对象的大小关系；</li><li>创建此实现类的对象，并将此对象传递到相应方法的参数位置即可。</li></ol><p>对比：</p><p>自然排序：单一的；一劳永逸的；Comparable接口、comparaTo</p><p>定制排序：灵活的；临时的；Comparater接口、compara</p><h2 id="其他常用类">其他常用类</h2><p>System类</p><p>属性：out、in、err</p><p>方法：currentTimesMills等</p><p>Runtime类</p><p>对应着Java进程的内存使用的运行时环境，是单例的</p><p>Math类</p><p>数学运算</p><p>BigInteger、BigDecimal类</p><p>BigInteger：可以表示任意长度的整数</p><p>BigDecimal：可以表示任意精度的浮点数</p><p>Random类</p><p>产生随机数，例：nextInt(int bound)获取[0,bound)的随机整数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;常用类与基础API&lt;/h1&gt;
&lt;h2 id=&quot;String类的深入认识&quot;&gt;String类的深入认识&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;类的声明&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-多线程</title>
    <link href="http://cv-elevation.github.io/2025/05/03/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://cv-elevation.github.io/2025/05/03/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2025-05-03T05:56:53.000Z</published>
    <updated>2025-06-28T13:18:15.131Z</updated>
    
    <content type="html"><![CDATA[<h1>多线程</h1><h2 id="概念">概念</h2><p>程序：为完成任务，用某种语言编写的一组指令的集合。</p><p>进程：程序的一次执行过程，或是正在内存中运行的应用程序。</p><p>线程：进程可以进一步细化为线程，是程序内部的一条执行路径。线程是CPU调度和执行的最小单位。</p><ul><li><p>不同进程之间是不共享内存的。</p></li><li><p>进程之间的数据交换和通信的成本很高。</p></li></ul><p><strong>线程调度策略</strong><br>分时调度：所有线程轮流使用CPU的使用权。并且平均分配每个线程占用CPU的时间<br>抢占式调度：让优先级高的线程以较大的概率优先使用CPU。如果线程的优先级相同，那么就会随机选一个。Java使用的是抢占式调度。</p><p><strong>并行和并发：</strong></p><ul><li><p>并发是指一个处理器同时处理多个任务。<br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务</p></li><li><p>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</p></li><li><p>也就是说，只有多核CPU才能并行，单核CPU本身就不能同时处理多个进程，只能把一段时间拆成多块来分别执行不同的进程</p></li></ul><p><strong>多线程的优点</strong></p><ul><li><p>提供应用程序的响应。</p></li><li><p>提高计算机CPU的利用率。</p></li><li><p>改善程序结构。将既长又复杂的进程拆为多个线程，独立运行，便于理解和修改。</p></li></ul><h2 id="多线程创建方式">多线程创建方式</h2><p>方式一：继承Thread类的方式</p><ol><li><p>创建一个继承于Thread类的子类</p></li><li><p>重写Thread类的run()</p></li><li><p>创建当前Thread的子类对象</p></li><li><p>通过对象调用start()</p></li></ol><p>创建线程代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方式1：创建子类</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        myThread2.start();</span><br><span class="line">        <span class="comment">//方式2：创建匿名子类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：实现Runnable接口</p><ol><li>创建一个Runnable接口的实现类</li><li>实现接口中的run()</li><li>创建当前实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的实例</li><li>实例调用start()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Way2test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadTest);<span class="comment">//多态</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadTest);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//使用实现Runnable接口的方式创建线程，匿名实现类的匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下两种方式：</p><p>共同点：①启动线程都是Thread类的start()方法②创建的线程对象都是Thread类或其子类的实例</p><p>不同点：前者是类的继承，后者是接口的实现</p><p>建议使用runnable接口的方式。</p><p>好处：①实现的方式，避免了单继承的局限性②更适合处理有共享数据的问题③实现了代码和数据的分离</p><p>联系：代理模式</p><p>方式三：实现Callable方式</p><p>方式四：使用线程池</p><p>方式三、四在此省略</p><h2 id="Thread类">Thread类</h2><h3 id="常用方法">常用方法</h3><p><strong>线程中的构造器(记得子类不会继承父类的构造器)</strong></p><p>Thread()<br>Thread(String name)<br>Thread(Runnable target)<br>Thread(Runnable target，String name)</p><p><strong>线程中的常用方法</strong></p><p>start()：①启动线程②调用线程的run()<br>run()：声明线程要执行的代码<br>currentThread()：获取当前的线程<br>getName()：获取线程名<br>setName()：设置线程名<br>sleep(long mills)：静态方法，调用可以是当前线程睡眠指定的毫秒数<br>yield()：静态方法一旦执行此方法，就释放CPU的执行权<br>join()：在线程a中通过线程b调用join方法，意味着线程a进入阻塞状态，直到线程b结束，线程a才会继续执行<br>isAlive()：判断当前线程是否还存活</p><p><strong>线程优先级</strong></p><p>getPriority()：获取线程的优先级<br>setPriority()：设置线程的优先级（1~10）</p><h3 id="线程的生命周期">线程的生命周期</h3><p>jdk5之前</p><p><img src="/2025/05/03/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20250430202641386.png" alt="image-20250430202641386"></p><p>jdk5之后对阻塞进行了细分，在此不做赘述，在JUC中会详细学习</p><h2 id="线程安全问题">线程安全问题</h2><p>什么叫线程安全问题？</p><p>如何解决？</p><h3 id="方式一：同步代码块解决安全问题">方式一：同步代码块解决安全问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"></span><br><span class="line">需要被同步的代码;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>需要被同步的代码，即操作共享数据的代码。</li><li>共享数据：即多个线程都需要操作的数据。</li><li>需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其他线程必须等待。</li><li>同步监视器，俗称锁，哪个线程获取了锁，哪个线程就能执行需要被同步的代码。</li><li>同步监视器，可以用任何一个类的对象充当。但是，多个线程必须公用一个同步监视器。</li></ul><p>在实现Runnable接口的方式中，同步监视器可以考虑使用this<br>在继承Thread类的方式中，同步监视器慎用this</p><h3 id="方式二：同步方法解决安全问题">方式二：同步方法解决安全问题</h3><p>如果操作共享数据的代码完整声明在了一个方法中，那么我们就可以将此方法声明为同步方法。</p><p>非静态的同步方法，默认监视器是this；静态的同步方法，默认监视器是当前类本身（.class）。</p><p>synchronized的好处：解决了线程安全问题。</p><p>弊端：在操共享数据时，多线程其实是串行执行的，意味着性能低。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account acc=<span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(acc,<span class="string">&quot;甲&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(acc,<span class="string">&quot;乙&quot;</span>);</span><br><span class="line">        customer1.start();</span><br><span class="line">        customer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            balance+=amount;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存款成功，余额为：&quot;</span>+balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Account account,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.deposit(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式单例模式">懒汉式单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">publicpublic <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2：线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(LazyOne.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3：相比2效率提高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加这个代码，暴露问题</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要   </span></span><br><span class="line"><span class="comment">volatile关键字，避免指令重排。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>形式二：使用内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LazySingle</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazySingle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类只有在外部类被调用才加载，产生INSTANCE实例；又不用加锁。</p><p>此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。</p><p>此时的内部类，使用enum进行定义，也是可以的。</p></blockquote><h3 id="死锁">死锁</h3><p>不同线程分别占用着对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p><p><strong>诱发死锁的原因：</strong></p><ul><li>互斥条件</li><li>占用且等待</li><li>不可抢夺（或不可抢占）</li><li>循环等待</li></ul><p>以上4个条件，同时出现就会触发死锁。</p><p><strong>解决死锁：</strong></p><p>死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件。</p><p>针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</p><p>针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p><p>针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p><p>针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p><h3 id="方式三：Lock锁的方式解决线程安全问题">方式三：Lock锁的方式解决线程安全问题</h3><p>Lock的使用</p><ol><li>创建Lock实例，需要确保多个线程共用一个Lock实例。需要考虑将此对象声明为static final</li><li>执行lock()方法吗，锁定对共享资源的调用</li><li>执行unlock()，释放对共享资源的锁定</li></ol><p>对比synchronized和Lock：<br>synchronized不管是同步代码块还是同步方法，都需要在一对{}之后，释放对同步资源的调用</p><p>Lock是通过两个方法控制需要被同步的代码，更灵活。Lock作为接口，提供了多种实现类，适合更多复杂的场景，效率更高。</p><h2 id="线程通信">线程通信</h2><p>涉及到三个方法的使用：</p><p>wait()：线程一旦执行此方法，就进入等待状态。同时会释放对同步监视器的调用。</p><p>notify()：一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。如果多个被wait的线程优先级相同，那么就随机唤醒一个。被唤醒的线程从当初被wait的位置继续执行。</p><p>notifyAll()：唤醒所有被wait的线程。</p><p>注意：</p><ul><li>这三个方法必须在同步代码块或同步方法中使用；</li><li>这三个方法的调用者必须是同步监视器。否则会报IlleagalMonitorStateException异常</li><li>这三个方法声明在Object类中</li></ul><p>wait()和sleep()区别？</p><p>相同点：调用后都会使线程进入阻塞状态</p><p>不同点：</p><ul><li><p>声明的位置:</p><ul><li>wait():声明在Object类中</li><li>sleep()：声明在Thread类中，静态的</li></ul></li><li><p>使用的场景不同：</p><ul><li>wait()：只能使用在同步代码块或同步方法中</li><li>sleep():可以在任何需要使用的场景</li></ul></li><li><p>使用在同步代码块或同步方法中：</p><ul><li>wait()：一旦执行，会释放同步监视器</li><li>sleep()：一旦执行，不会释放同步监视器</li></ul></li><li><p>结束阻塞的方式：</p><ul><li>wait()：到达指定时间自动结束阻塞 或 通过被notify唤醒，结束阻塞</li><li>sleep():到达指定时间自动结束阻塞</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;多线程&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;程序：为完成任务，用某种语言编写的一组指令的集合。&lt;/p&gt;
&lt;p&gt;进程：程序的一次执行过程，或是正在内存中运行的应用程序。&lt;/p&gt;
&lt;p&gt;线程：进程可以进一步细化为线程，是程序内部的一条执行路径。线程是CPU</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-异常</title>
    <link href="http://cv-elevation.github.io/2025/04/28/%E5%BC%82%E5%B8%B8/"/>
    <id>http://cv-elevation.github.io/2025/04/28/%E5%BC%82%E5%B8%B8/</id>
    <published>2025-04-28T13:24:03.000Z</published>
    <updated>2025-06-28T13:40:45.626Z</updated>
    
    <content type="html"><![CDATA[<h1>异常</h1><h2 id="0-概述">0.概述</h2><p>异常是指程序在执行过程中出现的非正常情况，如果不处理最终会导致JVM的非正常停止</p><p>异常的抛出机制：Java把不同异常用不同的类表示，一旦发生某种异常，就创建该异常类型的对象，并且抛出(throw)。然后程序员可以捕获(catch)到这个异常现象，并处理；如果没有捕获这个异常对象，那么这个异常对象会导致程序的终止。</p><h2 id="1-常见异常">1.常见异常</h2><p>Error:StackOverflowError、OOM</p><p>Exception：</p><p>编译时异常（受检异常）在执行javac.exe时出现的异常：</p><ul><li>ClassNotFoundException</li><li>FileNotFoundException</li><li>IOException</li></ul><p>运行时异常（非受检异常）在执行java.exe时出现的异常：</p><ul><li>ArrayIndexOutOfBoundsException</li><li>NullPointerException</li><li>ClassCastException</li><li>NumberFormatException</li><li>InputMismatchException</li><li>ArithmeticException</li></ul><h2 id="2-异常处理">2.异常处理</h2><h3 id="方式一：try-catch-finally">方式一：try-catch-finally</h3><p>基本结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ......<span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e)&#123;</span><br><span class="line">    ......<span class="comment">//当产生异常类型1时的处置措施</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e)&#123;</span><br><span class="line">    ......<span class="comment">//当产生异常类型2时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    ......<span class="comment">//无论是否异常都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节：</p><ul><li>如果写了多个catch，如果多个异常类型不存在子父类关系，则不同类型的catch谁写在上边，谁写在下边都可以；如果存在子父类关系，则子类异常要写在父类异常上面，否则会报错</li><li>catch中异常处理的方式：<ul><li>自己编写输出的语句</li><li>printStackTrace()：打印异常的详细信息</li><li>getMessage()：获取发生异常的原因</li></ul></li><li>try中声明的变量，出了try结构后就不可以再调用了</li><li>将<strong>一定</strong>要被执行的代码写在finally<ul><li>无论try中或catch中是否存在仍未被处理的异常、无论try中或catch中是否存在return，都会执行。唯一的例外：System.exit(0)会强行终止当前运行的VM</li><li>在开发中，有一些资源（输入流、输出流、数据库连接、Sokect），在使用完后，必须显式地进行关闭，否则会导致内存泄漏。</li></ul></li></ul><h3 id="方式二：throws-异常类型">方式二：throws+异常类型</h3><p>格式：<code>public void test() throws 异常类型1,异常类型2,.....&#123;//可能存在编译时异常的代码&#125;</code></p><p>throws处理异常的方式，仅是将可能出现的异常抛给了此方法的调用者。调用者仍要考虑如何处理异常。</p><p>方法重写的要求：（针对编译时异常）</p><p>**（重要）**子类抛出的异常类型要么和父类异常类型一样，要么是父类异常类型的子类。</p><h3 id="throws和try-catch-finally的选择：">throws和try-catch-finally的选择：</h3><ul><li>如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。</li><li>如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally进行处理，不能throws。</li><li>开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。</li></ul><h2 id="3-抛出异常对象">3.抛出异常对象</h2><p>异常的处理过程中有两个过程，一个是“抛”，一个是“抓“<br>“抛”的过程在程序上就是产生异常对象的过程，具体又可以分为自动抛和手动抛，这里的throw就是手动抛的过程<br>“抓”的过程实际上就是处理异常的过程，上述的throws和try-catch-finally就是处理异常的过程。</p><p>throw的使用：写在方法里，格式是<code>throw 异常对象</code>，这样就可以产生一个异常对象。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;手动抛出异常&quot;</span>);<span class="comment">//创建一个名为手动抛出异常的异常对象</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;捕获异常&quot;</span>);</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是想说明，自动抛和手动抛没有本质上的区别，都能被try-catch捕获。</p><h2 id="4-自定义异常">4.自定义异常</h2><p>如何自定义异常？</p><ul><li>继承于现有的异常体系，通常继承于RuntimeException/Exception</li><li>通常提供几个重载的构造器</li><li>提供一个全局常量，声明为：static final long serialVersionUID</li></ul><p>使用：通过<code>throw 自定义异常类的对象</code>，将异常对象抛出</p><p>如果自定义异常类是非运行时异常，则必须考虑如何处理此异常类的对象</p><p>为什么要自定义异常类呢？</p><p>我们其实更关心的是，通过异常的名称就能直接判断此异常出现的原因。既然如此，就有必要在实际开发场景中，不满足我们指定的条件时，指明我们自己特有的异常类。通过此异常类的名称就能判断出具体出现的问题。</p>]]></content>
    
    
    <summary type="html">学习JavaSE中异常时的笔记</summary>
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象（高级）</title>
    <link href="http://cv-elevation.github.io/2025/04/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
    <id>http://cv-elevation.github.io/2025/04/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/</id>
    <published>2025-04-25T11:51:07.000Z</published>
    <updated>2025-06-28T13:43:05.317Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象高级</h1><h2 id="static关键字">static关键字</h2><p>static用来修饰的结构：属性、方法；代码块、内部类</p><p>我们可以按照变量在类中声明的位置，分为局部变量和成员变量。对于成员变量又可以进一步分类：<br>对于加了static关键字的变量，我们称为<strong>静态变量</strong>、类变量；<br>对于没有加static关键字的变量，我们称为<strong>实例变量</strong>、非静态变量。</p><p>静态变量和实例变量对比</p><table><thead><tr><th style="text-align:center"></th><th>静态变量</th><th>实例变量</th></tr></thead><tbody><tr><td style="text-align:center">个数</td><td>只有一份，被类的多个对象共享</td><td>每一个对象都保存有一份</td></tr><tr><td style="text-align:center">内存位置</td><td>jdk6及之前，在方法区，jdk7及之后再堆</td><td>存放在堆空间的对象实体中</td></tr><tr><td style="text-align:center">生命周期</td><td>随类的加载而加载，随类的卸载而消亡</td><td>随对象的创建而加载，随对象的消亡儿消亡</td></tr><tr><td style="text-align:center">调用者</td><td>可被类直接调用，也可被对象调用</td><td>只能被对象调用</td></tr></tbody></table><h3 id="static修饰方法">static修饰方法</h3><ul><li><p>随着类的加载而加载</p></li><li><p>可以通过“类.静态方法”的方式，直接调用静态方法</p></li><li><p>静态方法内可以调用静态的属性或静态的方法，不可以调用非静态的结构（比如属性和方法）</p></li><li><p>静态方法可被类直接调用，也可被对象调用；实例方法只能被对象调用</p></li><li><p>静态方法内不能用this和super（理解：因为静态方法随类的加载而加载，而this和super都是需要产生对象才可以使用的，但是VM是先加载类再加载对象，所以静态方法使用this和super显然是不合适的）</p></li></ul><h3 id="什么时候要使用static？">什么时候要使用static？</h3><ul><li>属性：1)当前类的对象是否能共享此属性，且此变量值相同。2)常量</li><li>方法：方法内操作的变量都是静态变量。工具类的方法，如：Arrays、Maths</li></ul><h2 id="单例-Singleton-设计模式">单例(Singleton)设计模式</h2><h3 id="饿汉式">饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;<span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建实例</span></span><br><span class="line">    <span class="comment">//4.声明为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="comment">//3.获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“立即加载”，随着类的加载就创建了<br>优点：写法简单，运行较快，是线程安全的<br>缺点：内存占用时间长</p><h3 id="懒汉式">懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;<span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.声明实例</span></span><br><span class="line">    <span class="comment">//4.声明为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instace</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//3.获取实例，如果没有创建对象，则在方法内再创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“延迟加载”，在需要的时候才创建对象<br>优点：节省内存<br>缺点：线程不安全</p><h2 id="类的成员之四：代码块">类的成员之四：代码块</h2><p>代码块，也叫初始化块。是用来初始化类或对象的信息。按照是否加static修饰分为静态代码块和非静态代码块。静态代码块随着类的加载而执行，由于类的加载只会执行一次，所以静态代码块<strong>只会执行一次</strong>；非静态代码块随着对象的创建而执行，没创建一个实例，<strong>都会执行一次</strong>。静态代码块要先于非静态代码块执行。</p><p>作用：可以把不同构造器中相同的部分写在代码块中进行赋值；对静态变量进行赋值。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User2</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User2</span>();</span><br><span class="line">        System.out.println(user1.getInfo());</span><br><span class="line">        System.out.println(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line">        <span class="type">User2</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User2</span>(<span class="string">&quot;KuoZ&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        System.out.println(user2.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;<span class="comment">//注册时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.userName=<span class="string">&quot;&quot;</span>+System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User2</span><span class="params">(String userName, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//使用非静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.registrationTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + userName +</span><br><span class="line">                <span class="string">&quot;, 密码：&quot;</span> + password +</span><br><span class="line">                <span class="string">&quot;, 注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：属性赋值的位置及过程">总结：属性赋值的位置及过程</h3><h2 id="final关键字">final关键字</h2><p>final可以修饰类、方法、变量</p><p>final修饰类时，则此类无法被<strong>继承</strong><br>final修饰方法时，则此方法无法被<strong>重写</strong><br>final修饰变量时，则表示常量，无法被更改</p><p><s>你就是我的final了！</s></p><h2 id="abstract关键字">abstract关键字</h2><p>abstract关键字可以修饰类和方法</p><p>abstract修饰类：</p><ul><li>此类称为抽象类</li><li>不能实例化</li><li>抽象类要包含构造器，因为子类对象实例化时会间接调用父类的构造器</li><li>抽象类中不一定要有抽象方法，而抽象方法所在的类必须是抽象类</li></ul><p>abstract修饰方法：</p><ul><li>此方法即为抽象方法</li><li>抽象方法只有方法的声明，没有方法体</li><li>抽象方法的功能是确定的，只是不知道其如何实现的</li><li>子类必须重写父类所有抽象方法之后才可实例化，否则必须声明为抽象类</li></ul><p>abstract不能修饰的结构：属性、构造器、代码块</p><p>与abstact矛盾的关键字：<br>私有方法：因为私有方法不能被重写<br>静态方法：阻碍静态方法使用类调用<br>final方法：不能重写<br>final类：不能继承</p><h2 id="接口-interface">接口(interface)</h2><h3 id="接口的使用：">接口的使用：</h3><p>接口的本质是一个契约、规范、标准，制定好后大家都要遵守。</p><p>接口内部结构：</p><p>可以声明：<br>属性：必须使用public static final修饰<br>方法：jdk8之前：声明抽象方法，修饰为public abstract<br>jdk8：声明了静态方法、默认方法<br>jdk9：声明私有方法</p><p>不可以声明构造器、代码块等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//全局常量 默认即为 public static final，可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SPEED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">7900</span>;</span><br><span class="line">    <span class="comment">//方法 默认即为 public abstract，可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口和类的关系：实现关系</p><p>格式<code>class A extends SuperA implements B,C&#123;&#125;</code><br>A是SuperA的子类，是B、C的实现类</p><p>类可以实现多个接口，这种多实现性一定程度上弥补了单继承的局限性。类必须将实现的接口中的所有抽象方法都重写才能实例化，否则必须声明为抽象类。</p><p>接口和接口之间是可以有<strong>继承关系</strong>的，而且是<strong>多继承</strong></p><p>接口的多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建接口实现类的对象(camera)</span></span><br><span class="line">        <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.DataTransfer(camera);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建接口实现类的匿名对象</span></span><br><span class="line">        computer.DataTransfer(<span class="keyword">new</span> <span class="title class_">printer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建接口匿名实现类的对象</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;usb1 start&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;usb1 stop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        computer.DataTransfer(usb1);</span><br><span class="line">        <span class="comment">//4.创建接口匿名实现类的匿名对象</span></span><br><span class="line">        computer.DataTransfer(<span class="keyword">new</span> <span class="title class_">USB</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;usb2 start&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;usb2 stop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;<span class="comment">//接口定义</span></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;<span class="comment">//实现类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;computer start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;computer stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DataTransfer</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Data Transfer&quot;</span>);</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;<span class="comment">//实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;camera start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;camera stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;<span class="comment">//实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printer start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printer stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区分抽象类和接口：相同：都可以声明抽象方法；都不能实例化。不同：抽象类一定要有构造器，接口没有；关系不同。（指继承、实现、多继承）</p><h3 id="jdk8和jdk9中接口的新特性">jdk8和jdk9中接口的新特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparaATest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ComparaA.method1();</span><br><span class="line">        <span class="comment">//SubClass.method1();1.静态方法不能被实现类调用</span></span><br><span class="line">        <span class="type">SubClass</span> <span class="variable">subClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">        subClass.method2();<span class="comment">//2.默认方法可以调用，并且可以重写</span></span><br><span class="line">        <span class="comment">//3.接口冲突：类实现了两个接口，两个接口都有同名的默认方法，会报错</span></span><br><span class="line">        <span class="comment">//解决方法：在实现类中重写该方法</span></span><br><span class="line">        subClass.method3();</span><br><span class="line">        <span class="comment">//4.类优先原则</span></span><br><span class="line">        subClass.method4();<span class="comment">//优先调用了父类的method4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//5.调用接口、父类的方法</span></span><br><span class="line">        subClass.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComparaA</span> &#123;</span><br><span class="line">    <span class="comment">//属性不变</span></span><br><span class="line">    <span class="comment">//方法可声明静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ComparaA method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法可声明默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ComparaA method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ComparaA method3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ComparaA method4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComparaB</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ComparaB method3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">ComparaA</span>, ComparaB &#123;</span><br><span class="line">    <span class="comment">//重写接口中的默认方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass method3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        method3();</span><br><span class="line">        <span class="built_in">super</span>.method4();</span><br><span class="line">        ComparaA.<span class="built_in">super</span>.method3();</span><br><span class="line">        ComparaB.<span class="built_in">super</span>.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass method4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员之五：内部类">类的成员之五：内部类</h2><p>内部类的分类：</p><p>成员内部类：声明在外部类的里面<br>又分为是否使用static修饰，静态的成员内部类，反之为非静态。</p><p>局部内部类：声明在构造器、方法、代码块内<br>又分为是否匿名</p><p>成员内部类的理解</p><ul><li>从类的角度看<ul><li>可以声明属性、方法、构造器、代码块、内部类等</li><li>可以声明父类、实现接口</li><li>可以使用final修饰</li><li>可使用abstract修饰</li></ul></li><li>从外部类的成员的角度看<ul><li>在内部可调用外部类的的结构</li><li>可以声明为private（与外部类不同，外部类只能用public、缺省）</li><li>可以使用static修饰</li></ul></li></ul><p>如何创建成员内部类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.静态成员内部类实例化</span></span><br><span class="line">        Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        <span class="comment">//2.非静态成员内部类实例化</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> person.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Dog eat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">        String name=<span class="string">&quot;鸮&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bird eat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在成员内部类中调用外部类的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    System.out.println(name);<span class="comment">//形参</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">    System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerTest2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//开发中的场景</span></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getInstace</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.返回实现类的有名对象</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MyComparable</span> <span class="variable">myComparable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">        <span class="keyword">return</span> myComparable;</span><br><span class="line">        <span class="comment">//2.返回实现类的匿名对象</span></span><br><span class="line"><span class="comment">//        class MyComparable implements Comparable &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回匿名实现类的有名对象</span></span><br><span class="line"><span class="comment">//        Comparable c = new Comparable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        return c;</span></span><br><span class="line">        <span class="comment">//4.返回匿名实现类的匿名对象</span></span><br><span class="line"><span class="comment">//        return new Comparable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>()&#123;<span class="comment">//接口匿名实现类的匿名对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.Method();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>()&#123;<span class="comment">//抽象类匿名子类的匿名对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.Method();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>()&#123;<span class="comment">//匿名子类的匿名对象</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.Method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;<span class="comment">//普通的一个父类</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，针对抽象类（父类）、接口，都可通过上述方式创建**匿名子类（实现类）**的匿名对象来实现方法。</p><h2 id="枚举类">枚举类</h2><p>枚举类本质上也是类，不过这个类的对象是<strong>有限、确定的</strong>，用户不能随意创建。</p><p>枚举类声明格式<br><code>enum 枚举名&#123;&#125;</code>，在枚举类中，必须先声明多个对象，对象之间用“，”连接。枚举类的属性必须为<code>private final</code></p><p>参考代码及常用方法测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.toString()方法</span></span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">        <span class="comment">//2.name()方法</span></span><br><span class="line">        System.out.println(Season.SPRING.name());</span><br><span class="line">        <span class="comment">//3.values()方法</span></span><br><span class="line">        Season[] seasons = Season.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seasons.length; i++) &#123;</span><br><span class="line">            System.out.println(seasons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.valueOf(String objName)方法 返回名称为objName的对象,如果不存在则报错</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objName</span> <span class="operator">=</span> <span class="string">&quot;SUMMER&quot;</span>;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.valueOf(objName);</span><br><span class="line">        System.out.println(season);</span><br><span class="line">        <span class="type">String</span> <span class="variable">wrongObjName</span> <span class="operator">=</span> <span class="string">&quot;SUMMER1&quot;</span>;</span><br><span class="line">        <span class="comment">//Season season1 = Season.valueOf(wrongObjName);</span></span><br><span class="line">        <span class="comment">//报错：java.lang.IllegalArgumentException</span></span><br><span class="line">        <span class="comment">//5.ordinal()方法</span></span><br><span class="line">        System.out.println(Season.SPRING.ordinal()); <span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//对象</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName=seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc=seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举实现接口的操作：</p><ol><li>枚举类实现接口，在枚举类中重写接口的抽象方法。当通过不同的枚举类对象调用此方法时，执行同一个方法</li><li>枚举类每一个对象重写接口的抽象方法。当通过不同的枚举类对象调用此方法时，执行不同方法</li></ol><p>针对2，要让枚举类的每一个对象重写接口的抽象方法，具体操作参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天来了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="注解">注解</h2><p>注解（annotation），与注释类似但并不相同，注解是可以被编译器读取的。</p><p>常见的Java内置注解：</p><p><code>@override</code>用于检查重写方法是否写对。</p><p><code>@Deprecated</code>表示某个类或方法已经<strong>不推荐使用</strong>，调用时会有警告提示。调用被它标记的类或方法时会出现删除线。</p><p><code>@SuppressWarnings</code>告诉编译器<strong>忽略特定类型的警告</strong>。</p><p>框架 = 注解 + 反射 + 设计模式</p><p>元注解：注解的注解</p><h2 id="包装类">包装类</h2><h3 id="概述">概述</h3><p>使用包装类的原因：为了使基本数据类型具备引用数据类型变量的特征，给8中基本数据类型都提供了相应的包装类。</p><p>基本数据类型的包装类<br>对于8种数据类型，int、char的包装类为Integer、Character，byte、short、long、float、double、boolean为将首字母大写。</p><p>基本数据类型与引用数据类型的转换：<br>（装箱）基本数据类型–&gt;包装类：1.使用包装类的构造器 2.（建议）使用包装类的valueOf()<br>（拆箱）包装类–&gt;基本数据类型：调用包装类的xxxValue()</p><p>jdk5.0新特性：自动装箱和自动拆箱，直接赋值就能自动装/拆</p><h3 id="String和基本数据类型、包装类的转换">String和基本数据类型、包装类的转换</h3><p>基本数据类型、包装类–&gt;String类型：1.调用String类重载的方法valueOf()；2.使用基本数据类型/包装类+“”</p><p>String类型–&gt;基本数据类型、包装类：调用包装类的静态方法：parseXxx()</p><h1>IDEA快捷键</h1><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>使用xx块环绕-surround with</td><td>ctrl+alt+t</td></tr><tr><td>复制指定行代码</td><td>ctrl+d</td></tr><tr><td>删除指定行代码</td><td>ctrl+y</td></tr><tr><td>切换到上一行代码空位</td><td>ctrl+alt+enter</td></tr><tr><td>上下移动代码</td><td>ctrl+shift+↑/↓</td></tr><tr><td>上下移动代码</td><td>alt+shift+↑/↓</td></tr><tr><td>形参列表提醒</td><td>ctrl+p</td></tr><tr><td>批量修改</td><td>shift+f6</td></tr><tr><td>重写父类的方法</td><td>ctrl+o</td></tr><tr><td>实现接口的方法</td><td>ctrl+i</td></tr><tr><td>查看源码</td><td>ctrl+click或者ctrl+n</td></tr><tr><td>打开的类文件之间切换</td><td>ctrl+alt+←/→</td></tr><tr><td>切换标签</td><td>alt+←/→</td></tr><tr><td>查看继承树关系</td><td>ctrl+h</td></tr><tr><td>类的UML关系图</td><td>ctrl+alt+u</td></tr><tr><td>全项目搜索文本</td><td>ctrl+shift+f</td></tr><tr><td>格式化代码</td><td>ctrl+alt+l</td></tr></tbody></table><p>哎，咱快累死了，不过终于是把这面向对象学完了。</p><p>说起来明天咱居然就要20岁了，感觉好突然呐Σ( ° △ °|||)︴</p><p>附一张赫萝表情包</p><img src="/2025/04/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/Holo.jpg" width="40%">]]></content>
    
    
    <summary type="html">在这一篇进一步学习了面向对象的知识。包括static、final、abstract，代码块、内部类，接口、枚举、注解、包装类。最后总结了IDEA中常用的快捷键。</summary>
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象（进阶）</title>
    <link href="http://cv-elevation.github.io/2025/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/"/>
    <id>http://cv-elevation.github.io/2025/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/</id>
    <published>2025-04-21T15:03:09.000Z</published>
    <updated>2025-06-28T13:48:00.144Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象(进阶)</h1><h2 id="this关键字">this关键字</h2><p>this可以调用：属性、方法；构造器</p><h3 id="this调用属性和方法">this调用属性和方法</h3><p><em>this</em> 理解为当前对象，也就是说代表调用属性或方法的对象.</p><p><em>this</em> 通常可以省略，但是在<strong>属性的名称和形参变量的名称一样的情况下</strong>，就必须用<em>this.</em> 标示出成员变量。方法里通常省略<em>this</em> 。</p><h3 id="this调用构造器">this调用构造器</h3><p>使用<em>this(形参列表)</em> 调用当前类中<strong>其它</strong>的重载的构造器，<em>this(形参列表)</em> 必须声明在当前构造器的首行，所以在一个构造器最多出现一次。</p><p>理解：在类中有n个构造器，则最多有n-1个<em>this(形参列表)</em> 结构</p><h2 id="面向对象特征之二：继承性">面向对象特征之二：继承性</h2><h3 id="继承的基本概念">继承的基本概念</h3><p><strong>继承性的好处：</strong></p><ul><li><p>减少代码冗余，提高复用性</p></li><li><p>便于功能扩展</p></li><li><p>产生了is-a的关系，为多态的使用提供了前提</p></li></ul><p><strong>继承性的特点</strong></p><ul><li><p>单继承性：但是一个子类只能有<strong>一个父类</strong>。</p></li><li><p>Java支持多层继承，一个父类可以扩展为多个子类。</p></li><li><p>Java中声明的类，如果没有显式声明其父类，<strong>默认继承</strong>于java.lang.Object类。</p></li><li><p>Java中子类父类的概念是相对的。</p></li></ul><p><strong>继承的格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边代码中：<br>A类：父类、superClass、超类、基类<br>B类：子类、subClass、派生类</p><p><strong>继承的作用</strong></p><p>通过这样声明，子类能够获得了父类声明的<strong>所有属性和方法</strong>。</p><p>子类继承父类后，还可以扩展自己的功能，要区别于集合和子集的概念。</p><p>同时，继承不打破<strong>封装性</strong>，所以因为封装性，子类不能直接调用父类私有的属性。但可以通过get方法调用。</p><h3 id="方法的重写（overwrite-override）">方法的重写（overwrite/override）</h3><p>子类对从父类继承过来的方法进行的覆盖、覆写的操作，称为重写（overwrite）</p><p>方法重写的规则：</p><ol><li>父类被重写的方法的方法名和形参列表必须相同</li><li>子类重写的权限修饰符不小于父类的修饰符。特例：子类不能重写父类中private的方法</li><li>返回值类型：<ul><li>父类为void，则子类重写只能是void</li><li>父类返回为基本数据类型，则子类同类型</li><li>父类返回为引用数据类型，则子类重写的方法的返回值类型相同 或 是引用数据类型的子类</li></ul></li><li>关于异常类型，子类重写的方法抛出的异常类型可以和父类被重写的方法抛出的异常类型相同，也可以是其子类</li></ol><h2 id="super关键字">super关键字</h2><p>使用场景：在子类中已经对父类中的方法进行了<strong>重写</strong>，但是又想要调用父类的方法，这是就要用super关键字<br>子类与父类定义了同名的属性，使用super可以区分子类和父类的属性。</p><p>super可以调用属性、方法；构造器</p><p>super调用属性、方法<br>子类继承父类以后，可以在子类的方法或构造器中调用父类的属性和方法。在满足封装性的前提下，使用<em>super.</em> 表示父类的属性或方法。<br>一般情况下，我们可以考虑省略<em>super.</em> ，但是如果子类中声明了同名的属性或者重写了父类的方法，就必须用<em>super.</em> 表示父类的属性和方法。对于子类父类的属性要尽量避开重名的情况（编程规范），而方法可能无法避免，就可以用<em>super.</em> 来调用</p><p>super调用构造器</p><ol><li>子类继承父类时是不会继承构造器的，可以在子类构造器中用<em>super(形参列表)</em> 调用父类的构造器。</li><li>规定<em>super(形参列表)</em> 必须写在子类构造器的首行，这也就意味着this和super只能出现一个。</li><li>如果没有写<em>super(形参列表)</em> 或<em>this(形参列表)</em> ，则默认是<em>super()</em> 。</li><li>由2、3得出结论，子类的任何一个构造器要么调用本类中重载的构造器，要么调用父类中的构造器。</li><li>由4得到，一个类中声明有n个构造器，最多有n-1个构造器使用了<em>this(形参列表)</em> ，剩下那一个一定使用<em>super(形参列表)</em> 。–&gt;在调用子类的构造器时，一定直接或间接调用了父类的构造器，也正因为调用了父类的构造器，我们才会将父类中声明的方法或属性加载到内存中，供子类对象使用。</li></ol><h2 id="子类对象实例化的全过程：">子类对象实例化的全过程：</h2><p>从结果来看，体现为类的继承性。</p><p>从过程上来讲，当我们通过子类的构造器创建对象时，一定会直接或间接得调用到其父类的构造器，父类也会直接或间接调用其父类的构造器……直到调用了Object类的构造器为止。</p><h2 id="面向对象特征之三：多态性">面向对象特征之三：多态性</h2><h3 id="基本概念">基本概念</h3><p>多态性使用的前提：1.要用子类的继承关系 2.要有方法的重写</p><p>如何理解多态性？</p><p>广义上：子类对象的多态性、方法的重写<br>狭义上：主要指子类对象的多态性</p><ul><li><p>Java中多态性主要体现在子类对象的多态性：子类的对象赋给父类的引用。<br>例<code>Object obj = new String(&quot;hello&quot;);</code>其中String()是子类的构造器，而Person是String的父类。</p></li><li><p>多态的优劣：</p><ul><li>优点：1. 极大地减少了代码的冗余，不需要定义多个重载的方法，比如equals(Object obj)；开闭原则。<br>2 .没有多态性，抽象类和接口的存在就没有意义。</li><li>弊端：在多态的场景下，创建了子类的对象，也加载了其特有的属性和方法，但因为其声明为了父类，就无法调用其特有的属性和方法。</li></ul></li></ul><p>多态性的应用：虚拟方法调用。编译时，认为方法声明的是父类的方法。执行时，实际执行的是子类重写的方法。<strong>编译看左边，运行看右边。</strong></p><p>多态仅仅适用于方法不适用于属性，<strong>本身也不建议在子类中定义与父类同名的属性</strong>。</p><h3 id="向下转型">向下转型</h3><p>类比基本数据类型的自动类型提升和强制类型转换。向上转型即为多态性，向下转型是多态的逆过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下转型的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dogAni</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span>(Dog) dogAni;<span class="comment">//向下转型后dog声明为Dog类</span></span><br><span class="line">        dog.catchMouse();</span><br><span class="line">        System.out.println(dogAni==dog);<span class="comment">//true,表明二者地址相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向下转型可能出现的问题：<strong>类型转换异常</strong>（ClassCastException）</p><p>为避免出现类型转换异常，建议在向下转型之前使用 *instanceof()*进行判断。<br>格式：<code>a instanceof A</code>判断对象a是否是类A的实例</p><p>如果<code>a instanceof A</code>为true，则<code>a instanceof superA</code>也为true，其中A是superA的子类。</p><h2 id="Object类及其常见方法使用">Object类及其常见方法使用</h2><p>Object类是Java类的根父类。<br>Object类中没有声明属性，Object类提供了一个空参的构造器。</p><p>clone()（了解）</p><p>再创建一个对象，内容与被克隆的完全一样，但是地址不同。</p><p>finalize()（了解）</p><p>在GC回收之前，进行finalize中的操作。</p><h4 id="equals-（掌握）">equals()（掌握）</h4><p>任何引用数据类型都可以使用。<br>自定义的类在使用equals方法没有重写时，调用的就是Object中的equals，比较两个对象的引用地址是否相同。<br>对于像String、File、Date和包装类等，他们都重写了Object类中的equals方法，用于比较两个对象的<strong>实体内容</strong>是否相等。</p><p>开发中往往要用equals比较两个对象的<strong>实体内容</strong>是否相等，这时候就要对equals进行重写。</p><h4 id="toString-（掌握）">toString()（掌握）</h4><p>开发中，在没有重写toString()方法时，打印的是类名+@+地址值<br>像String、File、Date和包装类等Object的子类，它们都已经重写了toString()方法，返回的是对象的实体内容。</p><p>开发中往往要用toString打印对象的<strong>实体内容</strong>，而非地址值。这时候，就要对toString进行重写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;面向对象(进阶)&lt;/h1&gt;
&lt;h2 id=&quot;this关键字&quot;&gt;this关键字&lt;/h2&gt;
&lt;p&gt;this可以调用：属性、方法；构造器&lt;/p&gt;
&lt;h3 id=&quot;this调用属性和方法&quot;&gt;this调用属性和方法&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;this&lt;/em&gt; 理解为当前对象，也就是</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象（基础）</title>
    <link href="http://cv-elevation.github.io/2025/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <id>http://cv-elevation.github.io/2025/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</id>
    <published>2025-04-19T13:15:48.000Z</published>
    <updated>2025-04-25T13:57:27.750Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象(基础)</h1><h4 id="序言">序言</h4><p>面向对象的三条主线：</p><ul><li>类及类的成员:属性、方法、构造器;代码块、内部类</li><li>特征:封装性、继承性、多态性</li><li>其他关键字:static、package、import</li></ul><h4 id="概述">概述</h4><p>对比面向对象和面向过程</p><ul><li>POP(Procedure Oriented Programming)以函数为单位，是一种执行者的思维</li><li>OOP(Object Oriented Programming)以类为单位，是一种设计者的思维</li></ul><p>面向对象编程的两个核心概念：类(Class)和对象(Object)，类是具有相同特征的集合，是抽象的；对象是实际存在的该类事物的个体，是具体的。</p><p>面向对象完成具体功能的操作流程：</p><ol><li>创建类，设计类的成员；</li><li>创建对象；</li><li>通过对象，调用其内部声明的属性或方法，完成相关功能。</li></ol><p>类的使用参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;<span class="comment">//测试类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person p1= <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//创建对象</span></span><br><span class="line">        p1.name=<span class="string">&quot;Miku&quot;</span>;<span class="comment">//通过对象，调用其内部声明的属性或方法</span></span><br><span class="line">        p1.id=<span class="number">233</span>;</span><br><span class="line">        p1.age=<span class="number">14</span>;</span><br><span class="line">        p1.gender=<span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+p1.name+<span class="string">&quot;标号：&quot;</span>+p1.id+<span class="string">&quot;年龄: &quot;</span>+p1.age+<span class="string">&quot;性别: &quot;</span>+p1.gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//创建类，设计类的成员；</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果: 姓名：Miku标号：233年龄: 14性别: 女</span></span><br></pre></td></tr></table></figure><h4 id="类中对象的内存解析">类中对象的内存解析</h4><p>Java中内存结构的划分：<strong>虚拟机栈、堆、方法区</strong>；程序计数器、本地方法栈</p><ul><li>虚拟机栈：以栈帧为基本单位；入栈对应方法的执行；方法的局部变量会存储在栈帧中</li><li>堆空间：new出来的结构（数组、对象）1.数组的元素2.对象的成员变量。</li><li>方法区：加载的类的模板结构。</li></ul><p>参考一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person p1= <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.age=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//创建类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内存上，使用new之后，会在堆里创建一段空间用于存储name、id、age，而<strong>p1在栈中存储这段空间的首地址</strong>。之后对p1.age进行赋值，是在堆中改变了age的值。</p><ul><li>可以总结出引用数据类型存储的其实都是<strong>地址</strong></li></ul><h4 id="类的成员之一：属性">类的成员之一：属性</h4><p>变量可以按类型分类也可以按照声明位置分类，按位置可以分为成员变量和局部变量。</p><p>属性的别名：成员变量、field(字段、域)</p><p>成员变量和局部变量对比</p><ol><li>位置不同</li><li>内存分配不同：局部变量保存在栈、成员变量保存在堆</li><li>生命周期：<br><strong>成员变量随对象产生随对象消亡，局部变量在栈帧中分配，随方法出栈消亡</strong></li><li>成员变量可用权限修饰符修饰，局部变量不行</li><li>默认值：局部变量没有默认初始化值，属性都有其默认初始化值</li></ol><h4 id="类的成员之二：方法">类的成员之二：方法</h4><p>Java的方法<strong>不能独立存在</strong>，必须定义在类里</p><ol><li><p>方法的声明格式:<br>权限修饰符 + [其他修饰符] + 返回值类型 + 方法名(形参列表)[throws 异常类型]{//方法头<br>//方法体<br>}</p></li><li><p>调用本类方法：方法可以调用本类其他方法，也可以调用自己（递归）</p></li><li><p>return的使用：</p></li></ol><ul><li><p>结束方法</p></li><li><p>将结果返回给其<strong>调用者</strong></p></li></ul><ol start="4"><li>形参和实参</li></ol><ul><li>形参：定义方法时，声明的变量成为形参</li><li>实参：调用时实际传给形参的变量/常量/表达式</li></ul><h4 id="再谈方法">再谈方法</h4><p>方法是设计类的核心，能否实现功能主要看方法。下面就重载、可变个数形参、值传递机制、迭代等方法的应用再进行补充说明。</p><h5 id="重载（overload）">重载（overload）</h5><p>重载是指同一个类中两个方法名相同的情况，要讨论的核心其实是Java编译其辨别不同方法的机制</p><p>是否为不同方法仅与<strong>方法名</strong>和<strong>形参列表</strong>有关</p><ul><li>注：形参列表不同只与形参的类型有关，而与其名称无关。相应的，类型相同，顺序不同也是两个方法。</li><li>关于自动类型提升，编译方面会能不自动提升就不自动提升。</li></ul><h5 id="可变个数形参（jdk5-0的新特性）">可变个数形参（jdk5.0的新特性）</h5><p>场景：形参类型确定，个数不确定</p><p>格式：<code>(类型 ... 参数名)</code></p><p>说明：</p><ul><li>个数为0,1,2……</li><li>与其他同名的方法可以构成重载，且当类型相同时可变个数的方法优先级较低</li><li>特例：可变个数的方法与另一个同名的以同类型数组为参数的方法不构成重载</li><li>方法内调用还是用数组</li><li>可变形参必须为于列表最后</li><li>在一个方法的形参列表中最多出现一次</li></ul><h5 id="值传递机制">值传递机制</h5><p>Java方法里的参数传递方式只用一种，就是值传递机制</p><p>方法内：基本数据类型传递数据值，引用数据类型传递地址值</p><p>方法参数传递：同样的，基本数据类型传递数据值，引用数据类型传递地址值</p><h5 id="递归">递归</h5><p>方法自己调自己的操作就叫递归</p><ul><li>可分为间接递归和直接递归</li><li>迭代其实是一种隐式循环，要避免无穷递归，会发生爆栈（StackOverflowError）</li><li>在使用递归的时候要注意朝着已知的反向走</li><li>注意：递归具有显著的缺点，层次多时运行较慢。相较于循环，递归花时间又耗内存，所以能用循环解决的问题就不要用递归</li></ul><h4 id="对象数组">对象数组</h4><p>数组的元素是引用数据类型中的类时，就称为对象数组</p><p>注意：在对象数组赋值前一定要实例化，否则会报空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">20</span>];<span class="comment">//Student为类，这里创建对象数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;students.length;i++)&#123;</span><br><span class="line">    students[i]=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//实例化</span></span><br><span class="line">    students[i].id=i+<span class="number">1</span>;<span class="comment">//赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="package和import关键字">package和import关键字</h4><h5 id="package">package:</h5><ol><li><p>一个源文件只能有一个package语句</p></li><li><p>package语句必须作为Java源文件的第一条语句，若缺省则为无名包</p></li><li><p>包对应于文件目录</p></li><li><p>同一个包下的类不能重名，不同包可以有重名的类</p></li></ol><p>MVC设计模式：</p><ul><li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li><li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li><li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li></ul><h5 id="import">import:</h5><ol><li><p>用于导入想用的类所在的包</p></li><li><p>使用：import 包名.类名，import 包名.*表示该包下的所有类</p></li><li><p>.a包的类已经导入，如果想用该包子包下的类，仍要导入</p></li><li><p>如果用类名冲突，可以使用<strong>全类名</strong>的方式调用</p></li></ol><h4 id="面向对象特征之一：封装性">面向对象特征之一：封装性</h4><p>表格：四种权限修饰符的范围</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">public</th><th style="text-align:center">protected</th><th style="text-align:center">缺省</th><th style="text-align:center">private</th></tr></thead><tbody><tr><td style="text-align:center">同类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">同包</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">子类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">不同包</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>问：如何理解封装性？</p><ol><li><p>Java规定了4中权限修饰符。我们可以使用这四种权限修饰符来修饰类的内部成员。当这些成员被调用的时候，体现可见性的大小。</p></li><li><p>封装性的体现（举例）</p></li></ol><ul><li><p>私有化类的属性，提供公共的get 和 set方法来更改</p></li><li><p>将类中不需要对外暴露的方法设为private</p></li><li><p>单例模式（在static后讲）</p></li></ul><ol start="3"><li>体现了程序设计的原则：高内聚、低耦合</li></ol><p>注：类只能使用public和缺省修饰</p><h4 id="类的成员之三：构造器">类的成员之三：构造器</h4><p>构造器（constructor）</p><p>构造器的定义格式<br><code>权限修饰符 类名(形参列表)&#123;&#125;</code></p><p>构造器的作用</p><ol><li>搭配new关键字，创建类的对象</li><li>在创建对象的同时，可以给对象的相关属性赋值</li></ol><p>在没有显式提供构造器的情况下，系统会默认提供一个空参的构造器，且构造器的权限和类的权限相同</p><p>一旦显式声明了构造器，系统就不再提供空的构造器</p><p>构造器重载，一个类中可以声明多个构造器，彼此构成重载</p><p><strong>匿名对象</strong><br>直接使用(new 类名(参数列表))作为实参传递给方法，适合用于一次性的对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;面向对象(基础)&lt;/h1&gt;
&lt;h4 id=&quot;序言&quot;&gt;序言&lt;/h4&gt;
&lt;p&gt;面向对象的三条主线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类及类的成员:属性、方法、构造器;代码块、内部类&lt;/li&gt;
&lt;li&gt;特征:封装性、继承性、多态性&lt;/li&gt;
&lt;li&gt;其他关键字:static、pack</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Java基本语法</title>
    <link href="http://cv-elevation.github.io/2025/04/16/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://cv-elevation.github.io/2025/04/16/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2025-04-16T11:08:50.000Z</published>
    <updated>2025-06-28T13:54:33.244Z</updated>
    
    <content type="html"><![CDATA[<h1>0.简单的DOS命令</h1><p>md（生成文件），cd（跳转路径），rd（del）（删除文件），dir（显示文件目录）</p><h1>1.JAVA程序基本结构</h1><ul><li>JAVA执行的基本流程：</li></ul><p>编写.java文件，之后由javac.exe文件生成字节码文件（.class），再由java.exe运行。</p><h2 id="简单的HelloWorld程序：">简单的HelloWorld程序：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloChina</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Angel Beats!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在class内部，可以定义若干方法（method）。</li></ul><h2 id="关于命名">关于命名</h2><p><strong>JAVA严格区分大小写，而Windows不区分大小写。</strong></p><p>类名要求：</p><ul><li>类名必须以英文字母开头，后接字母，数字和下划线的组合</li><li>习惯以大写字母开头，使用驼峰命名</li></ul><p>方法名、变量名：</p><ul><li>和类名一样，不过首字母要小写，使用小驼峰命名</li></ul><h2 id="关于注释">关于注释</h2><p>JAVA特有：文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*look in my eyes!</span></span><br><span class="line"><span class="comment">*<span class="doctag">@KuoZ</span></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="练习题">练习题</h2><h4 id="1-为什么JAVA是半编译半解释型语言？">1.为什么JAVA是半编译半解释型语言？</h4><h4 id="2-内存泄漏和内存溢出是什么，JAVA还会发生这些问题吗？能否举一个例子？">2.内存泄漏和内存溢出是什么，JAVA还会发生这些问题吗？能否举一个例子？</h4><h4 id="3-一个JAVA文件里能否声明多个类，有什么限制？">3.一个JAVA文件里能否声明多个类，有什么限制？</h4><h1>2.变量和运算符</h1><h2 id="关键字和标识符">关键字和标识符</h2><ul><li><p>JAVA里一共有50个关键字。false和true可以当做关键字来看待。</p></li><li><p>还有goto和const两个<strong>保留字</strong></p></li><li><p>可以自己起名的都是标识符，包括类名、方法名、变量名、接口名等。</p></li></ul><h2 id="变量">变量</h2><h4 id="JAVA中变量的两种类型">JAVA中变量的两种类型</h4><p>基本数据类型</p><ul><li>整型 byte short int long</li><li>浮点型 float double</li><li>字符型 char</li><li>布尔型 boolean</li></ul><p>引用数据类型（先记录三类）</p><ul><li>类</li><li>数组</li><li>接口</li></ul><h4 id="基本数据类型">基本数据类型</h4><ol><li>整型<br>分别占1、2、4、8个字节。与c语言不同，JAVA只定义了带符号的整型。long型结尾需要加L/l。不加则为int类型，但是int类型可以赋值给long型，可以正常运行。</li><li>浮点型<br>分别占用4、8字节。对于float类型,需要加上f后缀，否则默认为double类型。<br>ps:十进制小数和二进制小数并不能一一对应，二进制小数不能准确表示0.1、0.01……这些10的负次幂的数。所以说对于语句<code>System.out.println(0.1+0.2);</code>输出的结果不等于0.3。</li><li>字符型<br>占两个字节，JAVA的char类型除了用ASCII码外，还可以用<strong>Unicode码</strong>赋值。综合下来可以有四种形式对char型赋值</li></ol><ul><li><code>char name = '中'</code> 用一对单引号括起来进行赋值，单引号内有且仅有一个字符</li><li><code>char name='\u0036'</code>单引号内是\u+相应的Unicode码</li><li><code>char name='\n'</code>单引号内是转义字符</li><li><code>char name=51</code>直接用ASCII码对字符进行幅值</li></ul><ol start="4"><li><p>布尔型<br>布尔型只有<code>true</code>和<code>false</code>两种取值，且不能用1、0代替。在编译时不谈boolean型的占用字节，在内存分配上，实际上占用<strong>4个字节</strong>。</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps：JVM的内存分配问题：小于4个字节的分配1个slot（slot，槽位，等于4个字节），大于四个字节的分配2个slot。</span><br></pre></td></tr></table></figure></li></ol><h4 id="var关键字">var关键字</h4><p>使用var时，会自动根据赋值语句来判断变量类型，实际上也就是省了写变量类型。</p><p>注意：<strong>var关键字在JAVA10之后才有。</strong></p><h4 id="常量">常量</h4><p>使用final表示常量类型，如<code>final int AGE = 20 </code>。常量的命名应全大写，使用常量以避免被人诟病”MagicNumber”。</p><h4 id="作用域（scope）">作用域（scope）</h4><p>定义作用域时，要遵循作用域最小原则，尽量少定义全局变量，也不要重复使用变量名。</p><h4 id="基本数据类型变量运算规则">基本数据类型变量运算规则</h4><ul><li><p>对于变量之间运算问题，变量的类型问题尤为重要。</p></li><li><p>除布尔型的其他7种基本数据类型可以参与运算，运算时候的变量类型问题如下：</p></li></ul><h5 id="自动类型提升">自动类型提升</h5><p>自动类型提升用于将<strong>容量</strong>小的变量类型自动提升为<strong>容量</strong>大的类型（ps：容量指的是表示数的范围大小而非所占内存大小）<br>结论：</p><pre><code class="highlight mermaid">graph LRA[byte]==&gt;B[int]C[short]==&gt;BD[char]==&gt;BB==&gt;E[long]E==&gt;F[float]F==&gt;G[double]</code></pre><p>整型常量默认为int型，浮点型默认为double型。byte、short、char之间运算结果为int型。</p><h5 id="强制类型转换">强制类型转换</h5><ul><li><p>强制类型转换用于将变量强制转换为指定类型。使用“( )“,”( )”内写上指定类型。</p></li><li><p>强制类型转换的本质是<strong>截断</strong>，直接将所存数据的多的字节截去，这牵扯到补码。</p></li><li><p>强制类型转换过程中可能有精度损失。</p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> testNum;</span><br><span class="line"><span class="type">int</span> intNum=<span class="number">128</span>;</span><br><span class="line">testNum=(<span class="type">byte</span>)intNum;</span><br><span class="line">System.out.println(testNum);</span><br><span class="line"><span class="comment">//运行结果是？-128</span></span><br></pre></td></tr></table></figure><p>这里的解释（不用太深入探究）：128为0b1000 0000，截断后变为0b1000 0000，赋值给testNum，如果不深究的话可以直接认为计算机规定0b1000 0000为-128。如果深究的话，0b1000 0000是一个负数的补码，按照规则求原数，减去1得到0b0111 1111，再取反就是0b1000 0000，其大小是128，表明这个负数的绝对值是128，自然这个数就是-128。不要试图求0b1000 0000的原码，因为其无对应原码(128超出了byte类型的范围)</p><h4 id="String类">String类</h4><ul><li><p>String类为引用数据类型，使用时用“ ”括起来的字符串赋值。</p></li><li><p>String类型使用”+“连接符进行运算，可以与基本数据类型（包括布尔型）和String类型进行运算。结果为String类型。</p></li></ul><h2 id="运算符">运算符</h2><h4 id="运算符类型">运算符类型</h4><p>包括算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符和条件运算符</p><h4 id="算术运算符">算术运算符</h4><ul><li>除常见的加减乘除外还有++、- -、连接符+</li><li>运算遵从四则运算规则</li></ul><h5 id="运算符（以-为例）：">++ - -运算符（以++为例）：</h5><p>1.区分先++、后++:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++;<span class="comment">//先取值后加1</span></span><br><span class="line">++a;<span class="comment">//先加1后取值</span></span><br></pre></td></tr></table></figure><p>这里可以引入操作数栈的概念理解，看下边的练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">m=n=<span class="number">1</span>;</span><br><span class="line">m=m++;<span class="comment">//m等于1。先将m的值1放入操作数栈，然后将m加1，再把操作数栈的数（1）赋值给m</span></span><br><span class="line">n=++n;<span class="comment">//n等于2。先将将n加1，然后n的值2放入操作数栈，再把操作数栈的数（2）赋值给n</span></span><br></pre></td></tr></table></figure><p>2.num++和num=num + 1的区别，num++不改变变量类型，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> num=<span class="number">1</span>;</span><br><span class="line">num++;<span class="comment">//不报错</span></span><br><span class="line">num=num + <span class="number">1</span>;<span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><h4 id="赋值运算符">赋值运算符</h4><p>重点介绍+=、-+、*=、/=、%=在参与运算时的数据类型。<br>与num++类似，上边的运算符也不改变数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> num=<span class="number">1</span>;</span><br><span class="line">num+=<span class="number">2</span>;<span class="comment">//不报错，实际上可以理解为num=(byte)(num + 2)</span></span><br><span class="line">num=num + <span class="number">2</span>;<span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><p>练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">n+=(n++)+(++n);<span class="comment">//n=n+(n++)+(++n)结果为10+10+12=32</span></span><br></pre></td></tr></table></figure><h4 id="比较运算符">比较运算符</h4><p>==  !=  &gt;=  &lt;=  &gt;  &lt;  instanceof</p><ul><li>运算结果为布尔型</li><li>除布尔型外的7中基本变量类型可以参与比较运算</li><li>==  !=适用于引用数据类型</li></ul><h4 id="逻辑运算符">逻辑运算符</h4><p>区分&amp;和&amp;&amp;</p><h4 id="位运算符（难点非重点）">位运算符（难点非重点）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; &lt;&lt; &gt;&gt;&gt;(无符号右移) &amp; | ^ ~</span><br></pre></td></tr></table></figure><ul><li>位运算符的运算效率较高</li></ul><h4 id="条件运算符">条件运算符</h4><p>条件表达式？表达式1：表达式2<br>条件表达式为true执行表达式1，为false执行表达式2</p><ul><li>条件运算符的运算效率比if else略高</li></ul><h2 id="练习题-2">练习题</h2><h4 id="1-效率较高地运算2-8">1.效率较高地运算2*8</h4><h4 id="2-和-的区别">2.&amp;和&amp;&amp;的区别</h4><h4 id="3-boolean型变量占用的字节数">3.boolean型变量占用的字节数</h4><h4 id="4-为什么0-1-0-2不等于0-3">4.为什么0.1+0.2不等于0.3</h4><h1>3.流程控制</h1><h2 id="Scanner类和random（）方法">Scanner类和random（）方法</h2><p>在流程控制之前，先介绍两个类方法</p><ol><li>Scanner类：</li></ol><p>使用Scanner类的一般代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导入包</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerTemplate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arr)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建对象，格式固定</span></span><br><span class="line"><span class="type">int</span> inputNum=input.nextInt();<span class="comment">//变量类型不同，相应有不同的方法</span></span><br><span class="line">input.close();<span class="comment">//收回，防止内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见Scanner的类方法：</p><table><thead><tr><th>Modifier and Type</th><th>Method</th></tr></thead><tbody><tr><td>String</td><td>next()</td></tr><tr><td>boolean</td><td>nextBoolean()</td></tr><tr><td>byte</td><td>nextByte()</td></tr><tr><td>short</td><td>nextShort()</td></tr><tr><td>int</td><td>nextInt()</td></tr><tr><td>float</td><td>nextFloat()</td></tr><tr><td>double</td><td>nextDouble()</td></tr></tbody></table><ol start="2"><li>random()</li></ol><ul><li>Math类的random()方法：返回一个[0 , 1)范围的double类型的随机数。</li></ul><p>获得指定范围的随机整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定范围为[a , b]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomInt</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*(b-a+<span class="number">1</span>))+a;<span class="comment">//注意强转和所乘倍数</span></span><br></pre></td></tr></table></figure><h2 id="分支语句">分支语句</h2><h4 id="if-else">if else</h4><p>和C语言几乎完全一致，在此省略。</p><h4 id="switch-case">switch case</h4><p>语法结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">                <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">                           执行语句<span class="number">1</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">                           执行语句<span class="number">2</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                           <span class="keyword">break</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>与if-else不同，switch-case具有<strong>穿透性</strong></p></li><li><p>switch-case通常用于情况有限的问题</p></li><li><p>default位置可以改变</p></li><li><p>switch中的表达式只能是特定的数据类型：byte  short  char  int ; 枚举(JDK5.0新增)  String(JDK7.0新增)</p></li></ul><p>一个利用穿透性的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">           <span class="type">int</span> month=input.nextInt();</span><br><span class="line">           <span class="type">int</span> days=input.nextInt();</span><br><span class="line">           input.close();</span><br><span class="line">           <span class="type">int</span> sumDays=days;</span><br><span class="line">           <span class="keyword">switch</span>(month)&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                   sumDays+=<span class="number">30</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                   sumDays+=<span class="number">31</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                   sumDays+=<span class="number">30</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                   sumDays+=<span class="number">31</span>;        </span><br><span class="line">           <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                   sumDays+=<span class="number">31</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                   sumDays+=<span class="number">30</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                   sumDays+=<span class="number">31</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                   sumDays+=<span class="number">30</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                   sumDays+=<span class="number">31</span>;        </span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                   sumDays+=<span class="number">28</span>; </span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                   sumDays+=<span class="number">31</span>;</span><br><span class="line">           <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(sumDays);</span><br></pre></td></tr></table></figure><h4 id="对比">对比</h4><ul><li>能用switch-case的，都可以用if-else代替</li><li>switch-case比if-else的效率稍高</li></ul><h2 id="循环语句">循环语句</h2><p>循环的四要素</p><ol><li><p>初始化部分</p></li><li><p>循环条件部分–&gt;boolean类型的变量或表达式</p></li><li><p>循环体部分</p></li><li><p>迭代部分</p></li></ol><h4 id="for循环">for循环</h4><p>for(1;2;4){<br>3<br>}</p><ul><li>一般用于有明显循环次数（范围）需求的问题</li></ul><h4 id="while循环">while循环</h4><p>1<br>while(2){<br>3<br>4<br>}</p><ul><li>一般用于不知道循环多少次的问题</li><li>初始化条件的作用域与for循环不同，while循环的初始化条件在循环语句之后依旧有效</li></ul><h4 id="do-while循环">do-while循环</h4><p>1<br>do {<br>3<br>4<br>}while(2);</p><ul><li>至少执行一次循环体</li></ul><h4 id="无限循环">无限循环</h4><ul><li>结构：while(true)和for(;;)</li><li>需要根据一定的条件使用break终止循环</li><li>如果循环无法终止，就构成了死循环，开发中要避免死循环。死循环的后边不能有语句，否则编译会报错</li></ul><h4 id="嵌套循环">嵌套循环</h4><p>例：使用嵌套for循环显示菱形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Diamond</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arr)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        input.close();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(row+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=row+<span class="number">1</span>-i*<span class="number">2</span>;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;       </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=row-i*<span class="number">2</span>;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(row-<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;       </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=row-<span class="number">2</span>*i;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="break、continue">break、continue</h4><table><thead><tr><th style="text-align:left"></th><th>适用范围</th><th>在循环结构中的作用</th><th>相同点</th></tr></thead><tbody><tr><td style="text-align:left"><strong>break</strong></td><td>switch-case语句/循环结构</td><td>一旦执行，结束(或跳出)<strong>当前</strong>循环结构</td><td>此关键字的后面，不能声明语句</td></tr><tr><td style="text-align:left"><strong>continue</strong></td><td>循环结构</td><td>一旦执行，结束(或跳出)<strong>当次</strong>循环结构</td><td>此关键字的后面，不能声明语句</td></tr></tbody></table><h4 id="算法好坏">算法好坏</h4><p>currentTimeMillis()方法可获得从标准时间点到现在的时间（以ms为单位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        案例：找出100000以内的所有质数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100000</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;Math.sqrt(i);j++)&#123;<span class="comment">//使用开根值可大大加快速度</span></span><br><span class="line">                    <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                        isFlag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//避免多余操作</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;time spend: &quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.数组</h1><h2 id="数组使用">数组使用</h2><ol><li>声明和初始化：<br>初始化后数组的长度就确定了，无法更改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义：类型[] 数组名 = new 类型 [长度];</span></span><br><span class="line"><span class="comment">//第一种方式（静态初始化）</span></span><br><span class="line"><span class="type">int</span>[] arr;<span class="comment">//声明</span></span><br><span class="line">arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span>&#125;;<span class="comment">//进一步简写，必须写在一行！</span></span><br><span class="line"><span class="comment">//第二种方式（动态初始化）</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];<span class="comment">//声明和初始化</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>数组的调用<br>与c语言相同，省略。</p></li><li><p>数组的属性length<br>用来描述数组容器的容量大小，可以使用<code>数组名.length</code>获得数组长度。</p></li><li><p>数组的遍历<br>使用for循环</p></li><li><p>数组的默认初始化</p><table><thead><tr><th>类型</th><th>初始化值</th></tr></thead><tbody><tr><td>整型</td><td>0</td></tr><tr><td>浮点型</td><td>0.0</td></tr><tr><td>字节型</td><td>0(或者‘\u0000’)</td></tr><tr><td>布尔型</td><td>false</td></tr><tr><td>引用数据类型</td><td>null</td></tr></tbody></table></li><li><p>一维数组的内存解析<br>JVM中与此相关的内容：栈(stack)、堆(heap)，在此不展开描述。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">        <span class="type">int</span>[] arr1 =arr;</span><br><span class="line">        arr1[<span class="number">1</span>]=<span class="number">114</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);<span class="comment">//114</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组变量存储的实际上是首地址，在这段代码中创建arr1时并未在堆中开辟一段新内存，因此更改arr1的数组内容也同样更改了arr的数组内容。</p></li></ol><h2 id="二维数组">二维数组</h2><p>所谓的二维数组本质上还是数组，也就是说Java中实际上不存在二维数组这一数据结构。</p><ul><li><p>调用内层<br>返回的是元素值</p></li><li><p>调用外层<br>返回的是地址值</p></li><li><p>内存解析<br>数组元素名存放的是一个数组的首地址，这个数组存放各个第二层数组的首地址</p></li></ul><h2 id="常见算法操作">常见算法操作</h2><h4 id="扩容-缩容">扩容/缩容</h4><p>数组的扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//扩容1倍容量</span></span><br><span class="line">        <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span> [arr.length&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//复制到新的数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            newArr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加新的数字</span></span><br><span class="line">        newArr[arr.length] = <span class="number">10</span>;</span><br><span class="line">        newArr[arr.length + <span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        newArr[arr.length+<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//将新的数组地址赋值给原有的数组变量</span></span><br><span class="line">        arr = newArr;</span><br><span class="line">        System.out.println(arr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的缩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不新建数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delMinus</span> <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> delMinus; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delMinus</span> <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; delMinus; i++) &#123;</span><br><span class="line">            newArr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> delMinus; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            newArr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr = newArr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找">查找</h4><p>线性查找<br>逐个遍历，算法简单、适用性广但效率较低。</p><p>二分查找<br>前提：只适用有序数组，算法较复杂，但效率较高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tail=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (head&lt;=tail) &#123;</span><br><span class="line">            mid=(head+tail)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid]==target) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到了,在第&quot;</span>+mid+<span class="string">&quot;个位置&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target&gt;arr[mid]) &#123;</span><br><span class="line">                head=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head &gt; tail) System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序">排序</h4><p>冒泡排序，需要会手写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">90</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>-j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">                    arr[i+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序，需使用迭代，不必会手写，掌握实现思路即可。</p><h4 id="Arrays常见工具类">Arrays常见工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrToolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//打印数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr) );<span class="comment">//[1, 2, 3, 4, 5, 8, 5, 7, 7]</span></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr) );<span class="comment">//[1, 2, 3, 4, 5, 5, 7, 7, 8]</span></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        System.out.println(Arrays.binarySearch(arr,<span class="number">2</span>));<span class="comment">//1</span></span><br><span class="line">        <span class="comment">//填充数组</span></span><br><span class="line">        Arrays.fill(arr,<span class="number">6</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr) );<span class="comment">//[6, 6, 6, 6, 6, 6, 6, 6, 6]</span></span><br><span class="line">        <span class="comment">//相等判断</span></span><br><span class="line">        <span class="type">int</span> [] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.equals(arr,arr2);</span><br><span class="line">        System.out.println(Arrays.equals(arr,arr2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;0.简单的DOS命令&lt;/h1&gt;
&lt;p&gt;md（生成文件），cd（跳转路径），rd（del）（删除文件），dir（显示文件目录）&lt;/p&gt;
&lt;h1&gt;1.JAVA程序基本结构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JAVA执行的基本流程：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编写.java文件，之</summary>
      
    
    
    
    
    <category term="JavaSE" scheme="http://cv-elevation.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>主题~</title>
    <link href="http://cv-elevation.github.io/2025/03/30/theme/"/>
    <id>http://cv-elevation.github.io/2025/03/30/theme/</id>
    <published>2025-03-30T05:44:57.000Z</published>
    <updated>2025-06-03T13:14:42.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一点牢骚">一点牢骚</h2><p>​我自己的博客网站基本配置好了，选了张涩涩的miku当头图，或许这样能让我写代码和文的时候肾上腺素提升从而提高效率呢（<s>bushi</s>）。<br>​好像很多技术党都有一个自己博客，我也就东施效颦一下，但是其实更多的原因还是因为他人，也就是跟风。一直以来，我好像都缺乏一个内源的动力和目标，也没有什么自己的想法和意志，一直都是在不停地模仿。但是那又如何呢？<br>​我真的很讨厌自己去做选择，既没有能做出正确决定的视野，连做出决定的决心也没有。算了，我也不想过分自贬，就这样吧。</p><p>​言归正传，用了一天半搭建的网站还是可以庆祝一下的，也是有了一个个人的空间，或许可以成为我之后若干年还活着的证明。<br>​整体来讲，我想写一个是学习笔记，专业的技术文我也没有写的实力，还有就是一个经验积累，最后就是一些随想，当日记写呗就。</p><p>​最后附一张可爱的公主殿下！（<s>typora的图片直接插入功能太好用了</s>）</p><p><img src="/2025/03/30/theme/%E5%88%9D%E9%9F%B3.jpg" alt="初音"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一点牢骚&quot;&gt;一点牢骚&lt;/h2&gt;
&lt;p&gt;​		我自己的博客网站基本配置好了，选了张涩涩的miku当头图，或许这样能让我写代码和文的时候肾上腺素提升从而提高效率呢（&lt;s&gt;bushi&lt;/s&gt;）。&lt;br&gt;
​		好像很多技术党都有一个自己博客，我也就东施效颦一下，但是其实</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://cv-elevation.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
