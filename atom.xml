<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KuoZ&#39;s blog</title>
  
  
  <link href="http://cv-elevation.github.io/atom.xml" rel="self"/>
  
  <link href="http://cv-elevation.github.io/"/>
  <updated>2025-08-06T01:29:36.774Z</updated>
  <id>http://cv-elevation.github.io/</id>
  
  <author>
    <name>KuoZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025电赛小结</title>
    <link href="http://cv-elevation.github.io/2025/08/06/2025%E7%94%B5%E8%B5%9B%E5%B0%8F%E7%BB%93/"/>
    <id>http://cv-elevation.github.io/2025/08/06/2025%E7%94%B5%E8%B5%9B%E5%B0%8F%E7%BB%93/</id>
    <published>2025-08-06T01:27:54.000Z</published>
    <updated>2025-08-06T01:29:36.774Z</updated>
    
    <content type="html"><![CDATA[<h1>2025年电赛小结</h1><h2 id="序言：">序言：</h2><p>2025年电赛，我们选做的是G题。目前还没有出结果，估计最后不加报告是70分，进国测应该是没希望了。不过对于一个已经转码，决定不搞硬件的人来说其实可以接受了。</p><h2 id="日志：">日志：</h2><h3 id="2025年7月30日上午">2025年7月30日上午</h3><p>选定题目</p><p>D、G甚至F</p><p>G：感觉难点在于如何复现信号，保证同频</p><p>D：应该算精密测量了</p><p>F：完全不想做</p><p>G题大题思路：</p><p>G题最重要的就是测量后DAC复现的问题：</p><ul><li><p>数字滤波器？参数固定，不可即时更改(deprecated)（赛后补充，其实我最开始这个想法是正确的，但是和队长商量后他给出了这样的回复，总之就是还是不熟悉吧，也实现不了）</p></li><li><p>使用dds合成后dac输出，高精度，或许可以抵消滚波（赛后补充，赛后证明是可以的方案，确实可以实现无反馈锁相，只要输出的基波频率足够准确）</p></li></ul><p>基础部分：</p><ol><li>搭出预设的电路</li></ol><p>经仿真，是一个低通滤波器</p><p>且在100Hz~3kHz范围内放大倍数约在5~0.7倍</p><ol start="2"><li>后续电压步进要在0.1V，所以dac精度应至少有0.02V</li></ol><p>使用ad9959可以轻松达到此精度</p><p>发挥部分：</p><p>现在有3种方案</p><p>1.FIR</p><p>2.FFE</p><p>3.高精度DDS</p><p>串口屏需求：</p><p>基础</p><ol><li>不加电路100~1MHz正弦波输出</li><li>加电路2V 1kHz  1~2V 步长0.1V（100Hz~3kHz）[设置+启动]</li></ol><p>发挥</p><ol start="3"><li>滤波类型判断（学习键）</li><li>数字重现（一键启动探究装置）</li></ol><h3 id="2025年7月31日上午">2025年7月31日上午</h3><p>完成了基础部分的全部内容，硬件结构有9959-&gt;放大器-&gt;已知电路模型</p><p>12:53:48</p><p>“如果解决不了这个问题，就等着退赛吧”，这是队长的原话。</p><p>起因是想移植之前写的fft到队长发来的代码框架，但是之后发生了严重问题！<br>这个程序只要一烧写，芯片就会死锁，然后死掉，程序也不能运行，以为是烧写器或板子的问题，就又换了一个板子，可谁曾想，换了之后另一个板子也崩了。</p><p>结果就是stm32都用不了了，这如果解决不了，我们就要退赛了。</p><p>烧写后，一直报cannot halt the core，知道这大概是死锁了，原因大概是flash中的程序上电后就在跑，导致了无法烧写。</p><p>在经过约一个小时的调试，找到了比较好的解决办法</p><p>首先记得条stlink的模式为normal，能够识别到stlink之后参考下述博客</p><p><a href="https://blog.csdn.net/a1247812862/article/details/97773789">stm32 Invalid Rom Table 至芯片锁死解决方案_stm32erase能清除锁死状态吗-CSDN博客</a></p><p>总归是解决了，这代码底板混用是真的不好！</p><h3 id="晚上：">晚上：</h3><p>完成了FFT算法和扫频的移植，准备搭建系统进行联调</p><h3 id="2025年8月1日">2025年8月1日</h3><p>时间是真紧，这还没干什么就倒数第二天早上了。其实队伍的节奏我不是很适应，感觉另两个队友总是早早地回去了，我自己也没什么事可以干，就也回去了。我是希望再多干一会儿的。这也导致了后边时间不够进而引发一些矛盾。</p><p>上午首次联调过后没有成功，事后证明当时是因为基准源没有接。就这么一个小问题，这也反映了一个很大的问题就是队伍的配合真是一坨屎，但凡好一点这一次电赛的结果都能好不少。</p><p>总之我又去调了代码，进行了优化。不过我当时没太关注相位谱的调试，因为我自己测了一些都还可以，就主要关注扫频的幅度谱了。</p><p>到了下午，队长突然又换了器件，原来使用9959结果又换成了FPGA的外接DAC，这里我其实就不是很认同，因为基础部分已经测试过了，那么就不应该改器件，后续也因此引起了不好的结果，但是好歹也救回来了。</p><p>总之方案也换了，原本我们是想用定时器去单独测频率的，后来又改成了用FFT去测，这个没问题。其实当时我有些质疑这里为什么要用FFT去扫频，又为什么要用FFT去得到输入信号的频谱。当时也能理解一些，因为用FFT去测量相位差是已经实现过的，直接分析输入信号的频谱可以应对更普遍的情况。但是事后证明，这个频谱分析的精度是难以实现的，不如直接判断波形，然后测量参数再得到频谱，再进行数字滤波。当时其实是向队长提出了这个疑问的，不过感觉他也没怎么想就把我驳回了。算鸟算鸟。</p><h2 id="总结">总结</h2><p>这次比赛最大的问题完全是配合问题，我觉得以我们的积累和能力最后完全有能力进国测，但是因为配合的问题最后搞得一团糟。</p><p>具体的配合问题：</p><p>1.交流太少，方案论证不够</p><p>2.配合不好，最后一晚，我写好的代码明明可以运行，结果发给队长。他就说会报错，我让他看看是不是环境或者编译器版本的问题，他也不想解决，感觉就是质疑我的代码有问题。最后提出了直接交换位置来改的提案，这个提案是真的也有它的问题。我要负责报告，但是他们的电脑上一个没有word，一个没有visio，结果写报告就非常痛苦，报告一直拖到第四天中午才写完。</p><p>3.刚才说到质疑代码有问题，这就是一个团队信任度的问题，我的代码直到最后也没发现有什么问题，最后烧写的也是我的环境上的代码。虽然有一点问题，不过当时我是真的承受了很大的压力，总之就是队长一直在压力我。这让我真的无语，你怎么不全部自己写stm32和fpga的代码呢，不还是没时间？如果你觉得自己完不成那么就必须承认要有一个人写FFT的代码，然后就是我来写了，虽然有一些问题，但是你压力人又有什么用呢？至少说，可能是不太熟，但是如果真还是这样，那这个队伍我应该是不想再待的。</p><p>具体也有技术的问题：</p><p>1.我的问题FFT分析代码不熟悉，不熟悉常规的频谱泄露解决、基波及各谐波频点的寻找、相位谱分析等。最严重的还是最后导致很大问题的相位谱分析，各谐波相位的测量，这个直到最后都不知道是什么问题，明明相位差可以测准，但是相位就是测不准，真的很离谱。</p><p>2.FPGA一个小组只有一个人会，还不太熟悉。这个问题个人觉得不是很大，毕竟这个本身就有难度。但是对于两个培训3年，一个培训2年的队员来说，这个还不会确实有一点问题。</p><p>总之复制8月2号凌晨5点的qq群情绪宣泄：</p><p>这次电赛我经历了什么？</p><p>芯片自锁、爆堆爆栈、程序跑飞、编译优化导致程序错误、内存管理</p><p>还有什么？</p><p>队友分歧，分崩离析，四肢不和，如同bangdream一样的组内关系</p><p>然后呢？</p><p>死气沉沉，熬个大夜，伤个大身</p><p>所以呢？</p><p><strong>不要来打电赛！不要来打电赛！不要来打电赛！</strong></p><p>除非你有信仰，真的有的话，应该是没有的。先问问你的mcu吧！求他不要跑飞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;2025年电赛小结&lt;/h1&gt;
&lt;h2 id=&quot;序言：&quot;&gt;序言：&lt;/h2&gt;
&lt;p&gt;2025年电赛，我们选做的是G题。目前还没有出结果，估计最后不加报告是70分，进国测应该是没希望了。不过对于一个已经转码，决定不搞硬件的人来说其实可以接受了。&lt;/p&gt;
&lt;h2 id=&quot;日志：&quot;</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://cv-elevation.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Redis之多级缓存</title>
    <link href="http://cv-elevation.github.io/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://cv-elevation.github.io/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2025-07-23T11:01:55.000Z</published>
    <updated>2025-07-23T11:03:42.635Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis之多级缓存——亿级流量方案</h1><h2 id="序言">序言</h2><p>传统缓存问题：</p><p>传统缓存一般是请求到达Tomcat后，Tomcat先查询Redis缓存，如果<strong>未命中</strong>则查询数据库。存在下面问题：</p><ol><li>请求要经过Tomcat服务器，Tomcat的性能成为整个并发缓存的瓶颈</li><li>如果Redis缓存失效，会对数据库产生冲击</li></ol><p>多级缓存</p><p>充分利用各环节，分别添加缓存，减轻Tomcat的压力</p><p>客户端缓存-&gt;NGINX本地缓存-&gt;Redis-&gt;Tomcat-&gt;DB</p><p>其中Nginx缓存是业务Nginx，通常部署为集群，再由专门的Nginx做反向代理</p><h2 id="JVM进程缓存">JVM进程缓存</h2><p>Caffeine技术</p><p>缓存驱逐策略：</p><ul><li>基于容量、基于时间、基于引用</li></ul><p>实现效果：</p><ul><li>第一次查询走数据库，然后就会放入缓存，之后查询就走缓存</li></ul><h2 id="Lua语法">Lua语法</h2><p>轻量小巧的脚本语言</p><p>数据类型</p><p>nil、boolean、number、string、function、table、type函数</p><p>变量</p><p>声明变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> var_name = var_value</span><br><span class="line">#数组</span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;c++&#x27;</span>&#125;</span><br><span class="line">#map</span><br><span class="line"><span class="keyword">local</span> map = &#123;name = <span class="string">&#x27;Jack&#x27;</span>,age = <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>访问数组，下标从一开始arr[1]</p><p>访问Map，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">map.name</span><br></pre></td></tr></table></figure><p>循环遍历</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;lua&#x27;</span>,<span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index,value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">    prinr(key,value)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name</span><span class="params">(para)</span></span></span><br><span class="line">    <span class="comment">---</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>条件控制</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    <span class="comment">---</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">---</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="多级缓存">多级缓存</h2><h3 id="配置nginx">配置nginx</h3><ol><li><p>OpenResty是基于Nginx的高性能Web平台</p></li><li><p>OpenResty使用流程类似于Nginx的使用</p></li><li><p>监听路径类似于Response<br>Lua文件类似于Service层</p></li><li><p>请求参数处理，不同参数格式有相应解析代码</p></li></ol><h3 id="nginx查询Tomcat">nginx查询Tomcat</h3><p>小规律：服务器前三位地址相同，第四位换为1</p><p>nginx提供了内部API用以发送http请求</p><p>Tomcat集群的负载均衡</p><p>保证缓存一直生效，同一路径访问同一服务器</p><p>修改负载均衡算法由轮询改为Hash算法来直接匹配</p><h3 id="添加Redis缓存">添加Redis缓存</h3><p>冷启动：服务器初启动时，没有缓存，此时查询会都导向数据库，带来较大的数据库压力</p><p>缓存预热：利用大数据统计热点数据，将热点数据存到缓存</p><h3 id="实现nginx优先查询Redis缓存：">实现nginx优先查询Redis缓存：</h3><p>OpenResty如何操作Redis？</p><p>OpenResty提供了操作Redis的模块，大概模块如下：</p><ul><li><p>封装函数，从Redis读取数据并返回</p></li><li><p>引入Redis模块，并初始化Redis模块</p></li><li><p>封装函数，释放Redis连接，其实是放入连接池</p></li></ul><h3 id="Nginx本地缓存">Nginx本地缓存</h3><p>利用shared dict开启词典</p><p>修改查询逻辑，加入缓存业务</p><h2 id="缓存同步">缓存同步</h2><p>三种方式</p><ol><li>设置有效期</li><li>同步双写，在修改数据的同时直接修改缓存</li><li>异步通知，改数据库时发事件通知，相关服务进行监听到通知后修改缓存</li></ol><p>监听mysql，使用MQ/canal实现</p><p>canal基于mysql的主从模式，canal伪装为mysql的一个slave节点完成通知</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis之多级缓存——亿级流量方案&lt;/h1&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;传统缓存问题：&lt;/p&gt;
&lt;p&gt;传统缓存一般是请求到达Tomcat后，Tomcat先查询Redis缓存，如果&lt;strong&gt;未命中&lt;/strong&gt;则查询数据库。存在下面问题：&lt;/</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://cv-elevation.github.io/tags/Redis/"/>
    
    <category term="lua" scheme="http://cv-elevation.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存——Redis高级篇</title>
    <link href="http://cv-elevation.github.io/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    <id>http://cv-elevation.github.io/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/</id>
    <published>2025-07-20T16:55:44.000Z</published>
    <updated>2025-07-20T16:58:49.844Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式缓存——Redis高级篇</h1><p>单节点Redis问题</p><ol><li>数据丢失问题：实现Redis数据持久化</li><li>并发能力问题：搭建主从集群，实现读写分离</li><li>故障恢复问题：Redis哨兵，实现健康检测和自动恢复</li><li>存储能力问题：搭建分片集群，利用插槽机制实现动态扩容</li></ol><h2 id="一、持久化">一、持久化</h2><h3 id="方式之一：RDB持久化">方式之一：RDB持久化</h3><p>RDB全称RedisDatabaseBackup file（Redis数据备份文件）</p><p>有两个命令可以进行RDB持久化</p><ol><li>save命令：由主进程执行RDB，会阻塞所有命令</li><li>bgsave命令：开子进程执行RDB，避免主进程受影响</li></ol><p>默认Redis停机时会执行一次RDB</p><p>（停机≠宕机）</p><p>可以通过修改redis.conf文件来配置相关的RDB参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="comment">#900秒内由1次修改，就会执行bgsave。参数可以进行修改</span></span><br><span class="line"><span class="comment">#是否压缩，建议不开启，压缩也会消耗CPU，磁盘的话相对不值钱</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment">#RDB文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment">#文件保存的路径目录</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure><p><strong>bgsave流程</strong></p><p>bgsave开始时会fork主进程得到子进程（在fork过程中主进程会被阻塞），子进程共享主进程的内存数据。fork后主进程可以正常读写，子进程会读取内存数据并写入RDB文件。</p><p>如果只是这样可能会有脏数据的问题，就是说在子进程读的时候主进程可能更改了数据。</p><p>要理解这个问题，需要理解内存结构。</p><p><img src="https://cdn.jsdelivr.net/gh/CV-Elevation/imgHub/article_img/image-20250719194405703.png" alt="image-20250719194405703"></p><p>如图是我参考课程使用visio绘制的fork框图，下面结合这个来解释一下fork的流程。</p><p>首先是关于linux的结构，在linux中，进程都是不能直接更改物理内存的，它在虚拟内存中，通过一个页表来维护关系，进程通过修改页表修改内存中的数据。</p><p>当使用bgsave的时候，首先会进行fork，会开启子进程，子进程复制主进程的页表，复制完后，为避免脏读的情况，会将数据A和数据B设为只读的共享内存，这样子进程在存储RDB时就不会被主进程干扰。</p><p>相应的主进程要更改数据，数据B会被拷贝为数据B的副本，主进程通过修改副本实现修改的功能。</p><p>因为内存进行了拷贝，所以极限情况下可能会占用两倍的内存，这也就是为什么使用Redis都要预留一定的内存空间。</p><p>RDB缺点：</p><ol><li>RDB间隔较长，两次RDB间由数据丢失风险</li><li>fork子进程、压缩写出RDB比较耗时</li></ol><h3 id="方式二：AOF持久化">方式二：AOF持久化</h3><p>AOF全程Append Only File（追加文件），可以看成命令日志文件</p><p>可以通过redis.conf配置文件开启和配置AOF</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">&quot;名字&quot;</span></span><br><span class="line"><span class="comment">#频率</span></span><br><span class="line">appendfsync always<span class="comment">#每执行一次命令，立即写到AOF</span></span><br><span class="line">appendfsync everysec<span class="comment">#写命令执行完先放入AOF缓冲区，每隔一秒将缓冲数据写到AOF</span></span><br><span class="line">appendfsync no<span class="comment">#写命令执行完先放入AOF缓冲区，由操作系统决定什么时候将缓冲数据写到AOF</span></span><br></pre></td></tr></table></figure><p><strong>AOF体积压缩</strong></p><p>因为AOF记录的是每条命令，多条命令叠加下可能很多命令是无效的，所以体积会很大。</p><p>可以使用bgrewriteaof命令将AOF文件进行重写以减小体积</p><p>什么时候进行重写？</p><p>可以在redis.conf文件中配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto<span class="literal">-aof-rewrite-percentage</span> <span class="number">100</span><span class="comment">#AOF文件增长超过多少百分比触发重写</span></span><br><span class="line">auto<span class="literal">-aof-rewrite-min-size</span> <span class="number">64</span>mb<span class="comment">#AOF文件体积最小多大以上触发重写</span></span><br></pre></td></tr></table></figure><h3 id="RDB和AOF对比">RDB和AOF对比</h3><p>各有优缺点，如果对数据安全性要求较高，在实际开发中往往会将两种方式结合起来使用</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高</td></tr></tbody></table><h2 id="二、主从集群">二、主从集群</h2><ul><li>搭建主从架构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CV-Elevation/imgHub/article_img/image-20250721000603573.png" alt="image-20250721000603573"></p><p>开启主从关系</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof/slaveof(<span class="number">5.0</span>之前) host port(主节点的)</span><br></pre></td></tr></table></figure><p>开启后主从搭建就完成了，主节点写，从节点只读</p><ul><li>数据同步原理</li></ul><p>全量同步</p><p>首次请求进行全量同步</p><p><img src="https://cdn.jsdelivr.net/gh/CV-Elevation/imgHub/article_img/image-20250721003505684.png" alt="image-20250721003505684"></p><p>增量同步</p><p>在上边全量同步的流程中，如果发现replid一致，就会进行增量同步。主节点会从log文件中获取offset以后的数据，发送offset之后的命令给从节点。</p><p>上边暂存的lrepl_baklog可以理解为是一个环形的结构，而这个环形的结构是有存储上限的。当slave和master之间差的offset超过repl——baklog的大小时，不能进行增量同步</p><p>优化：</p><ol><li>在master中配置repl-diskless-sunc yes，启用无磁盘复制，避免全量同步时的磁盘IO</li><li>Redis单节点的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>提高log的大小，发现slave宕机时尽快恢复，尽可能避免全量同步</li><li>限制一个master的slave数量，如果是在太多可以使用主从从结构</li></ol><h2 id="三、Redis哨兵">三、Redis哨兵</h2><h3 id="哨兵的作用：">哨兵的作用：</h3><ul><li>监控：Sentinel会不断检查您的master和slave是否按预期工作</li><li>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master，当故障实例恢复后也会以新的master为主</li><li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端</li></ul><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令</p><p>主观下线：如果Sentinel节点发现某实例未在规定时间内响应，则认为该实例主观下线</p><p>客观下线：若超过指定数量（quorum）的Sentinel都认为该实例主观下线，则该实例客观下线。quorum的值最好超过Sentinel实例数量的一半。</p><p>选择新的master的优先级：</p><ol><li>断开时间长短</li><li>slave-priority</li><li>offset</li><li>运行id，越小优先级越高</li></ol><h3 id="故障转移流程">故障转移流程</h3><ol><li>选择新的master，执行slave of no one</li><li>其他节点slave of新的master</li><li>修改故障节点配置，添加slave of新的master</li></ol><h3 id="搭建哨兵集群">搭建哨兵集群</h3><ol><li>新建sentinel.conf</li><li>配置ip、主从集群、目录</li></ol><h3 id="RedisTemplate的哨兵模式">RedisTemplate的哨兵模式</h3><ol><li>导入依赖</li><li>在yaml文件中配置sentinel集群地址</li><li>配置主从读写分离</li></ol><h2 id="四、Redis分片集群">四、Redis分片集群</h2><p>分片集群的作用：</p><p>海量数据存储</p><p>高并发写操作</p><p>分片集群说明：</p><ul><li>集群中有多个master</li><li>每个master都有多个slave</li><li>master之间通过ping监测批次的健康状态</li><li>客户端请求可访问集群的任意节点，最终都会被转发到正确节点</li></ul><h3 id="搭建">搭建</h3><p><code>redis-cli –-cluster create --cluster-replicas 1 X X X Y Y Y</code></p><p>因为设置每个master的slave个数为1，所以前三个为master，后三个是slave</p><h3 id="散列插槽">散列插槽</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hashslot）上，查看集群信息就能看到</p><p>数据key不是与节点绑定，而是与插槽绑定，redis会根据key的有效部分计算插槽值，分两种情况</p><ul><li>key中含有”{}“且{}中至少包含一个字符，则{}内的部分有效</li><li>key不是不含{}，整个key有效</li></ul><p>计算方法是有CRC16算法的一个hash值，然后对16384取余。</p><p>如何将同一类数据固定的保存在同一个Redis实例？</p><p>使用相同的有效部分，也就是{}内的部分相同</p><h3 id="添加一个节点到集群">添加一个节点到集群</h3><p>例：想集群中添加一个master节点，向其中添加一个num=10数据</p><ol><li>添加 使用addnode指令</li><li>插槽分配 使用<code>redis-cli —cluster reshard host port</code></li></ol><h3 id="故障转移">故障转移</h3><p>当集群中有一个master宕机会发生什么？</p><p>自动故障转移：</p><ol><li>该实例失去连接</li><li>疑似宕机</li><li>确定下线，自动提升一个slave为新的master</li></ol><p>如果想要手动更换master节点，使用failover指令进行故障转移</p><p>具体流程如下：</p><ol><li>slave节点告诉master节点拒绝任何客户端请求</li><li>master返回当前的数据offset给slave</li><li>slave等待offset与master一致</li><li>slave、master开始故障转移</li><li>slave标记自己为master，广播故障转移的结果</li><li>原master收到广播，开始处理客户端读的请求</li></ol><p>failover有3种模式：</p><ol><li>缺省，就是上述的默认模式</li><li>force，省略一致性检验的过程</li><li>takeover，直接执行步骤5</li></ol><h3 id="RedisTemplate访问分片集群">RedisTemplate访问分片集群</h3><p>与哨兵的配置类似</p><p>只是在yaml文件的配置不同</p><p>今天试了试用图床来插入图片，我已经受够了糟糕的mermaid流程图，还是visio画着舒服❤</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式缓存——Redis高级篇&lt;/h1&gt;
&lt;p&gt;单节点Redis问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据丢失问题：实现Redis数据持久化&lt;/li&gt;
&lt;li&gt;并发能力问题：搭建主从集群，实现读写分离&lt;/li&gt;
&lt;li&gt;故障恢复问题：Redis哨兵，实现健康检测和自动恢复&lt;/l</summary>
      
    
    
    
    
    <category term="Redis 分布式缓存" scheme="http://cv-elevation.github.io/tags/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架</title>
    <link href="http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/"/>
    <id>http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/</id>
    <published>2025-07-18T08:53:50.000Z</published>
    <updated>2025-07-29T08:27:50.864Z</updated>
    
    <content type="html"><![CDATA[<h1>Spring Framework</h1><p>Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=3">Spring-01-初识Spring_哔哩哔哩_bilibili</a></p><p>要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Spring源码的部分进一步学习。</p><p><strong>Spring系统架构</strong></p><img src="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/image-20250614224253416.png" alt="image-20250614224253416" style="zoom:30%;"><p><strong>IoC（Inversion of Control）控制翻转</strong></p><p>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象的创建控制权由程序转移到外部，这个思想就是<strong>控制翻转</strong>。</p><p>IoC、Bean和DI：</p><ul><li><p>Spring提供了一个容器，称为IoC容器，用来充当Ioc思想中的“外部”</p></li><li><p>IoC容器负责对象的创建、初始化的一系列工作，被创建或管理的对象在IoC容器中统称为<strong>Bean</strong></p></li><li><p>DI（依赖注入）在容器中建立起bean与bean之间的关系</p></li></ul><p>我们这样做的目的是充分解耦，具体做法可以概括如下：</p><ul><li>使用IoC容器管理bean（IoC）</li><li>在IoC容器中将有依赖关系的bean进行关系绑定（DI）</li></ul><h2 id="bean管理">bean管理</h2><h3 id="bean作用范围">bean作用范围</h3><p>bean的作用范围对应着scope属性，主要就是控制其是否为单例。</p><p>为什么bean默认为单例？</p><ul><li>IoC容器就适合管理单例的对象，这样才能有效地提高效率。</li></ul><p>适合交给容器管理的bean</p><ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul><p>不适合交给容器管理的bean</p><ul><li>封装实体的域对象、</li></ul><h3 id="bean的实例化">bean的实例化</h3><ol><li>构造方法（常用）</li></ol><p>提供可访问的构造方法</p><p>配置</p><ul><li>无参构造器如果不存在，会抛出BeanCreationException</li></ul><ol start="2"><li>静态工厂（了解）</li><li>实例工厂（了解）</li><li>使用FactoryBean实例化，其中有三个方法，用来得到Bean实例、设定Bean类型、设定是否为单例（实用）</li></ol><h3 id="bean的生命周期">bean的生命周期</h3><ul><li>bean生命周期：bean从创建到销毁的整体过程</li><li>bean生命周期控制：在bean创建后到销毁前做的一些事情</li></ul><p><strong>生命周期控制</strong></p><ul><li>配置的方式</li><li>接口控制</li></ul><p><strong>bean的生命周期</strong></p><p>初始化容器</p><ol><li>创建对象（内存分配）</li><li>执行构造方法</li><li>执行属性注入（set操作）</li><li>执行bean初始化方法</li></ol><p>使用bean</p><ol><li>执行业务操作</li></ol><p>关闭/销毁容器</p><ol><li>执行bean销毁方法</li></ol><p><strong>bean销毁</strong></p><p>容器关闭前触发bean的销毁</p><p>关闭容器方式：</p><ul><li>手动关闭容器，ConfigurableApplicationContext接口close()操作</li><li>注册关闭<strong>钩子</strong>，在虚拟机退出前先关闭容器再退出虚拟机，ConfigurableApplicationContext接口registerShutdownHook()操作</li></ul><h3 id="总结">总结</h3><p>bean相关标签属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;dao bookDaoImpl daoImpl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;com.itheima.factory.BookDaoFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>id</code>: bean的Id</li><li><code>name</code>: bean别名</li><li><code>class</code>: bean类型，静态工厂类，FactoryBean类</li><li><code>scope</code>: 控制bean的实例数量</li><li><code>init-method</code>: 生命周期初始化方法</li><li><code>destroy-method</code>: 生命周期销毁方法</li><li><code>autowire</code>: 自动装配类型，实际开发一般用注解，该属性一般不用</li><li><code>factory-method</code>: bean工厂方法，应用于静态工厂或实例工厂</li><li><code>factory-bean</code>: 实例工厂bean</li><li><code>lazy-init</code>: 控制bean延迟加载</li></ul><h2 id="依赖注入">依赖注入</h2><h3 id="手动装配">手动装配</h3><ul><li>setter注入</li></ul><p>引用类型使用ref配置</p><p>简单类型：使用property标签value属性进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>构造器注入</li></ul><p>使用constructor-arg标签ref属性注入引用类型对象</p><p>依赖注入方式选择</p><p>如果使用第三方bean，如果其同时提供了构造器注入和setter注入，使用setter注入。没有setter注入就只能使用构造器注入。自己开发推荐使用setter注入。</p><h3 id="自动装配">自动装配</h3><p>自动装配方式：</p><ol><li>按类型</li><li>按名称</li><li>构造器</li><li>不使用自动装配</li></ol><p>通过属性autowire进行自动装配的配置</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于手动注入</li></ul><h3 id="集合注入">集合注入</h3><p>数组、list、set、map、properties</p><p>格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="容器">容器</h2><h3 id="创建容器">创建容器</h3><p>方式1，使用ClassPathXmlApplicationContext</p><p>方式2，使用FileSystemXmlApplicationContext</p><h3 id="获取bean">获取bean</h3><p>方式1，按名称</p><p>方式2，按类型</p><p>方式3，按名称并按类型</p><h3 id="容器类层次结构">容器类层次结构</h3><p><img src="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/image-20250618151923608.png" alt="image-20250618151923608"></p><h3 id="总结-2">总结</h3><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口初始化类<ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h2 id="加载propertis文件">加载propertis文件</h2><h3 id="开启命名空间的方式">开启命名空间的方式</h3><p>1.开context命名空间</p><p>2.使用context空间加载propertie文件</p><p>3.使用属性占位符${}读取properties文件中的属性</p><h3 id="加载propertis文件几种方式">加载propertis文件几种方式</h3><ul><li><p>不加载系统属性</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载多个properties文件</p></li><li><p>加载所有properties文件</p></li><li><p>加载properties文件标准格式</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>从类路径或jar包中搜索并加载properties文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpathE*:*.properties&quot;</span></span></span><br></pre></td></tr></table></figure><p>前三种格式都不规范，推荐使用后两种</p><h2 id="注解开发">注解开发</h2><h3 id="注解开发定义bean">注解开发定义bean</h3><p>使用注解的形式代替原来在配置文件中写的<code>&lt;bean&gt;</code>标签。具体方法是：在相应bean的类那里使用@Component注解。</p><p>为了能让Spring容器找到这个<strong>组件</strong>，还要在配置中添加扫描标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.dao.impl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>同时@Component还有三个衍生注解@Controller、@Service、@Repository</p><h3 id="纯注解开发">纯注解开发</h3><p>Spring3.0升级了纯注解开发模式</p><p>创建一个配置类，添加@Configuration、@ComponentScan注解，就可以完全代替配置文件</p><p>相对应的，应用程序的使用也要改变，需要使用AnnotationConfigApplicationContext的实现类创建容器，其相应参数传入我们的配置类。</p><p>总之，核心思想就是通过一个类及其注解代替配置文件</p><h3 id="bean管理-2">bean管理</h3><p>bean作用范围</p><p>@Scope</p><p>bean生命周期</p><p>@PostConstruct</p><p>@PreDestroy</p><h3 id="依赖注入-2">依赖注入</h3><p><strong>引用类型</strong></p><p>自动装配@Autowired按照类型自动装配。</p><ul><li>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法</li><li>注意：自动装配建议使用无参构造方法（默认），如果不提供对应构造方法，请提供唯一的构造方法</li></ul><p>关于有多个同类型的类的情况下如何解决，在SpringBoot的依赖注入部分我已经总结过<a href="https://kuoz.top/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/">SpringBoot入门 | KuoZ’s blog</a></p><p><strong>简单类型</strong></p><p>使用@Value()进行值的注入，这样直接注入是静态的，实际上没什么意义，关键是如何动态注入。</p><p>如何动态进行注入？</p><p>方法：</p><ol><li><p>在properties配置文件中写相应的属性名及其值</p></li><li><p>在配置类中添加@PropertySource(“配置文件名”)注解</p></li><li><p>然后在基本类型的@Value注解中用${属性名}进行替换</p></li></ol><p>注意：要添加多个配置文件，要用数组的形式进行配置，@PropertySource({“配置文件名1”,“配置文件名2”,…})</p><h3 id="第三方bean管理">第三方bean管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个问题，这个bean是在配置类中写的，可能会有很多第三方bean，如果都写在SpringConfig配置类中就会很臃肿，所以要写新的配置类。接下来的问题是如何将这个新的配置类加载起来，方法是在SpringConfig配置类中使用@Import()注解，同样的，有多个配置类时，要用数组的形式写如@Import的属性。</p><p>第三方bean依赖注入</p><ul><li>引用类型：方法形参</li><li>简单类型：成员变量，使用@Value进行注入即可</li></ul><h3 id="总结-3">总结</h3><p>XML和注解配置的对比</p><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">XML配置</th><th style="text-align:left">注解</th></tr></thead><tbody><tr><td style="text-align:left">定义bean</td><td style="text-align:left"><code>&lt;bean&gt;</code>标签</td><td style="text-align:left"><code>@Component</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>id</code>属性</td><td style="text-align:left">- <code>@Controller</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>class</code>属性</td><td style="text-align:left">- <code>@Service</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <code>@Repository</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>@ComponentScan</code></td></tr><tr><td style="text-align:left">设置依赖注入</td><td style="text-align:left">setter注入（set方法）</td><td style="text-align:left"><code>@Autowired</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- 引用/简单类型</td><td style="text-align:left">- <code>@Qualifier</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">构造器注入（构造方法）</td><td style="text-align:left"><code>@Value</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- 引用/简单类型</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">自动装配</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">配置第三方bean</td><td style="text-align:left"><code>&lt;bean&gt;</code>标签</td><td style="text-align:left"><code>@Bean</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">静态工厂、实例工厂、<code>FactoryBean</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">作用范围</td><td style="text-align:left"><code>scope</code>属性</td><td style="text-align:left"><code>@Scope</code></td></tr><tr><td style="text-align:left">生命周期</td><td style="text-align:left">标准接口</td><td style="text-align:left"><code>@PostConstruct</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>init-method</code></td><td style="text-align:left"><code>@PreDestroy</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">- <code>destroy-method</code></td><td style="text-align:left"></td></tr></tbody></table><h2 id="整合">整合</h2><h3 id="Spring整合MyBatis">Spring整合MyBatis</h3><p>如何整合MyBatis？</p><ul><li>通过MyBatis的实现代码可以看出，MyBatis的核心实现类是SqlSessionFactory，所以整合的核心也是sqlSessionFactory对象</li></ul><p>简略地说，只有两个bean需要配置</p><ul><li>SqlSessionFactoryBean</li><li>MapperScannerConfigurer</li></ul><h3 id="Spring整合JUnit">Spring整合JUnit</h3><p>在pom中导入JUnit依赖和Spring整合测试依赖</p><p>在test包下创建测试类，为其添加注解</p><ul><li>@RunWith(SpringJUnit4ClassRunner.class)</li><li>@ContextConfiguration(classes = SpringConfig.class)</li></ul><h2 id="AOP">AOP</h2><p>在介绍AOP之前，我想先来介绍一下代理模式，这样可以利于理解AOP</p><h3 id="代理模式">代理模式</h3><p>动态代理</p><p>什么是动态代理？</p><p>就是一种无侵入式地修改代码、添加功能</p><p>这个功能的实现就依赖于代理对象。</p><p>什么是代理对象？</p><p>代理对象就相当于是一个中间对象，它介于目标对象和调用者之间，通过反射的方式间接调用目标对象的方法，同时还可以添加增强的功能。</p><p>下一个问题，如何创建代理对象？</p><p>jdk中为我们提供了一个类：java.lang.reflect.Proxy类，提供了为对象产生代理对象的方法：<code>newProxyInstance()</code></p><p>该方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="keyword">new</span> <span class="title class_">ProxyInstance</span>(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数1：用于指定用哪个类加载器去加载生成的代理类，一般固定</span></span><br><span class="line"><span class="comment">*参数2：指定接口，指明有哪些方法</span></span><br><span class="line"><span class="comment">*参数3：生成的代理对象要干什么事（一般是匿名实现类的匿名对象，不懂的可以去看面向对象高级里的接口）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="AOP-2">AOP</h3><ul><li><p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</p></li><li><p>作用：在不惊动原始设计的基础上为其进行功能增强</p></li></ul><p><strong>AOP的重要概念</strong></p><p>连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法</p><ul><li>在SpringAOP中，理解为方法的执行</li></ul><p>切入点（Pointcut）：匹配连接点的式子</p><ul><li><p>在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法</p><ul><li><p>一个具体方法：</p></li><li><p>匹配多个方法：</p></li></ul></li></ul><p>通知（Advice）：在切入点处执行的操作，也就是共性功能</p><ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul><p>通知类：定义通知的类</p><p>切面（Aspect）：描述通知与切入点的对应关系</p><p><strong>AOP开发</strong></p><p>比如在服务层的若干连接点，在这些方法前执行一个共性方法</p><ol><li>导入aspect依赖、spring-aop依赖（依赖于Context依赖，导入Context后会自动导入）</li><li>定义dao接口和实现类</li><li>定义通知类，为这个类添加<code>@Component、@Aspect</code>，</li><li>定义切入点，写一个私有空方法（比如<code>private void pt()&#123;&#125;</code>），在上边添加<code>@Pointcut(“execution()”)</code>绑定切入点，参数是切入点的返回类型+包名.类名.方法名</li><li>绑定切入点与通知关系，<code>@Before(“pt()”)</code></li><li>为配置类添加@EnableAspectJAutoProxy</li></ol><p><strong>AOP工作流程</strong></p><p>工作流程：</p><ol><li>Spring容器启动</li><li>读取所有切面配置的切入点（注意一定是使用了的切入点才会被读取）</li><li>初始化bean，判定bean对应的类中的方法是否匹配到了任意切入点<ul><li>匹配失败，创建对象</li><li>匹配成功，创建目标对象的代理对象</li></ul></li><li>获取bean的执行方法<ul><li>获取bean，调用方法并执行，完成操作</li><li>根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ul></li></ol><p>AOP的本质就是<strong>代理模式</strong></p><p><strong>AOP切入点表达式</strong></p><p>切入点表达式和切入点是完全不同的概念</p><p>语法格式：</p><p>没什么好讲的，大概给个标准格式吧，稍微看一点就会了</p><p><code>动作关键字(权限修饰符（可省略） 返回值类型 包名.类/接口名.方法名（形参列表）异常名)</code></p><p>通配符：</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>可以独立出现，也可以作为前缀或者后缀（如find*）（用在方法参数中一个只表示一个任意参数）</td></tr><tr><td>…</td><td>多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</td></tr><tr><td>+</td><td>专用于匹配子类类型</td></tr></tbody></table><p>下面给几个例子，来体验一下切入点表达式的书写</p><p>书写技巧：</p><ol><li>按照编程的命名规范编程，否则技巧全部无用</li><li>通常描述切入点时描述到接口而不写实现类</li><li>一般省略修饰符</li><li>对于返回值，增删改类使用精准类型加速匹配，查询类使用*通配符快速描述</li><li>包名尽量不用…匹配，效率太低，常用*作为单个包匹配，或者精准匹配</li><li>接口名采用*匹配，如：<code>*Service</code>，绑定业务层接口名</li><li>方法名动词精准匹配，名词用*，如<code>getBy*</code></li><li>参数规则较复杂，据业务方法灵活调整</li><li>不使用异常方法做匹配规则</li></ol><p>AOP通知类型</p><p>五种类型：</p><ul><li>前置通知@Before</li><li>后置通知@After</li><li><strong>环绕通知@Around</strong>（重点）</li><li>@AfterReturning（不常用）</li><li>@AfterThrowing（不常用）</li></ul><p>环绕通知的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(pt)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;切入点前执行...&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed; </span><br><span class="line">    System.out.println(<span class="string">&quot;切入点后执行...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于@Around的通知类型的注意：</p><ul><li>通知中未使用ProceedingJoinPoint对原始方法进行调用，则会跳过原始方法</li><li>对原始方法的调用可以不接收返回值，通知方法返回值类型设为void即可，如果接收，则必须设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设定为void，也可以设定成Object</li><li>由于无法预知原始方法是否会抛出异常，所以通知方法要抛出异常</li></ul><p>AOP通知获取数据</p><p>获取参数</p><p>环绕类型直接使用ProceedingJoinPoint参数获取参数</p><p>其他类型使用JoinPoint参数获取参数</p><p>获取返回值</p><p>使用returning注解属性获取返回值</p><p>获取异常</p><p>使用throwing注解属性获取返回值</p><h2 id="Spring事务属性">Spring事务属性</h2><p>Spring事务，在数据层、业务层保障一系列数据库操作同成功同失败</p><h3 id="Spring事务的添加">Spring事务的添加</h3><ol><li>在业务层接口上加@Transactional注解</li><li>在配置中添加事务管理器</li><li>开启事务控制@EnableTransactionManagement</li></ol><h3 id="Spring事务角色">Spring事务角色</h3><p>Spring事务会让数据层接口的事务加入Spring事务，从而保证一致性</p><p>有两个角色</p><p>事务管理员：发起事务方，在Spring中代指业务层开启事务的方法</p><p>事务协调员：加入事务方，在Spring中代指数据层方法也可以是业务层方法</p><h3 id="Spring事务属性-2">Spring事务属性</h3><p>事务相关配置</p><p>在@Transactionnal注解属性中可以更改readonly、timeout等属性，最重要的还是rollbackFor属性</p><p>为什么需要rollbackFor属性？</p><p>因为默认情况下只有遇到Error、运行时异常，事务才会回滚。如果想在其他异常时也同样回滚，就需要设置rollbackFor属性。</p><p>例如<code>@Transactional(rollbackFor=IOException.class)</code></p><p>日志模块</p><p>日志模块要求无论转账成功与否，都要在数据库中添加记录</p><p>这就涉及到事务的传播行为，来设定事务的处理态度</p><p>通过@Transactional注解的Propagation设定</p><p>总共有如下取值</p><table><thead><tr><th>Propagation</th><th>事务管理员</th><th>事务协调员</th></tr></thead><tbody><tr><td>REQUIRED</td><td>开启T</td><td>加入T</td></tr><tr><td></td><td>无</td><td>新建T2</td></tr><tr><td>REQUIRES_NEW</td><td>开启T</td><td>新建T2</td></tr><tr><td></td><td>无</td><td>新建T2</td></tr><tr><td>SUPPORTS</td><td>开启T</td><td>加入T</td></tr><tr><td></td><td>无</td><td>无</td></tr><tr><td>NOT_SUPPORTED</td><td>开启T</td><td>无</td></tr><tr><td></td><td>无</td><td>无</td></tr><tr><td>MANDATORY</td><td>开启T</td><td>加入T</td></tr><tr><td></td><td>无</td><td>ERROR</td></tr><tr><td>NEVER</td><td>开启T</td><td>ERROR</td></tr><tr><td></td><td>无</td><td>无</td></tr></tbody></table><p>还有一个是NESTED，设置savePoint，一旦事务回滚，事务将回滚到savaPoint，交由客户响应提交/回滚</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Spring Framework&lt;/h1&gt;
&lt;p&gt;Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门&lt;a href=</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://cv-elevation.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC之登录校验</title>
    <link href="http://cv-elevation.github.io/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/"/>
    <id>http://cv-elevation.github.io/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/</id>
    <published>2025-07-13T07:21:29.000Z</published>
    <updated>2025-07-13T10:18:47.125Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringMVC之登录校验</h1><p>登录功能的实现比较简单，只需要根据输入的用户名和密码，或者其他登录验证形式，到数据库查询是否有这条数据就可以了。</p><p>但实际上这是一个伪登录的功能。因为HTTP协议是一种无状态的协议，所以在后续的访问中无法记录登录状态。也就是<strong>登录校验</strong>功能没有实现，下边来详细讲解一下该功能的实现。</p><pre><code class="highlight mermaid">graph LR浏览器--&gt;|请求|拦截器拦截器--&gt;|响应|浏览器拦截器--&gt;login拦截器--&gt;Controller接口login--&gt;|存|登录标记登录标记--&gt;|取|拦截器</code></pre><p>上图展示了登录验证这一业务的实现流程</p><ul><li><p>实现登录标记：会话技术</p></li><li><p>实现统一拦截：过滤器(filter)、拦截器(interceptor)</p></li></ul><p>下边介绍这些技术</p><h2 id="会话技术">会话技术</h2><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要多次请求是否来自于同一浏览器，以便在同一次会话的多次请求之间能够<strong>共享数据</strong></li></ul><h3 id="Cookie">Cookie</h3><p>客户端会话跟踪技术</p><p>服务端在响应的响应头里携带Set-Cookie：name=value</p><p>之后浏览器在请求时请求头里携带Cookie：name=value</p><p>优点：</p><ul><li>HTTP协议中支持的技术，浏览器自动进行</li></ul><p><strong>缺点：</strong></p><ul><li><p>在移动端无法使用Cookie</p></li><li><p>不安全，用户可以自己禁用Cookie</p></li><li><p>Cookie不能<strong>跨域</strong></p></li></ul><h3 id="session">session</h3><p>服务器会话跟踪技术,是基于Cookie实现的</p><p><strong>缺点</strong></p><ul><li><p>服务器集群环境下无法使用session</p></li><li><p>cookie的缺点：因为底层就是用cookie实现的</p></li></ul><h3 id="令牌技术">令牌技术</h3><p>优点：</p><ul><li><p>支持PC端和移动端，因为现在不需要把令牌存储在Cookie中，其他的存储空间也是可以的</p></li><li><p>解决集群环境下的认证问题</p></li><li><p>减轻服务器端的存储压力</p></li></ul><p>后边在redis还会详细讲解其实现</p><p><strong>JWT令牌：（令牌的一种形式）</strong></p><p>JSON Web Token（<a href="https://jwt.io">https://jwt.io</a>）</p><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全传输信息。由于数字签名的存在，这些信息是可靠的。</p><p><strong>JWT令牌的组成：</strong></p><p>第一部分：Header（头），记录令牌类型、签名算法等。</p><p>第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。</p><p>第三部分：Signature（数字签名），防止Token被篡改，确保安全性。融入header、payload，并加入指定秘钥，通过指定签名算法计算而来。</p><p>介绍一下Base64编码：是一种基于64个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式。</p><p><strong>JWT校验：</strong></p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的</li><li>如果JWT令牌解析时报错，则说明JWT令牌被篡改或失效了，令牌非法</li></ul><p>JWT校验需要使用统一拦截的技术，下面将会讲解统一拦截的实现方式</p><h2 id="统一拦截">统一拦截</h2><h3 id="过滤器">过滤器</h3><p>过滤器(Filter)是JavaWeb三大组件（Filter、Servlet、Listener）之一。</p><p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊功能</p><p>过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等</p><p><strong>Filter快速入门：（并不重要）</strong></p><p>定义：实现Filter接口</p><p>配置：</p><p>在实现类上加上@WebFilter(urlPatterns=“/*”)表示拦截路径</p><p>Filter并不是SpringBoot的组件，所以需要在启动类上加上@ServletComponentScan</p><p><strong>过滤器的执行流程</strong></p> <pre><code class="highlight mermaid">graph LR浏览器--&gt;|请求|Filtersubgraph Filter1.放行前逻辑2.放行4.放行后逻辑endFilter--&gt;3.Web资源3.Web资源--&gt;Filter</code></pre><p>Filter的执行流程如图所示，按照1234的顺序执行。访问Web资源后还会回到Filter中执行放行后逻辑。</p><p><strong>过滤器链</strong></p><p>一个Web应用中可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。</p><p>优先级：注解配置的Filter，是按照过滤器的类名（字符串）自然排序执行的。</p><p><strong>登录校验Filter的业务流程：</strong></p><pre><code class="highlight mermaid">graph请求--&gt;A[获取请求路径]A--&gt;B[判断是否为登录请求]B--&gt;|是|C[放行]B--&gt;|否|D[获取请求头token]D--&gt;E[判断是否有token]E--&gt;|有|F[校验token]E--&gt;|无|GF--&gt;|校验通过|CF--&gt;|校验不通过|G[返回未登录结果]</code></pre><h3 id="拦截器">拦截器</h3><p>拦截器（Interceptor）与过滤器类似，是一种动态拦截方法调用的机制。是Spring框架提供的，用来动态拦截控制器方法的执行。</p><p><strong>拦截器的一般架构：</strong></p><p>1.定义拦截器,实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line">     <span class="comment">// 在业务处理器处理请求之前被调用，返回true表示放行，返回false表示不放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在业务处理器处理请求完成之后，生成视图之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在DispatcherServlet完全处理完请求之后被调用，可用于清理资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.注册拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径配置详解：</p><p>在配置类中，关于配置的路径：</p><p>使用<code>.addPathPatterns</code>添加需要拦截的资源，使用<code>.excludePathPatterns</code>添加不需要拦截的资源</p><p>具体拦截路径：</p><p><code>/*</code>：拦截一级路径</p><p><code>/**</code>：拦截任意级路径</p><p>拦截器的执行流程</p><pre><code class="highlight mermaid">graph LRFilter--&gt;Dispatchersubgraph SpringDispatcher--&gt;InterceptorInterceptor--&gt;控制层end</code></pre><p>Filter作为Tomcat服务器的一部分，是先于Spring框架执行的。</p><p>使用拦截器实现统一拦截：</p><p>业务逻辑与Filter完全一致</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SpringMVC之登录校验&lt;/h1&gt;
&lt;p&gt;登录功能的实现比较简单，只需要根据输入的用户名和密码，或者其他登录验证形式，到数据库查询是否有这条数据就可以了。&lt;/p&gt;
&lt;p&gt;但实际上这是一个伪登录的功能。因为HTTP协议是一种无状态的协议，所以在后续的访问中无法记录登录状</summary>
      
    
    
    
    
    <category term="会话技术" scheme="http://cv-elevation.github.io/tags/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Token" scheme="http://cv-elevation.github.io/tags/Token/"/>
    
    <category term="Filter" scheme="http://cv-elevation.github.io/tags/Filter/"/>
    
    <category term="Intercetor" scheme="http://cv-elevation.github.io/tags/Intercetor/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://cv-elevation.github.io/2025/07/04/Redis/"/>
    <id>http://cv-elevation.github.io/2025/07/04/Redis/</id>
    <published>2025-07-04T10:00:54.000Z</published>
    <updated>2025-07-06T04:05:55.468Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis基础部分</h1><h2 id="介绍">介绍</h2><p>Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p>特征：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li><strong>单线程</strong>，每个命令具备原子性</li><li>低延迟，速度快（基于<strong>内存</strong>、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="redis安装">redis安装</h2><p>关于redis，这里推荐装linux版的。</p><p>所以建议先学习安装linux和它的常用vi命令。这里做几点建议：</p><ul><li>win10及以上可以直接使用自带的wsl2来安装linux子系统，具体教程b站上有。我使用的是Ubuntu，并且没有什么问题</li><li>redis的安装和测试可以参考这个教程<a href="https://developer.aliyun.com/article/764565">如何在 Ubuntu 20.04 上安装和配置 Redis-阿里云开发者社区</a></li></ul><h2 id="redis常用的命令">redis常用的命令</h2><p>命令不用死记，建议去redis官网查询命令</p><p>又或者，你也可以在命令行中使用help [command]来查询,例如：</p><p><img src="/2025/07/04/Redis/image-20250703191308454.png" alt="image-20250703191308454"></p><p>下边总结常用的命令</p><ul><li><p>KEYS：查看符合模版的所有key，<strong>不建议在生产环境设备上使用</strong>，因为效率过低</p></li><li><p>DEL：删除一个指定的key</p></li><li><p>EXISTS：判断key是否存在</p></li><li><p>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p>TTL：查看一个key的剩余有效期</p></li></ul><h3 id="String类型">String类型</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：string、int、float</p><p>String的常见命令</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的value</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY：让一个整型的key自增并指定步长</li><li>INCRYBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并指定有效值</li></ul><p>Key的层级格式：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用‘:’隔开，这样就会形成层级结构。</p><h3 id="Hash类型">Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/2025/07/04/Redis/image-20250703211510016.png" alt="image-20250703211510016"></p><p>Hash的常见命令：</p><ul><li>HSET key field value：添加或修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field值</li><li>HMSET：批量添加多个hash类型key的field值</li><li>HMGET：获取获取多个hash类型key的field值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有field</li><li>HVALS：获取一个hash类型的key中的所有value</li><li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="List类型">List类型</h3><p>Redis中的List类型与Java中的LinkedList基本一致</p><p>List的常见命令：</p><ul><li>LPUSH key element…：想列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element…：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key start end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p>如何利用List结构模拟一个栈?</p><ul><li>入口和出口在同一边</li></ul><p>如何利用List结构模拟一个队列？</p><ul><li>入口和出口在不同边</li></ul><p>如何利用List结构模拟一个阻塞队列？</p><ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul><h3 id="Set类型">Set类型</h3><p>Redis的Set结构和Java中的HashSet类似，可以看做是一个value为null的HashMap。</p><p>Set的常见指令：</p><ul><li>SADD key member …：向Set中添加一个或多个元素</li><li>SREM key member …：移除set中的指定元素</li><li>SCARD key：返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2…：求key1与key2的交集</li><li>SDIFF key1 key2…：求key1与key2的差集</li><li>SUNION key1 key2…：求key1与key2的并集</li></ul><h3 id="SortedSet类型">SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member：获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><h2 id="Redis的Java客户端">Redis的Java客户端</h2><h3 id="Jedis">Jedis</h3><p>简单好上手，直接使用redis命令作为方法名。</p><p>使用Jedis的流程</p><ol><li>引入依赖</li><li>创建Jedis依赖，建立连接</li></ol><h3 id="SpringDataRedis">SpringDataRedis</h3><p>使用步骤：</p><ol><li>引入SpringDataRedis的依赖</li><li>在配置文件中配置redis信息</li><li>注入RedisTemplate依赖</li></ol><p>序列化</p><p>默认为jdk序列化方式，这不好</p><p>自动序列化：</p><p>定义RedisTemplate</p><p>key使用String序列化</p><p>value使用json序列化</p><blockquote><p>这里插入一个debug记录：在添加对象的时候，我遇到了一个离谱的问题，那就是lombok使用不了的问题。也在这里记录一下：</p></blockquote><p>问题描述：</p><p><img src="/2025/07/04/Redis/image-20250704165357899.png" alt="image-20250704165357899"></p><p>在传对象的时候，使用全参构造器新创建一个对象，然后作为value进行传输，报了如上的错误。</p><p>经过分析问题应该是lombok注解添加的全参构造器没有生效。然后去问了ai这个问题，给了一些常见的原因，经过排查都没能解决。</p><p>最后我去对比了之前的工程，对比之后发现可能是SpringBoot版本的问题。</p><p>因为在前边写配置文件的时候，课程相对比较老，老师用的是SpringBoot2版本，为了一致，我就也改成了SpringBoot2版本。</p><p>我将SpringBoot改成了3.4.6版本，lombok版本是1.18.38。然后又配置了配置文件，这里注意配置redis之前的层级要加上data。之后就能正常增加数据了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><p>问题总结：</p><p>这个问题真的让人很难排查，因为idea认为我们的编写是没有问题的，编译时不会报错误，但是一运行就挂。总之在看这些相对老点的课程一定要优先关注版本问题。</p><p>手动序列化：</p><p>ObjectMapper手动序列化：</p><p>直接使用Spring提供的<code>StringRedisTemplate</code>类，这个提供了key和value都直接用String序列化的方法。</p><p>字符串类型可以直接使用set、get来存储和读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stringTest</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于对象需要手动序列化：</p><p>使用ObjectMapper来进行手动序列化为JSON，并手动反序列化读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;miku&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>,json);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> objectMapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis存储的数据：</p><p><img src="/2025/07/04/Redis/image-20250704175717830.png" alt="image-20250704175717830"></p><p>客户端读取到的数据：</p><p><img src="/2025/07/04/Redis/image-20250704175736214.png" alt="image-20250704175736214"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Redis基础部分&lt;/h1&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。&lt;/p&gt;
&lt;p&gt;特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键值（</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://cv-elevation.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis入门</title>
    <link href="http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/"/>
    <id>http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/</id>
    <published>2025-06-08T12:02:16.000Z</published>
    <updated>2025-07-01T09:29:27.924Z</updated>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>2025-06-28 修改了部分错误，优化了文档结构</li><li>2025-07-01 修复了代码块sql语句无法高亮的问题</li></ul><h1>Mybatis入门</h1><img src="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/Mybatis.jpg" width="40%"><h2 id="0-序">0.序</h2><p>Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;<a href="https://www.bilibili.com/video/BV1m84y1w7Tb?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=117">Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili</a>。</p><h2 id="1-入门">1.入门</h2><p><strong>快速入门</strong></p><p>开启一个模版程序，实现使用Mybatis查询所有用户数据</p><ol><li>准备工作（创建springboot文件，定义实际类User，数据库表user）</li><li>添加mybatis相关依赖，配置mybatis（数据库连接信息）</li><li>编写SQL语句（注解/XML）</li></ol><p>具体操作流程如下：</p><ul><li><p>创建springboot文件：与springboot入门中的创建方法基本一致，注意要勾选Mybatis Framework和MySQL Driver依赖。</p></li><li><p>定义实际类：实际类要与数据库中user的字段保证一致，常见的几种类型对应：int-&gt;Integer，varchar-&gt;String，tinyint-&gt;Short，主要使用其包装类。同时声明相应的getset方法、构造器、toString方法。</p></li><li><p>在properties配置文件中加入以下内容，格式比较固定，url要根据相应的数据库名称确定，密码设定为自己的密码</p></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><ul><li>编写SQL语句（注解/XML）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//在运行时，MyBatis会扫描这个接口，并为其生成一个实现类对象（代理对象），并交给IOC管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//springboot整合单元测试的注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后的文件结构如图</p><img src="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/module.png" width="50%"><p><strong>配置SQL提示</strong></p><p>在上边的SQL语句中，如果没有配置，那么就不会显示相应的提示，即使写错了也不会提醒，这对于开发是非常不利的。好在Idea中可以为其配置MySQL数据库连接。</p><ul><li>选中SQL语句，右键，配置为MySQL语句</li><li>点击右侧边栏的数据库选项，点击加号，数据源选择MySQL，填写host、port、用户和密码、数据库</li></ul><p><strong>数据库连接池</strong></p><ul><li>数据库连接池是个容器，负责分配、管理数据库连接</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>能够释放空闲时间超过最大空闲时间的连接，避免因为没有释放连接引起的数据库连接遗漏</li><li>好处：资源重用 提升系统响应速度 避免数据库连接遗漏</li></ul><p>标准接口：DataSource</p><ul><li>官方提供的数据库连接池接口，由第三方组织实现此接口</li><li>功能：获取连接</li></ul><p>常见产品：C3P0、DBCP、Druid、Hikari</p><p><strong>lombok</strong></p><p>在入门-快速入门的实际类编写中我们自己手动构造了getset、toString等方法，较为繁琐。改进方法就是使用lombok。lombok是一个实用Java类库，能通过注解的形式自动生成getset方法、构造器、toString等方法，并可以自动化生成日志日志变量，简化Java开发、提高效率。</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter、@Setter</td><td>提供getset方法</td></tr><tr><td>@ToString</td><td>提供tostring方法</td></tr><tr><td>@EqualsAndHashCode</td><td>重写equals和hashCode方法</td></tr><tr><td>@Data</td><td>上边三个的整合</td></tr><tr><td>@NoArgsConstructor</td><td>无参构造器</td></tr><tr><td>@AllArgsConstructor</td><td>含参构造器</td></tr></tbody></table><p>直接添加注解是会报错的，还需要导入lombok的依赖，可以写注解然后根据IDEA自动导入依赖。</p><h2 id="2-CRUD操作">2.CRUD操作</h2><p>CRUD操作是mybatis使用的核心，这一部分以实操为主</p><p>首先进行工程的<strong>准备工作</strong>，和入门的工程基本一致。</p><p>关于实体类的创建的注意点：</p><ul><li>注意在数据库表结构中字段名是使用下划线分隔的，但是在实体类中我们采用驼峰命名</li></ul><h3 id="在mybatis中实现删除操作">在mybatis中实现删除操作</h3><p>根据主键删除</p><p>在Mapper接口中编写如下方法和语句，#{…}是占位符，用于将方法的参数提取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id =#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><h3 id="日志输出">日志输出</h3><p>在配置文件中添加</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis的日志，指定输出到控制台</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>再次运行程序，控制台中日志的输出如下</p><p><code>==&gt;  Preparing: delete from user where id =? ==&gt; Parameters: 9(Integer) &lt;==    Updates: 1</code></p><p>可以看到输出的SQL语句带有“？”，这个就被称为<strong>预编译SQL</strong>。</p><p>它有两大优势：</p><ul><li>性能更高</li><li>更安全（防止SQL注入）</li></ul><p><strong>为什么性能更高？</strong></p><p>需要从SQL语句具体的执行过程来分析</p><p>SQL语句执行</p><pre><code class="highlight mermaid">graph LR    A[Java] ==&gt; B(SQL语法解析检查)        subgraph SQL处理流程[缓存]        B ==&gt; C(优化SQL)        C ==&gt; D(编译SQL)    end        D ==&gt; E(执行SQL)</code></pre><p>对比两种方式</p><p>第一种</p><p><code>delete from user where id =1</code></p><p><code>delete from user where id =2</code></p><p><code>delete from user where id =3</code></p><p>第二种</p><p><code>delete from user where id = ?</code></p><p><code>1</code></p><p><code>2</code></p><p><code>3</code></p><p>这两种性能的差别就是因为这个缓存的过程，在Java发送SQL语句之后，会先经过检查、优化、编译，然后被缓存起来，之后再发送的时候会先检查缓存种是否有这个SQL语句，如果有就直接执行了。</p><p>第一种的话由于三条SQL语句每条都不相同，所以需要编译三次，而第二种的话由于是预编译的形式，所以只用编译一次，后边三条SQL语句就可以直接执行。</p><p>由此我产生一个问题，使用多态性是否也同样能提高Java的效率？</p><p><strong>为什么更安全？</strong></p><p>这里主要是与另一种占位符作对比</p><p>#{…}</p><ul><li><p>执行SQL时，会将#{…}替换为？，生成预编译SQL，会自动设置参数值</p></li><li><p>使用时机：参数传递，都使用#{…}</p></li></ul><p>${…}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：很少使用，如果对表名、列表进行动态设置时使用</li></ul><p>SQL注入：通过操作输入的数据来修改实现定义好的SQL语句，以达到执行代码对服务器进行攻击的方法</p><p>举个栗子🌰</p><p>账户的登录操作其实就是查询数据库中用户表的相应username和password是否都存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;miku&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果count(*)&gt;=1，那么我们就认为密码正确，就可以放行了。</p><p><strong>若使用的是${…}</strong></p><p>那么就是直接拼接的形式，如果传入的是这样的(“miku”,”‘ ’ or ‘1’=‘1”)</p><p>SQL语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;miku&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样就是一个恒成立的条件，那么也会直接放行。</p><p>这里只是举个例子，实际上现在是个网站都会防SQL注入，渗透也没有这么简单。</p><p><strong>若使用的是#{…}</strong></p><p>那么就会直接传递给？，就会直接拿传递的参数去数据库查询，不会更改SQL的基本逻辑。</p><h3 id="在mybatis中实现新增操作">在mybatis中实现新增操作</h3><p><strong>基本插入</strong></p><p>最简单的插入，不含占位符，无参数传递， <s>也最没有用</s></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(user.username, user.name, user.gender, user.age) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;values(&#x27;test&#x27;,&#x27;测试插入SQL&#x27;,1, 18)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>使用占位符传递，注意与实用类的属性名保持一致，使用小驼峰命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(id,user.username, user.name, user.gender, user.age) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;values(#&#123;id&#125;,#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><p><strong>获取主键</strong></p><p>在@Insert注解上添加注解@Options(keyProperty = “id”,useGeneratedKeys = true)会自动将生成的主键值，赋值给emp对象的id属性</p><h3 id="在mybatis中实现更新操作">在mybatis中实现更新操作</h3><p>很简单，会SQL语句就会更新操作</p><p>直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update user set username=#&#123;username&#125;&quot;+</span></span><br><span class="line"><span class="meta">&quot;, name=#&#123;name&#125;,gender=#&#123;gender&#125;, age=#&#123;age&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><h3 id="在mybatis中实现查询操作">在mybatis中实现查询操作</h3><p><strong>根据Id查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p>代码比较简单，就是设置一个传参的SQL语句就可以了</p><p>但是有一个问题，比如日期update_time这些MySQL和Java命名规范不一样的字段，是不会进行自动封装的，也就是说直接查是查不到的。相应有三种解决方案：</p><ul><li>配置自动映射</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>这是最简单也是最推荐的一种方案，只要保证符合命名规范，就能够自动封装</p><ul><li>使用别名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select update_time updateTime from user where id = #&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure><ul><li>使用@Results注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;updateTime&quot;, column = &quot;update_time&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;entryDate&quot;, column = &quot;entry_date&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure><p>后两种都比较繁琐，很少用</p><p><strong>条件查询</strong></p><p>考虑下面一个需求：</p><p>查询员工，根据员工的姓名、性别、入职时间搜索满足条件的员工信息。要求：员工姓名支持模糊匹配，性别精确匹配，入职时间进行范围查询。对查询的结果根据最后修改时间进行倒序排序。</p><p>编写出的SQL语句应该是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> entry_date <span class="keyword">between</span> </span><br><span class="line"><span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>用Mybatis实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and entry_date between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name ,Short gender,LocalDate begin,LocalDate end)</span>; </span><br></pre></td></tr></table></figure><p>注意，在这里使用了concat (‘%’,#{name},‘%’)函数，这是因为如果直接替换为‘%#{name}%’，是不合法的，因为?占位符不能出现在引号内，只能使用${…}，可是这样就会有性能低、安全性低的问题。那么就使用了SQL的函数concat，它用于将多个字符串拼接起来，这样就解决了问题。</p><p><strong>参数名说明</strong></p><p>在SpringBoot1.X版本，参数名前必须要加上@Param(“字段名”)，才能进行传递，这是因为在这个版本是不会把形参名保留下来，所以就必须要加上注解。</p><h2 id="3-XML映射文件">3.XML映射文件</h2><p>定义规范</p><ul><li>XML的文件名称与Mapper接口的名称一致，并且放置在相同包下（同包同名）</li><li>XML的namespace属性与Mapper接口的全限定名一致</li><li>XML中SQL语句的id与Mapper接口中的方法名一致，有返回值的要写resultType属性，这个是单条记录所封装的类型（也就是说如List结构，要写他的单挑记录的数据类型）</li></ul><h2 id="4-动态SQL">4.动态SQL</h2><p>学习动态SQL就是要学习其响应的标签</p><p>1.<if></if></p><ul><li>用判断条件是否成立，如果条件为true，则拼接SQL</li><li>形式：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.<where></where></p><ul><li>where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句开头的and或or</li></ul><p>3.<set></set></p><ul><li>动态地在行首插入set关键字，并会删除额外的逗号。（用在update语句中）</li></ul><p>4.<foreach></foreach></p><ul><li>SQL语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure><ul><li>接口方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBytes</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure><ul><li>XML映射文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBytes&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签属性说明：</p><p>collection：集合名称</p><p>item：集合遍历出来的元素/项，与下边占位符名称一致</p><p>separator：每一次遍历使用的分隔符</p><p>open：遍历开始前拼接的片段</p><p>close：遍历结束后拼接的片段</p><p>5.<sql> <include></include></sql></p><p>为提高复用性，可以将sql用<sql>标签记录，并使用<include>标签调用</include></sql></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--纪录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line">    select id,username,name,gender,age from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改历史：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2025-06-28 修改了部分错误，优化了文档结构&lt;/li&gt;
&lt;li&gt;2025-07-01 修复了代码块sql语句无法高亮的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Mybatis入门&lt;/h1&gt;
&lt;img src=&quot;/2025/06/08/</summary>
      
    
    
    
    
    <category term="Mybatis" scheme="http://cv-elevation.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="http://cv-elevation.github.io/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>http://cv-elevation.github.io/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/</id>
    <published>2025-06-03T14:30:09.000Z</published>
    <updated>2025-06-28T10:03:04.470Z</updated>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>增加了Web入门的基础知识，完善了结构</li></ul><h1>SpringBoot入门</h1><h2 id="0-概述">0.概述</h2><p>本篇只是对springboot的基本使用的总结，学习视频-&gt;<a href="https://www.bilibili.com/video/BV1m84y1w7Tb?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=67">Day05-01. 请求响应-概述_哔哩哔哩_bilibili</a>，使用postman进行调试。</p><h2 id="1-Web入门">1.Web入门</h2><h3 id="HTTP协议">HTTP协议</h3><p><strong>概述</strong></p><p>HTTP协议（HyperTextTransferProtocol），超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><p>特点：</p><ol><li>TCP协议：面向连接，安全</li><li>基于请求-响应模型：一次请求对应一次响应</li><li>HTTP是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的<ul><li>缺点：多次请求无法共享数据</li><li>优点：速度快</li></ul></li></ol><p><strong>请求协议</strong></p><p>请求数据包括三个部分：</p><p>请求行：请求数据第一行（请求方式，资源路径、协议）</p><p>请求头：第二行开始，格式key: value</p><p>请求体：POST请求，存放请求参数</p><p>两种请求方式对比：</p><ul><li><p>请求方式-get：请求参数在请求行中，没有请求体。get请求大小是有限制的。</p></li><li><p>请求方式-post：请求参数在请求体中，post请求大小是没有限制的。</p></li></ul><p><strong>响应协议</strong></p><p>响应数据包括三部分：</p><ul><li><p>响应行：相应数据第一行（协议、状态码、描述）</p></li><li><p>响应头：key: value</p></li><li><p>响应体：存放响应数据</p></li></ul><p>常见状态码：</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">响应中</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">客户端错误-处理发生错误，责任在客户端。如请求了不存在的资源、客户端未被授权、禁止访问</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">服务器错误-处理发生错误，责任在服务端。如程序抛出异常</td></tr></tbody></table><p>目前主要了解：200 处理成功，404 请求资源不存在，500 服务器端异常</p><p>更多状态码见网站：</p><p><a href="https://cloud.tencent.com/developer/chapter/13553">状态 | Status - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云</a></p><p><strong>协议解析</strong></p><p>服务器端要做的事情，一方面是要根据请求协议，解析浏览器发送的请求；另一方面是要根据响应协议，发送响应数据。</p><p>这种解析的工作较为固定，有不少<strong>Web服务器</strong>已经完成了这些工作，这样后端就只用关注业务逻辑的实现。常见的Web服务器有：Tomcat、IBM、jetty、WebLogic等</p><h3 id="Tomcat服务器">Tomcat服务器</h3><p>具体内容暂时不用详细了解，SpringBoot已经内嵌了Tomcat服务器，所以不用专门下载。介绍在此省略</p><h2 id="2-请求">2.请求</h2><p>此处请求的含义：后端接收来自浏览器端的请求指令，进行解析</p><h3 id="简单参数">简单参数</h3><p>请求：</p><p>GET指令：<code>http://localhost:8080/simpleParam?name=miku&amp;age=16</code></p><p>POST指令：<code>http://localhost:8080/simpleParam</code>请求体：<code>name=Miku&amp;age=16</code></p><p>Java代码：</p><p>原始方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在原始的Web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);<span class="comment">//需要与请求参数的key保持一致</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);<span class="comment">//需要与请求参数的key保持一致</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);</span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//繁琐，并且需要进行手动类型转换</span></span><br></pre></td></tr></table></figure><p>SpringBoot方式：</p><p>简单参数，参数名与<strong>形参列表名</strong>相同，定义形参即可接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(<span class="type">int</span> age,String name)</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;:&quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果形参名和请求参数名不一致，可以使用@RequestParam进行映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(<span class="type">int</span> age,<span class="meta">@RequestParam(name=&quot;name&quot;,required = true)</span> String username)</span> &#123;</span><br><span class="line">    System.out.println(username + <span class="string">&quot;:&quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解@RequestParam中有两个属性，一个是重定向，一个是required属性，第二个参数如果不写默认为true，即参数是必须的，如果缺少该参数会报400的状态码，表明客户端请求错误。</p><h3 id="实体参数">实体参数</h3><p>简单实体对象，请求参数名与形参对象属性名相同，定义POJO接收即可</p><p>请求：<code>http://localhost:8080/simplePojo?name=miku&amp;age=16</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simplePojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要创建User对象，声明相应属性、getset方法、toString方法</p><p>复杂实体对象，请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><p>请求：<code>http://localhost:8080/complexPojoname=miku&amp;age=16&amp;address.city=Tokyo&amp;address.country=Japan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/complexPojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(User1 user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组参数">数组参数</h3><p>请求参数名与形参数组名相同且请求参数为多个，定义数组类型形参即可接收参数</p><p>请求：<code>http://localhost:8080/arrayParam?friend=Miku&amp;friend=Kurumi&amp;friend=Marin</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(String[] friend)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String f : friend) &#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合参数">集合参数</h3><p>请求参数名与形参集合名称相同且请求参数为多个，@RequestParam绑定参数关系</p><p>请求：<code>http://localhost:8080/arrayParam?friend=Miku&amp;friend=Kurumi&amp;friend=Marin</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleRequest</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; friend)</span> &#123;</span><br><span class="line">    Iterator&lt;String&gt; iterator = friend.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日期参数">日期参数</h3><p>使用@DateTimeFormat注解完成日期参数格式转换</p><p>请求：<code>http://localhost:8080/dateParam?updateTime=2025-06-03 17:47:55</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateRequest</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Update Time: &quot;</span> + updateTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="json参数">json参数</h3><p>json参数根据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用@RequestBodt标识</p><p>请求：</p><p>请求行<code>http://localhost:8080/jsonParam</code></p><p>请求体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Miku&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span><span class="string">&quot;Japan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jsonParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonRequest</span><span class="params">(<span class="meta">@RequestBody</span> User1 user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User: &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径参数">路径参数</h3><p>通过请求URL直接传递该参数，使用{…}来表示该路径参数，需要使用@PathVariable获取路径参数</p><p>请求：<code>http://localhost:8080/path/1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ID: &quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取多个路径参数：</p><p>请求：<code>http://localhost:8080/path/1/Miku</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,<span class="meta">@PathVariable</span> String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-响应">3.响应</h2><p>@Response注解</p><p>位置：Controller类上或者方法上</p><p>作用：将方法返回值直接响应，若返回值是实体对象/集合，转为JSON格式响应</p><p>统一响应结果：</p><p>Result(code、msg、data)</p><h2 id="4-分层解耦">4.分层解耦</h2><h3 id="三层架构">三层架构</h3><p>三层架构包括控制层（Controller）、业务逻辑层（Service）、数据访问层（Dao）</p><pre><code class="highlight mermaid">graph LR浏览器==&gt;ControllerController==&gt;ServiceService==&gt;Dao</code></pre><ul><li><p>Controller：控制层，接收前端发送的请求，（对请求进行处理），进行响应</p></li><li><p>Service：业务逻辑层，处理具体的业务逻辑</p></li><li><p>Dao：数据访问层（持久层），负责数据的访问操作</p></li></ul><p>介绍完三层架构之后，那么就该谈到它的实现了，如果说只是用程序进行控制，那么就很容易会产生耦合，使得代码的拓展性大大降低。好在Spring给我们提供了IOC，我们可以通过Spring容器来对 <em>Bean对象</em> 进行控制，这样不同层的代码就相互独立起来。</p><h3 id="IOC（控制反转）">IOC（控制反转）</h3><p>涉及到四个注解：</p><p>@Component、@Controller、@Service、@Repository</p><p>后边三个都是@Component的衍生注解，实际功能与@Component类似，但是推荐使用后三个，当某一个部分不属于后三个中的任何一个的时候再使用@Component。</p><ul><li>声明bean的时候，可以使用value属性指定bean的名字，如果没用，则默认为类名的首字母小写形式</li><li>不只是建议：在使用springboot集成的web开发中，声明控制器bean只能用@Controller</li></ul><p>Bean组件扫描</p><p>上边的四大注解要想生效，还必须经过Bean组件扫描，使用的是@ComponentScan注解，该注解在启动类的声明注解中已经包含，默认范围是启动类所在包及其子包。可以通过在启动类的注解中加上重写的@ComponentScan来更改扫描路径，但是不推荐更改。</p><h3 id="DI（依赖注入）">DI（依赖注入）</h3><p>Spring中，依赖注入是通过@Autowired注解完成的，最简单的的情况下，就在Controller声明Service对象处或者Service声明Dao对象处加上@Autowired注解，就会根据<strong>类型自动匹配</strong>。</p><p>那么如果有多个业务逻辑呢？（以业务逻辑为例）</p><p>如果不进行处理，就会存在多个业务逻辑可供选择，直接就会报错。</p><p>有三个注解可以用来解决这个问题</p><ul><li>@Primary：见名知意，就是给不同的Service提供一个优先级，那么就会优先注入Primary的依赖</li><li>@Qualified：通过在@Autowired的地方加这个注解，通过其value属性指定相应的Service</li><li>@Resource：不使用@Autowired注解，使用名字进行注入，使用<code>@Resource(name = &quot;empServiceA&quot;)</code>进行注入，因为是根据名字进行注入的，也就不存在冲突</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改历史：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加了Web入门的基础知识，完善了结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;SpringBoot入门&lt;/h1&gt;
&lt;h2 id=&quot;0-概述&quot;&gt;0.概述&lt;/h2&gt;
&lt;p&gt;本篇只是对springboot的基本使用的总结，学习视频-&amp;gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://cv-elevation.github.io/tags/SpringBoot/"/>
    
    <category term="三层架构" scheme="http://cv-elevation.github.io/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="http://cv-elevation.github.io/2025/05/25/Maven/"/>
    <id>http://cv-elevation.github.io/2025/05/25/Maven/</id>
    <published>2025-05-25T12:43:27.000Z</published>
    <updated>2025-06-02T12:52:30.520Z</updated>
    
    <content type="html"><![CDATA[<h1>Maven</h1><h2 id="概述">概述</h2><p>Maven是一款管理和构建Java项目的工具。基于POM（项目对象模型）的概念，通过一小段描述来管理项目</p><p><strong>Maven坐标</strong>，唯一标识和定位一个项目</p><p>groupId：组织</p><p>artifactId：模块名称</p><p>version：版本</p><p><strong>仓库</strong>：用于存储资源，管理jar包</p><p>本地仓库：自己计算机上的一个目录</p><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><p>远程仓库：一般由公司团队搭建的私有仓库</p><p>使用顺序：本地仓库&gt;远程仓库&gt;中央仓库</p><h2 id="依赖管理">依赖管理</h2><p>依赖：指当前项目运行所需的jar包</p><h3 id="配置依赖（在IDEA中）">配置依赖（在IDEA中）</h3><ol><li>在pom.xml中编写<dependencyies>标签</dependencyies></li><li>在<dependencyies>标签中使用<dependency>引入坐标</dependency></dependencyies></li><li>定义坐标的groupId，artifactId，version</li><li>点击刷新按钮，引入最新加入的坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递">依赖传递</h3><p>依赖具有传递性</p><ul><li><p>直接依赖：在当前项目中通过依赖配置建立的关系</p></li><li><p>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p></li><li><p>排除依赖：主动断开依赖的资源，被排除的资源无需指定版本</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="依赖范围">依赖范围</h3><table><thead><tr><th style="text-align:center">scope值</th><th style="text-align:center">主程序</th><th style="text-align:center">测试程序</th><th style="text-align:center">打包（运行）</th><th style="text-align:center">范例</th></tr></thead><tbody><tr><td style="text-align:center">compile(默认)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">log4j</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">junit</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">servlet-api</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">jdbc驱动</td></tr></tbody></table><p>可以通过下面的xml标签来设置依赖范围</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期">生命周期</h3><p>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。（运行后面的阶段，前面的阶段也会运行）</p><p>生命周期阶段（常见）</p><table><thead><tr><th>常见生命周期阶段</th><th></th></tr></thead><tbody><tr><td>clean</td><td>移除上一次构建生成的文件</td></tr><tr><td>compile</td><td>编译项目源代码</td></tr><tr><td>test</td><td>使用合适的单元测试框架运行测试</td></tr><tr><td>package</td><td>将编译后的文件打包，如：jar、war等</td></tr><tr><td>install</td><td>安装项目到本地仓库</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Maven&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;Maven是一款管理和构建Java项目的工具。基于POM（项目对象模型）的概念，通过一小段描述来管理项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maven坐标&lt;/strong&gt;，唯一标识和定位一个项目&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Maven" scheme="http://cv-elevation.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://cv-elevation.github.io/2025/05/24/MySQL/"/>
    <id>http://cv-elevation.github.io/2025/05/24/MySQL/</id>
    <published>2025-05-24T13:58:00.000Z</published>
    <updated>2025-07-03T08:55:10.651Z</updated>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>2025-07-01 修复了sql语句的代码快无法高亮的问题</li></ul><h1>MySQL-基础</h1><p>数据库管理系统DBMS</p><p>MySQL数据模型</p><p>客户端-&gt;DBMS-&gt;多个数据库-&gt;多个二维表</p><h2 id="SQL语句">SQL语句</h2><p>DDL(Data Definition Language)数据定义语言（数据库、表、字段）</p><p>DML(Data Manipulation Language)数据操作语言</p><p>DQL(Data Query Language)数据查询语言</p><p>DCL(Data Control Language)数据控制语言，管理数据库用户，控制数据库的访问权限</p><h3 id="DDL-数据定义">DDL-数据定义</h3><p><strong>数据库操作</strong></p><table><thead><tr><th style="text-align:center">大类</th><th style="text-align:center">语句</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">查询</td><td style="text-align:center">show databases</td><td style="text-align:center">查询所有数据库</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select database()</td><td style="text-align:center">查询当前数据库</td></tr><tr><td style="text-align:center">创建</td><td style="text-align:center">create database [if not exists] 数据库名</td><td style="text-align:center">（如果不存在）创建一个数据库</td></tr><tr><td style="text-align:center">使用</td><td style="text-align:center">use 数据库名;</td><td style="text-align:center">使用数据库</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">drop database [if exists] 数据库名</td><td style="text-align:center">删除数据库</td></tr></tbody></table><p><strong>表操作-查询</strong></p><table><thead><tr><th>语句</th><th>作用</th></tr></thead><tbody><tr><td>show tables;</td><td>查询当前数据库所有表</td></tr><tr><td>desc 表名;</td><td>查询表结构</td></tr><tr><td>show create table 表名;</td><td>查询指定表的建表语句</td></tr></tbody></table><p><strong>表操作-创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">    ……</span><br><span class="line">    字段n 字段类型 [约束] [comment 字段<span class="number">1</span>注释]</span><br><span class="line">)[comment 表注释];</span><br></pre></td></tr></table></figure><p>关于约束：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段所有数据唯一</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>字段未指定值则用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接</td><td>foreign key</td></tr></tbody></table><p>字段数据类型</p><p>数值</p><table><thead><tr><th>类型</th><th>大小（byte）</th><th>描述</th></tr></thead><tbody><tr><td>tinyint</td><td>1</td><td>小整数值</td></tr><tr><td>smallint</td><td>2</td><td>大整数值</td></tr><tr><td>mediumint</td><td>3</td><td>大整数值</td></tr><tr><td>int</td><td>4</td><td>大整数值</td></tr><tr><td>bigint</td><td>8</td><td>极大整数值</td></tr><tr><td>float</td><td>4</td><td>单精度浮点数</td></tr><tr><td>double</td><td>8</td><td>双精度浮点数</td></tr><tr><td>decimal</td><td></td><td>小数值（精确定点数)</td></tr></tbody></table><p>例如double,需使用double(整个数的长度，小数部分长度)</p><p>字符串</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>定长字符串</td></tr><tr><td>varchar</td><td>变长字符串</td></tr><tr><td>tinyblob</td><td>不超过255个字符的二进制数据</td></tr><tr><td>tinytext</td><td>短文本字符串</td></tr><tr><td>blob</td><td>二进制形式的长文本数据</td></tr><tr><td>text</td><td>长文本数据</td></tr><tr><td>midiumblob</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>midiumtext</td><td>中等长度文本数据</td></tr><tr><td>longblob</td><td>二进制形式的极大文本数据</td></tr><tr><td>longtext</td><td>极大文本数据</td></tr></tbody></table><p>日期时间</p><table><thead><tr><th></th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>1000-01-01至9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>time</td><td>3</td><td>-838:59:59至838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>year</td><td>1</td><td>1901至2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>datatime</td><td>8</td><td>1000-01-01 00:00:00至9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>timestamp</td><td>4</td><td>1970-01-01 00:00:01至2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p>修改、删除表结构</p><p>语言可以不掌握，但是要会图形化操作</p><h3 id="DML-数据操作">DML-数据操作</h3><p>添加数据：</p><p>insert into 表名(字段1，字段2，……) values(值1,值2,……);</p><ul><li>字符串应该和日期型数据应该包含在引号内</li><li>插入的数据大小，应该在字段的规定范围内</li></ul><p>修改数据</p><p>update 表名 set 字段名1=值1,字段名2=值2,…[where 条件]</p><p>删除数据</p><p>delete from 表名 [where 条件]</p><h3 id="DQL-数据查询">DQL-数据查询</h3><p><strong>基本查询：</strong></p><p>基本查询<br>select 字段列表 from 表名;<br>select * from 表名;（不建议在开发中使用这种方式，因为不直观）</p><p>起别名<br>select 字段 as ‘别名’ from 表名;as可省略</p><p>去重<br>select distinct 字段名称 from 表名;</p><p><strong>条件查询：</strong></p><p>select 字段列表 from 表名 where 条件列表;</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt; &gt;= &lt; &lt;= = !=或&lt;&gt;</td><td>比较</td></tr><tr><td>between…and …</td><td>在某个范围之内（含最小值、最大值）</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配（_ 匹配单个字符，%匹配任意个字符）</td></tr><tr><td>is  null</td><td>是null</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>and或&amp;&amp;</td><td>并且</td></tr><tr><td>or或||</td><td>或</td></tr><tr><td>not或！</td><td>非</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;初音未来&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">&gt;</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">NOT null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">!=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">&gt;=</span><span class="number">2</span> <span class="operator">&amp;&amp;</span> job<span class="operator">&lt;=</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">&gt;=</span><span class="number">2</span> <span class="keyword">and</span> job<span class="operator">&lt;=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">in</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;____&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%三&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>聚合函数：</strong></p><p>select 聚合函数(字段列表) from 表名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="comment">-- 统计数量</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(image) <span class="keyword">from</span> emp;<span class="comment">-- null值不参与运算</span></span><br><span class="line"><span class="comment">-- 统计平均值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 统计最大值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 统计最小值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 统计和</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(age) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>分组查询：</strong></p><p>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</p><p>where与having区别</p><ul><li>执行时间不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤；</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>执行顺序：where &gt; 聚合函数 &gt; having</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他的字段毫无意义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据性别分组，统计男性员工和女性员工的数量</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 根据性别分组，统计男性员工和女性员工的平均年龄</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">avg</span>(age) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 查询年龄小于15的员工，并根据性别进行分组，获取员工数量大于等于2的性别(对聚合函数判断，要用having)</span></span><br><span class="line"><span class="keyword">select</span> gender <span class="string">&#x27;性别&#x27;</span>,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="string">&#x27;gendersum&#x27;</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">15</span> <span class="keyword">group</span> <span class="keyword">by</span> gender <span class="keyword">having</span> gendersum<span class="operator">&gt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>排序查询：</strong></p><p>select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方式;</p><p>排序方式：</p><p>ASC：升序（默认值）</p><p>DESC：降序</p><p>如果多字段排序，当第一个字段值相同的时候，才会根据第二个字段进行排序</p><p><strong>分页查询：</strong></p><p>select 字段列表 from 表名 limit 起始索引,查询记录数;</p><ul><li>起始索引从0开始，起始索引=（查询页码-1）*每页显示记录数；</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL是limit；</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。</li></ul><p>顺序</p><ul><li>编写顺序：select&gt;from&gt;where&gt;group by&gt;order by&gt;limit</li><li>执行顺序：from&gt;where&gt;group by&gt;select&gt;order by&gt;limit</li></ul><h3 id="DCL-数据控制">DCL-数据控制</h3><p><strong>管理用户：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询用户</span></span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;<span class="comment">-- 可以在任意主机访问该数据库</span></span><br><span class="line"><span class="comment">-- 修改用户密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span><span class="string">&#x27;1234&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>权限控制：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询权限</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> db01.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 撤销权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> db01.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;miku&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>多个权限之间，用逗号分隔；</li><li>授权时，数据库名和表名可以使用*进行通配，代表所有。</li></ul><h2 id="函数">函数</h2><h3 id="字符串函数">字符串函数</h3><p>concat(s1,s2,s3,…,sn)字符串拼接</p><p>lower(str)转大写</p><p>upper(str)转小写</p><p>lpad(str,n,pad)用pad左填充</p><p>rpad(str,n,pad)用pad右填充</p><p>trim(str)去除头部和尾部的空格</p><p>substring(str,start,len)截取字符串，索引从1开始</p><h3 id="数值函数">数值函数</h3><p>ceil向上取整</p><p>floor向下取整</p><p>mod(x,y)求x/y的模</p><p>rand0~1之间的随机数</p><p>round(x,y)对x四舍五入后保留y位小数</p><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 产生一个6位数的随机验证码</span></span><br><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>,<span class="number">0</span>),<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="日期函数">日期函数</h3><p>curdate()返回当前的日期</p><p>curtime()返回当前的时间</p><p>now()返回当前的日期和时间</p><p>year(date)返回日期的年份</p><p>month(date)返回日期的月份</p><p>day(date)返回日期的天数</p><p>date_add(date,interval expr type)返回一个推移指定时间长度后的日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(now(),<span class="type">interval</span> <span class="number">70</span> <span class="keyword">day</span>);</span><br></pre></td></tr></table></figure><p>datediff(date1,date2)求取两个日期之间的天数，前边减后边的</p><h3 id="流程函数">流程函数</h3><p>if(value,t,f)如果value为true，返回t，为false则返回f</p><p>ifnull()如果第一个值为null，则返回第二个值；如果第一个值非null，则返回第一个值</p><p>case when [value1] then [res1]… else [default] end如果value1为true，返回res1,…否则返回default</p><p>case [expr] when [val1] then [res1]… else [default] end如果expr的值为val1则返回res1,…否则返回default</p><h2 id="约束">约束</h2><h3 id="约束-概述">约束-概述</h3><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段所有数据唯一</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>字段未指定值则用默认值</td><td>default</td></tr><tr><td>检查约束(8.0.16版本之后)</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接</td><td>foreign key</td></tr></tbody></table><h3 id="约束-外键约束">约束-外键约束</h3><p>外键约束是让两张表之间的数据建立连接，从而保证数据的一致性。</p><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign key</span>(外键字段名) <span class="keyword">references</span> 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span>(外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign key</span> 外键名称;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter table</span> emp <span class="keyword">add constraint</span> fk_dept_id <span class="keyword">foreign key</span>(dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign key</span> fk_dept_id;</span><br></pre></td></tr></table></figure><h3 id="外键删除更新行为">外键删除更新行为</h3><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>no action</td><td>当在父表中删除/更新对应记录时，首先检查该记录中是否有对应外键，如果有则不允许更改</td></tr><tr><td>restrict</td><td>当在父表中删除/更新对应记录时，首先检查该记录中是否有对应外键，如果有则不允许更改</td></tr><tr><td>cascade</td><td>当在父表中删除/更新对应记录时，首先检查该记录中是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td></tr><tr><td>set null</td><td>当在父表中删除对应记录时，首先检查该记录中是否有对应外键，如果有则设置为null（前提是允许为null）</td></tr><tr><td>set default</td><td>父表有变更时，子表将外键设置成一个默认的值（Innodb不支持）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span>(外键字段) <span class="keyword">references</span> 主表(主表列名) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure><h2 id="多表查询">多表查询</h2><h3 id="多表关系">多表关系</h3><p><strong>一对多</strong></p><p>通常在多的一方添加外键，关联到一的一方的主键</p><p><strong>多对多</strong></p><p>建立第三方中间表，中间表至少包含两个外键，分别关联两方主键</p><p><strong>一对一</strong></p><p>通常用于单表查询，或者将其拆分，并在任意一方加入外键来关联。注意在外键中添加unique约束以保证一对一</p><h3 id="连接查询">连接查询</h3><p><strong>内连接</strong></p><p>隐式内连接：select 字段列表 from  表1,表2 where 条件…；<br>显示内连接：select 字段列表 from  表1 [inner] join 表2 on 连接条件…；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> emp.name,dept.name <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 如果为表起了别名，那么就不能通过表名限制字段</span></span><br><span class="line"><span class="keyword">select</span> e.name,d.name <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"><span class="comment">-- 显式内连接</span></span><br><span class="line"><span class="keyword">select</span> emp.name,dept.name <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><ul><li>内连接查询的是两张表交集的部分</li></ul><p><strong>外连接</strong></p><p>左外连接</p><p>select 字段列表 from 表1 left [outer] join 表2 on 条件…;</p><p>相当于查询表1（左表）的所有数据包括交集部分的数据</p><p>右外连接</p><p>select 字段列表 from 表1 right [outer] join 表2 on 条件…;</p><p>相当于查询表2（右表）的所有数据包括交集部分的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>,dept.name <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">select</span> dept.<span class="operator">*</span>,emp.<span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 使用左外连接实现右外连接</span></span><br><span class="line"><span class="keyword">select</span> dept.<span class="operator">*</span>,emp.<span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><p>常用左外连接实现</p><p><strong>自连接</strong></p><p>自连接查询使用内连接查询和外连接查询均可，重点是要给一张表<strong>起两个不同的别名</strong></p><p>内连接查询（例）</p><p>select 字段列表 from 表A 别名A join 表 A 别名B on 条件…;</p><p>外连接查询（例）</p><p>select 字段列表 from 表A 别名A left join 表 A 别名B on 条件…;</p><h3 id="联合查询">联合查询</h3><p>对于联合查询实际上就是将多次查询的结果合并起来，形成一个新的查询结果集，要使用到关键字union，union all。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A…</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B…；</span><br></pre></td></tr></table></figure><ul><li>对于联合查询的多张表的列数和字段类型需要保持一致</li><li>union all会将全部的数据直接贴合在一起，union会对合并之后的数据去重</li></ul><h3 id="子查询">子查询</h3><p><strong>标量子查询</strong></p><p>子查询的结果是单个的值，就称为标量子查询</p><p>例如如下的需求，查询某某部门的所有员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分步查询</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;<span class="comment">-- 查询某部门（假设为研发部）的对应id</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;<span class="comment">-- 由得到的id查询员工信息</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>);<span class="comment">-- 直接将第一个结果替换id进行查询</span></span><br></pre></td></tr></table></figure><p><strong>列子查询</strong></p><p>查询的结果为一列多行，就称为列子查询</p><p>常用的操作符</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>not in</td><td>不在指定的集合范围之内</td></tr><tr><td>any</td><td>子查询返回的列表中，有一个满足即可</td></tr><tr><td>some</td><td>等同于any</td></tr><tr><td>all</td><td>子查询返回的列表的所有值必须满足</td></tr></tbody></table><p><strong>行子查询</strong></p><p>查询的结果为一行多列，就称为列子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与“张无忌”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>表子查询</strong></p><p>查询的结果为多行多列，就称为表子查询。通常将表子查询的结果作为一个新的表进行多表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与“鹿杖客”，“宋远桥”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary)<span class="keyword">in</span> (<span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> &quot;鹿杖客&quot; <span class="keyword">or</span> name <span class="operator">=</span>&quot;宋远桥&quot;);</span><br><span class="line"><span class="comment">-- 查询入职日期是&quot;2006-01-01&quot;之后的员工信息，及其部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate<span class="operator">&gt;</span><span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id<span class="operator">=</span>d.id</span><br></pre></td></tr></table></figure><h2 id="事务">事务</h2><p>事务是一组操作的集合，这组操作，要么全部执行成功，要么全部执行失败</p><h3 id="事务操作">事务操作</h3><p>第一种方式</p><ul><li>查看/设置事务提交方式<br>select @@autocommit;<br>set @@autocommit=1;</li><li>提交事务<br>commit;</li><li>回归事务<br>rollback;</li></ul><p>第二种方式</p><ul><li>开启事务<br>start transaction或begin;</li><li>提交事务<br>commit;</li><li>回归事务<br>rollback;</li></ul><h3 id="事务的四大特性ACID">事务的四大特性ACID</h3><p>原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么<br>全部失败回滚</p><p>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态</p><p>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p><p>持久性：一旦事务提交，则其所做的修改会永久保存到数据库</p><h3 id="并发事务问题">并发事务问题</h3><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">一个事务读到另一个事物还没有提交的数据</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">一个事务按条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="事务隔离级别">事务隔离级别</h3><p>事务的隔离级别就是来解决并发事务问题的，下表表示解决情况。√表示未解决，×表示解决</p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read uncommitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Read committed</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Repeatable Read(默认)</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>查看事务的隔离级别</p><p>select @@transaction_isolation;</p><p>设置事务的隔离级别</p><p>set [global/session] transaction isolation level [隔离级别];</p><h1>MySQL-进阶</h1><h2 id="存储引擎">存储引擎</h2><h3 id="MySQL体系结构">MySQL体系结构</h3><ul><li>连接层</li><li>服务层</li><li>引擎层</li><li>存储层</li></ul><h3 id="简介">简介</h3><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型</p><p>创建表时指定存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 [comment 注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [comment 注释]</span><br><span class="line">)engine<span class="operator">=</span>存储引擎名[comment 表注释];</span><br></pre></td></tr></table></figure><h3 id="存储引擎的特点和选择">存储引擎的特点和选择</h3><p>特点</p><ul><li><p>InnoDB：</p><ul><li><p>MySQL目前默认的存储引擎；</p></li><li><p>支持<strong>事务、外键、行级锁</strong>；</p></li><li><p>默认每张表对应与磁盘中的一个.ibd文件。</p></li></ul></li></ul><p>InnoDB的逻辑存储结构：在InnoDB的逻辑存储结构中，Page是操作的最小单元，Extent的大小固定为1M，Page大小固定为16K</p><p><img src="/2025/05/24/MySQL/image-20250629154012042.png" alt="image-20250629154012042"></p><ul><li><p>MyISAM：</p><ul><li>MySQL早期的默认存储引擎；</li><li>不支持事务、外键，支持表锁不支持行锁，访问速度快；</li><li>文件：sdi：存储表结构的信息，MYD：存储数据，MYI：存储索引</li></ul></li><li><p>MEMORY：</p><ul><li>数据存放在内存中，由于受到硬件的问题、断电问题的影响，只能将这些表作为临时表或缓存使用</li><li>内存存放、hash索引（默认）</li><li>.sdi文件：存储表结构的信息</li></ul></li></ul><p><strong>存储引擎的选择：</strong></p><ul><li><p>InnoDB：是MySQL的默认存储引擎，支持<strong>事务、外键</strong>。如果应用对<strong>事务的完整性</strong>又比较高的要求，在并发条件下要求<strong>数据的一致性</strong>，数据操作除了插入和查询之外，还包含很多的<strong>更新、删除操作</strong>，那么InnoDB存储引擎是比较合适的选择。</p></li><li><p>MyISAM：如果应用是以读取和插入为主，很少有更新、删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎比较合适。</p></li><li><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保证数据的安全性。</p></li></ul><p>说是这么说，但是实际上主要用的就是InnoDB了，MyISAM的使用场景基本被nosql系列的数据库取代了，而MEMORY的场景被Redis取代了。</p><h2 id="索引">索引</h2><h3 id="概述">概述</h3><p>索引（index）本质上一种数据结构，是为了帮助数据库高效获取数据。</p><p><strong>索引的优势</strong>：提高数据<strong>检索的效率</strong>，降低数据库的IO成本；通过索引列对数据进行排序，降低数据<strong>排序</strong>的成本，降低CPU的消耗。</p><p>索引的劣势：占用空间；降低了更新表操作insert、update、delete的效率</p><p>索引大大提高了查询效率，却也降低了insert、update、delete的效率，不过一般主要业务都是查询，所以瑕不掩瑜。</p><h3 id="索引的结构">索引的结构</h3><p><strong>B+Tree索引:</strong></p><p>MySQL常用（默认）的结构就是<strong>B+Tree（多路平衡搜索树）</strong></p><ul><li>每一个节点，可以存储<strong>多个key</strong></li><li>所有的数据存储在叶子节点，非叶子节点仅用于索引数据</li><li>叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询</li></ul><p>这种结构就像一个矮胖的树，避免了二叉树容易<strong>层级过深</strong>的问题。</p><p><strong>Hash索引：</strong></p><p>Hash索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><p>如果两个（或多个）键值，映射到一个相同的键位，他们就产生了hash冲突（也称hash碰撞），可以通过链表来解决。</p><p><strong>特点</strong></p><ol><li>Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常高于B+Tree索引</li></ol><p><strong>存储引擎支持</strong></p><p>在MySQL中，支持hash索引的是MEMORY引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p><p><strong>思考：为什么InnoDB采用B+Tree索引？</strong></p><ul><li>相对于二叉树，层级更少，搜索效率更高</li><li>对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量的数据，只能增加树的高度，导致性能降低</li><li>相对于hash索引，hash索引不支持范围匹配及排序操作而B+Tree支持</li></ul><p>其他的还有R-tree空间索引、Full-text全文索引。之后如果没有特别说明，索引都是指B+Tree索引</p><h3 id="索引的分类">索引的分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td><strong>主键索引</strong></td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td><strong>唯一索引</strong></td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td><strong>常规索引</strong></td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td><strong>全文索引</strong></td><td>查找文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><p><strong>聚集索引（Clustered Index）</strong></p><ul><li>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</li><li>必须有，而且只有一个</li></ul><p><strong>二级索引（Secondary Index）</strong></p><ul><li>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</li><li>可以存在多个</li></ul><p><strong>聚集索引的选取规则：</strong></p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li><li>如果没有主键也没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><p>结构如图所示：</p><p><img src="/2025/05/24/MySQL/image-20250629214044891.png" alt="image-20250629214044891"></p><p>有趣的问题：InnoDB的主键索引的B+Tree高度为多高？</p><p>假设，一行的数据为1K，那么一页（16K），就能存放16行这样的数据。InnoDB的指针占用6个字节的空间，主键类型如果为bigint，就占用8个字节的空间。</p><p>先算出一页中有多少个主键，设为x，则$x*8+(n+1)<em>6=16</em>1024$，得x约为1170，那么就有1171个指针</p><p>如果树的高度为2：</p><p>那么存放数据有：$1171*16=18736$</p><p>如果树的高度为3：</p><p>那么存放的数据有：$1171^2*16=21939856$</p><h3 id="索引的语法">索引的语法</h3><ul><li>创建索引</li></ul><p>create [unique] index 索引名 on 表名(字段名,…);</p><ul><li>查看索引</li></ul><p>show index from 表名</p><ul><li>删除索引</li></ul><p>drop index 索引名 on 表名;</p><ul><li>建表时如果添加了主键约束，那么就会自动创建主键索引，是性能最高的</li><li>建表时添加唯一约束，本质就是添加了唯一索引</li></ul><h3 id="SQL性能分析">SQL性能分析</h3><p><strong>SQL执行频率</strong></p><p>通过如下指令，可以查看当前数据库的Insert、update、delete、select的访问频次</p><p><code>show global status like 'Com_______'</code></p><p><strong>慢查询日志</strong></p><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启MySQL慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#设置慢查询时间为2s，SQL语句执行时间超过2s，就会被视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><p>慢日志文件记录在/var/lib/mysql/localhost-slow.log</p><p><strong>profile详情</strong></p><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p><p><code>SELECT @@have_profiling；</code></p><p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：</p><p><code>SET profiling = 1;</code></p><p>执行一系列的业务SQL操作，然后通过以下指令可以查看指令的执行耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line">#查看特定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line">#查看指定uery_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>explain执行计划</strong></p><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>语法：</p><p>直接在select语句之前加上关键字 explain / desc</p><p><code>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件；</code></p><p>EXPLAIN 执行计划各字段含义：</p><p>➢ id</p><p>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</p><p>➢ select_type</p><p>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。</p><p>➢ <strong>type</strong></p><p>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。</p><p>➢ <strong>possible_keys</strong></p><p>显示可能应用在这张表上的索引，一个或多个</p><p>➢ <strong>key</strong><br>实际使用的索引，如果为NULL，则没有使用索引。</p><p>➢ <strong>key_len</strong><br>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p><p>➢ <strong>rows</strong><br>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</p><p>➢ filtered<br>表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。</p><p>加粗的是需要重点关注的</p><h3 id="索引的使用">索引的使用</h3><p><strong>最左前缀法则</strong></p><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指查询从索引最左列开始，并且不跳过索引中的列。如果跳跃了某一列，索引将部分失效（后面的字段索引失效）</p><p><strong>范围查询</strong></p><p>联合索引中，出现范围查询（&gt;,&lt;），范围查询右侧的列索引失效</p><p>因此，在业务允许的范围内，尽量使用&gt;=,&lt;=这样的范围查询</p><p><strong>索引列运算</strong></p><p>不要在索引列上进行运算操作，<strong>索引将失效</strong>。</p><p><strong>字符串不加引号</strong></p><p>字符串类型字段使用时，不加引号，<strong>索引将失效</strong>。</p><p><strong>模糊查询</strong></p><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>因此在大数据量的情况下，要尽量避免头部模糊匹配的情况。</p><p><strong>or连接的条件</strong></p><p>用or分割开的条件，如果or前的条件中的列有索引，而后边的列没有索引，那么涉及的索引都不会用到。</p><p>解决办法：针对没有索引的列添加索引即可。</p><p><strong>数据分布影响</strong></p><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><strong>SQL提示</strong></p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化的目的。</p><p>指令：</p><p>use index：</p><p><code>explain select * from 表名 use index(索引名字) where profession = ‘软件工程’</code></p><p>ignore index：</p><p><code>explain select * from 表名 ignore index(索引名字) where profession = ‘软件工程’</code></p><p>force index：</p><p><code>explain select * from 表名 force index(索引名字) where profession = ‘软件工程’</code></p><p><strong>覆盖索引</strong></p><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到），减少select *。</p><ul><li>关于Extra的参数：</li></ul><p>using index condition：查找使用了索引，但是需要回表查询数据</p><p>using where；using index：查找使用了索引，但是需要的数据在索引列中能够找到，所以不需要回表查询数据</p><p>所以后者的性能更高</p><ul><li>SQL优化问题：一张表，有四个字段（id,username,password,status）由于数据量大，需要对以下SQL语句进行优化，如何才是最优方案？<br><code>select id,username,password from tb_user where username='itcast'</code></li><li>答：需对username和password两个字段创建联合索引</li></ul><p><strong>前缀索引</strong></p><p>当字段类型是字符串（varchar、text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样就可以大大节约索引空间，从而提高索引效率。</p><ul><li>语法<br><code>create index idx_xxx on table_name(column(n))</code></li><li>前缀长度<br>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询的效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br><code>select count(distinct email)/count(*) from tb_user;</code><br><code>select count(distinct substring(email,1,5))/count(*) from tb_user;</code></li></ul><p>前缀索引的查询流程</p><p><img src="/2025/05/24/MySQL/image-20250630163104143.png" alt="image-20250630163104143"></p><p><strong>单列索引与联合索引</strong></p><p>单列索引：即一个索引只包含单个列</p><p>联合索引：即一个索引包含了多个列</p><p>在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议使用联合索引，而非单列索引。</p><p>例如：</p><ul><li>单列索引情况：</li></ul><p><code>explain select id,phone,name from tb_user where phone = '1111111323' and name ='xxx'</code></p><p>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</p><ul><li>联合索引情况：</li></ul><p><code>create unique index idx_phone_name on tb_user(phone,name)</code></p><p>由于创建的是联合索引，索引字段列表的顺序会有影响，参见<strong>最左前缀法则</strong>。</p><p><strong>索引设计原则</strong></p><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。  （几百万条）</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><h2 id="SQL优化">SQL优化</h2><h3 id="插入数据">插入数据</h3><p><strong>insert优化</strong></p><ul><li><p>批量插入<br><code>insert into tb_test values(1,'Tom),(2,'Cat)...</code></p></li><li><p>手动提交事务</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom),(2,&#x27;</span>Cat<span class="string">&#x27;)...;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">commit;</span></span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入</p></li></ul><p><strong>大批量数据插入</strong></p><p>如果一次性需要插入大量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端连接上服务器时，加上参数 —local-infile</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">--local-infile -u root -p</span></span><br><span class="line"><span class="comment">#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="attr">set</span> <span class="string">global local_infile=1;</span></span><br><span class="line"><span class="comment">#执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line"><span class="attr">load</span> <span class="string">data local infile &#x27;/root/sql1.log&#x27; into table `tb_user` field terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="主键优化">主键优化</h3><p><strong>数据组织方式</strong></p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table <strong>IOT</strong>）。</p><p><strong>页分裂</strong></p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据（如果一行数据太大，会行溢出），根据主键排列。</p><p><strong>页合并</strong></p><p>当删除一行记录时，实际上记录没有被物理删除，只是被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><p>当页中删除的记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（左或右）看看是否可以将两个页合并以优化空间使用。</p><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><h3 id="order-by优化">order by优化</h3><ol><li><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p></li><li><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p></li></ol><p><strong>创建索引时指定升降序的指令：</strong></p><p><code>create index idx_user_age_phone_aa on tb_user(age asc/desc, phone asc/desc);</code></p><p>如果没有指定，默认为降序。</p><p><strong>总结</strong></p><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li></ol><h3 id="group-by优化">group by优化</h3><p><strong>总结</strong></p><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h3 id="limit优化">limit优化</h3><p>一个常见的问题就是当limit的起始索引非常大时，此时MySQL需要排序起始索引前的记录，仅仅返回起始索引后的部分记录，其他记录废弃，查询排序的代价非常大。</p><p>优化思路：</p><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询的形式进行优化。</p><h3 id="count优化">count优化</h3><p>对比MyISAM和InnoDB：</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li><li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p><strong>count的几种用法</strong></p><ul><li>count是一个聚合函数，对于结果的返回集，一行行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值。</li><li>用法：count(*)，count(主键)、count(字段)、count(1)</li></ul><p><strong>几种用法的对比</strong></p><p>count（主键）<br>InnoDB 引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)。</p><p>count（字段）<br>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p><p>count（1）<br>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字&quot;1&quot;进去，直接按行进行累加。</p><p>count（*）<br>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p><p>按照效率排序的话，count(字段) &lt; count(主键id) &lt; count(1) ≈ count( * )，所以尽量使用count( * )。</p><h3 id="update优化">update优化</h3><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁，导致并发性能的降低。</p><h2 id="存储对象">存储对象</h2><h3 id="视图">视图</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p><strong>基本语法</strong></p><ul><li><p>创建视图<br><code>CREATE [OR REPLACE] VIEW 视图名称(列名列表) AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]</code></p></li><li><p>查询视图<br>查看创建视图语句：<code>SHOW CREATE VIEW 视图名称;</code><br>查看视图数据：<code>SELECT * FROM 视图名称……;</code></p></li><li><p>修改视图<br>方式一：<code>CREATE [OR REPLACE] VIEW 视图名称(列名列表) AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]</code><br>方式二：<code>ALTER VIEW 视图名称(列名列表) AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]</code></p></li><li><p>删除视图<br><code>DROP VIEW [IF EXISTS] 视图名称 [视图名称] …</code></p></li></ul><p><strong>视图的检查选项</strong></p><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行（如插入、更新、删除），以确保其符合视图的定义。MySQL允许基于另一个视图创建视图，并会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：CASCADED 和 LOCAL，默认值为 CASCADED。</p><ul><li>cascaded</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v3 <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> v2 <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>CASCADED选项会级联检查所有底层视图的条件，可以认为在依赖的视图v1上也添加了with cascaded check option</li><li>在示例中，v2视图会同时检查v1和v2自身的条件</li><li>v3视图由于没有指定WITH CHECK OPTION，不会检查自身的条件，但是会检查v1和v2的条件</li></ol><ul><li>local</li></ul><p>使用local，会递归地去检查依赖的视图是否要进行检查，如果依赖的视图有with check option则也要进行检查。</p><p><strong>视图的更新</strong></p><ol><li><p>视图的更新要求视图中的行与基础表中的行之间存在一对一的关系。</p></li><li><p>如果视图包含以下任何一项，则该视图不可更新：</p><ul><li><p>聚合函数或窗口函数（如 SUM()、MIN()、MAX()、COUNT() 等）</p></li><li><p>DISTINCT</p></li><li><p>GROUP BY</p></li><li><p>HAVING</p></li><li><p>UNION 或 UNION ALL</p></li></ul></li></ol><p><strong>视图的作用</strong></p><ol><li>简单<ul><li>视图可以简化用户对数据的理解和操作。</li><li>常用的查询可以定义为视图，避免用户每次操作时重复指定全部条件。</li></ul></li><li>安全<ul><li>数据库可以授权，但无法精确到特定行或列。</li><li>通过视图，用户只能查询和修改他们被允许访问的数据。</li></ul></li><li>数据独立<ul><li>视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ul></li></ol><h3 id="存储过程">存储过程</h3><p><strong>介绍</strong></p><p>存储过程（procedure）是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p><p><strong>特点</strong></p><ul><li>封装，复用</li><li>可以接收参数，也可以返回数据</li><li>减少网络交互，效率提升</li></ul><p><strong>基本语法</strong></p><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- SQL语句;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 存储过程名称();</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;数据库名字&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名字;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> 存储过程名字;</span><br></pre></td></tr></table></figure><p>注意：在命令行中创建存储过程时，需要通过关键字delimiter指定SQL语句的结束符。</p><p>格式就是<code>delimiter 指定结束符;</code></p><p><strong>变量</strong></p><blockquote><p>系统变量<br>MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p></blockquote><ul><li>查看系统变量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables;<span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;...&#x27;</span>;<span class="comment">-- 模糊匹配查找变量</span></span><br><span class="line"><span class="keyword">select</span> @@[session.<span class="operator">|</span>global.]系统变量名;<span class="comment">-- 查看指定变量的值</span></span><br></pre></td></tr></table></figure><ul><li>设置系统变量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[session.<span class="operator">|</span>global.]系统变量名 <span class="operator">=</span> 值; </span><br></pre></td></tr></table></figure><p>注意：如果没有指定session/global，默认是session，会话变量。</p><p>MySQL服务重启后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf中配置。</p><blockquote><p>用户定义变量</p><p>用户根据需要自己定义的变量，用户变量不用提前声明在用的时候用“@变量名”使用就可以。其作用域为当前连接。</p></blockquote><ul><li>赋值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以使用=也可以使用:=，推荐使用:=</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr[,<span class="variable">@var_name2</span><span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr[,<span class="variable">@var_name2</span>:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="comment">-- 第二种方法，使用select语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr[,<span class="variable">@var_name2</span><span class="operator">=</span>expr]...;</span><br><span class="line"><span class="comment">-- 将查询的字段赋值给变量</span></span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure><p>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p><blockquote><p>局部变量</p><p>根据需要定义的在局部生效的变量，访问之前，需要使用declare声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的begin…end块。</p></blockquote><ul><li>声明</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型[<span class="keyword">default</span> ...];</span><br></pre></td></tr></table></figure><ul><li>赋值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p><strong>if判断</strong></p><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>作为输入参数，调用时需要传入值</td><td>默认类型</td></tr><tr><td>OUT</td><td>作为输出参数，可作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可作输入参数，也可作输出参数</td><td></td></tr></tbody></table><ul><li>用法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span> 参数名称 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- sql语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><strong>case</strong></p><p>语法一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">    <span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">    [<span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">    [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>语法二</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">    [<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">    [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>语法一通过比较固定的 <code>case_value</code> 与 <code>when_value</code> 进行匹配。</li><li>语法二通过判断条件表达式 <code>search_condition</code> 执行对应的逻辑。</li></ul><p><strong>循环</strong></p><blockquote><p>while</p><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判断条件，如果条件为true，则执行逻辑，否则不执行逻辑</span></span><br><span class="line">while 条件 do</span><br><span class="line"><span class="keyword">sql</span>逻辑...</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><blockquote><p>repeat</p><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p></blockquote><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先执行一次循环，如果满足条件，则退出，如果不满足则继续执行循环</span></span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">sql</span>逻辑...</span><br><span class="line">until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure><blockquote><p>loop</p><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。l</p></blockquote><p>loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环。</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:]loop</span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">end</span> loop [end_label];</span><br><span class="line">leave 标记;<span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">iterate 标记;<span class="comment">-- 直接进入下一次循环</span></span><br></pre></td></tr></table></figure><p><strong>游标</strong></p><ol><li><p>游标（CURSOR）</p><ul><li>用于存储查询结果集的数据类型，在存储过程和函数中可对结果集进行循环处理。</li></ul></li><li><p>游标的使用步骤</p><ul><li><p>声明游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句；  </span><br></pre></td></tr></table></figure></li><li><p>打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称；  </span><br></pre></td></tr></table></figure></li><li><p>获取游标记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量 [,变量]；  </span><br></pre></td></tr></table></figure></li><li><p>关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称；  </span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>条件处理程序</strong></p><p>条件处理程序(Handler)可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><p>具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value[,condition_value]... statement;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handler_action</span><br><span class="line">continue:继续执行当前程序</span><br><span class="line">exit:终止执行当前程序</span><br><span class="line">condition_value</span><br><span class="line"><span class="keyword">SQLSTATE</span> sqlstate_value:状态码，如<span class="number">02000</span></span><br><span class="line"><span class="keyword">SQLWARNING</span>:所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line"><span class="keyword">NOT</span> FOUND:所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line"><span class="keyword">SQLEXCEPTION</span>:所有没有被<span class="keyword">SQLWARNING</span>或<span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure><p>状态码可以参考mysql的官方文档：</p><p><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">MySQL :: MySQL 8.0 Error Reference :: 2 Server Error Message Reference</a></p><h3 id="存储函数">存储函数</h3><p>存储函数（function）是有返回值的存储过程，存储函数的参数只能是IN类型。</p><p>具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称()</span><br><span class="line"><span class="keyword">returns</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL：不包含SQL语句</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</li></ul><p>存储函数并不常用，因为它能完成的事情，存储过程都能完成，但是存储函数还要求必须有返回值，并不普适。</p><h3 id="触发器">触发器</h3><p>介绍</p><ol><li>触发器（trigger）是与表有关的数据序列，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</li><li>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</li></ol><table><thead><tr><th>触发器类型</th><th>NEW/OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tbl_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name;<span class="comment">-- 如果没有指定schema_name，默认为当前数据库</span></span><br></pre></td></tr></table></figure><h2 id="锁">锁</h2><h3 id="概述-2">概述</h3><p><strong>介绍</strong></p><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤为重要，也更加复杂。</p><p><strong>分类</strong></p><p>MySQL中的锁，按照锁的力度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ol><h3 id="全局锁">全局锁</h3><p><strong>介绍</strong></p><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取<strong>一致性</strong>视图，保证数据的完整性。</p><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>一般的备份操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 itcast&gt;itcast.sql</span><br></pre></td></tr></table></figure><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ol><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ol><p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p123456 itcast&gt;itcast.sql</span><br></pre></td></tr></table></figure><h3 id="表级锁">表级锁</h3><p><strong>介绍</strong></p><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ol><p><strong>表锁</strong></p><p>对于表锁，又可以分为两类：</p><ol><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ol><p>语法</p><ol><li>加锁：lock tables 表名… read/write</li><li>释放锁：unlock tables/客户端断开连接</li></ol><p>读锁示意图：</p><p><img src="/2025/05/24/MySQL/image-20250702220250532.png" alt="image-20250702220250532"></p><p>加读锁后两个客户端都只能进行查询操作</p><p>写锁示意图：</p><p><img src="/2025/05/24/MySQL/image-20250702220304768.png" alt="image-20250702220304768"></p><p>加写锁后只有加锁客户端既可以读又可以写，其他客户端既不能读也不能写</p><p><strong>元数据锁</strong></p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong></p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read / write</td><td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>查看元数据锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure><p><strong>意向锁</strong></p><p>意向锁主要解决的问题是在InnoDB引擎中加的行锁和表锁加锁冲突的问题</p><ol><li>意向共享锁（IS）：由语句 select … lock in share mode添加。</li><li>意向排他锁（IX）：由insert、update、delete、select … for update 添加。</li></ol><p>兼容性</p><ol><li>意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</li><li>意向排他锁（IX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</li></ol><p>查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_scema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="行级锁">行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ol><p><strong>行锁</strong></p><p>InnoDB实现了以下两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><table><thead><tr><th>当前锁类型|请求锁类型</th><th>S (共享锁)</th><th>X (排他锁)</th></tr></thead><tbody><tr><td>S (共享锁)</td><td>兼容</td><td>冲突</td></tr><tr><td>X (排他锁)</td><td>冲突</td><td>冲突</td></tr></tbody></table><p>执行SQL语句时加的锁类型：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p><strong>间隙锁/临键锁</strong></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止<strong>幻读</strong>。</p><ol><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁。</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ol><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改历史：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2025-07-01 修复了sql语句的代码快无法高亮的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;MySQL-基础&lt;/h1&gt;
&lt;p&gt;数据库管理系统DBMS&lt;/p&gt;
&lt;p&gt;MySQL数据模型&lt;/p&gt;
&lt;p&gt;客户端-&amp;gt;DBMS-&amp;gt;多个</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://cv-elevation.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>主题~</title>
    <link href="http://cv-elevation.github.io/2025/03/30/theme/"/>
    <id>http://cv-elevation.github.io/2025/03/30/theme/</id>
    <published>2025-03-30T05:44:57.000Z</published>
    <updated>2025-06-03T13:14:42.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一点牢骚">一点牢骚</h2><p>​我自己的博客网站基本配置好了，选了张涩涩的miku当头图，或许这样能让我写代码和文的时候肾上腺素提升从而提高效率呢（<s>bushi</s>）。<br>​好像很多技术党都有一个自己博客，我也就东施效颦一下，但是其实更多的原因还是因为他人，也就是跟风。一直以来，我好像都缺乏一个内源的动力和目标，也没有什么自己的想法和意志，一直都是在不停地模仿。但是那又如何呢？<br>​我真的很讨厌自己去做选择，既没有能做出正确决定的视野，连做出决定的决心也没有。算了，我也不想过分自贬，就这样吧。</p><p>​言归正传，用了一天半搭建的网站还是可以庆祝一下的，也是有了一个个人的空间，或许可以成为我之后若干年还活着的证明。<br>​整体来讲，我想写一个是学习笔记，专业的技术文我也没有写的实力，还有就是一个经验积累，最后就是一些随想，当日记写呗就。</p><p>​最后附一张可爱的公主殿下！（<s>typora的图片直接插入功能太好用了</s>）</p><p><img src="/2025/03/30/theme/%E5%88%9D%E9%9F%B3.jpg" alt="初音"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一点牢骚&quot;&gt;一点牢骚&lt;/h2&gt;
&lt;p&gt;​		我自己的博客网站基本配置好了，选了张涩涩的miku当头图，或许这样能让我写代码和文的时候肾上腺素提升从而提高效率呢（&lt;s&gt;bushi&lt;/s&gt;）。&lt;br&gt;
​		好像很多技术党都有一个自己博客，我也就东施效颦一下，但是其实</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://cv-elevation.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
