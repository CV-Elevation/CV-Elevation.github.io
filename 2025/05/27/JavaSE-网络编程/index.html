<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaSE-网络编程 | KuoZ's blog</title><meta name="author" content="KuoZ"><meta name="copyright" content="KuoZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="网络编程 软件架构： CS架构：客户端-服务器 BS架构：浏览器-服务器 不过现在的很多软件都是一种混合开发，就是将CS架构和BS架构融合起来。 网络编程三要素 如何准确定位一台或多态主机：使用IP地址 如何定位主机上的特定的应用：使用端口号 如何可靠、高效地进行数据传输：规范通信协议 IP地址 IP地址：网络中的一台计算机设备做唯一编号 IP地址分类： 分类方式一： IPv4：占用4个字节，表示">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE-网络编程">
<meta property="og:url" content="http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="KuoZ&#39;s blog">
<meta property="og:description" content="网络编程 软件架构： CS架构：客户端-服务器 BS架构：浏览器-服务器 不过现在的很多软件都是一种混合开发，就是将CS架构和BS架构融合起来。 网络编程三要素 如何准确定位一台或多态主机：使用IP地址 如何定位主机上的特定的应用：使用端口号 如何可靠、高效地进行数据传输：规范通信协议 IP地址 IP地址：网络中的一台计算机设备做唯一编号 IP地址分类： 分类方式一： IPv4：占用4个字节，表示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cv-elevation.github.io/img/holo.jpg">
<meta property="article:published_time" content="2025-05-27T10:21:16.000Z">
<meta property="article:modified_time" content="2025-06-03T08:31:39.953Z">
<meta property="article:author" content="KuoZ">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="Socket">
<meta property="article:tag" content="URl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cv-elevation.github.io/img/holo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaSE-网络编程",
  "url": "http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
  "image": "http://cv-elevation.github.io/img/holo.jpg",
  "datePublished": "2025-05-27T10:21:16.000Z",
  "dateModified": "2025-06-03T08:31:39.953Z",
  "author": [
    {
      "@type": "Person",
      "name": "KuoZ",
      "url": "http://cv-elevation.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/Myfavicon2.ico"><link rel="canonical" href="http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE-网络编程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/miku2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KuoZ's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JavaSE-网络编程</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JavaSE-网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-27T10:21:16.000Z" title="发表于 2025-05-27 18:21:16">2025-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-03T08:31:39.953Z" title="更新于 2025-06-03 16:31:39">2025-06-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>3分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>网络编程</h1>
<p>软件架构：</p>
<p>CS架构：客户端-服务器</p>
<p>BS架构：浏览器-服务器</p>
<p>不过现在的很多软件都是一种<strong>混合开发</strong>，就是将CS架构和BS架构融合起来。</p>
<h2 id="网络编程三要素">网络编程三要素</h2>
<p>如何准确定位一台或多态主机：使用IP地址</p>
<p>如何定位主机上的特定的应用：使用端口号</p>
<p>如何可靠、高效地进行数据传输：规范通信协议</p>
<h3 id="IP地址">IP地址</h3>
<p>IP地址：网络中的一台计算机设备做唯一编号</p>
<p>IP地址分类：</p>
<p>分类方式一：</p>
<p>IPv4：占用4个字节，表示为<strong>a.b.c.d</strong>的形式，以点分十进制表示</p>
<p>IPv6：占用16个字节</p>
<p>分类方式二：</p>
<p>公网地址（万维网使用）和私网地址（局域网使用）192.168.开头的就是私有地址</p>
<p>本地回路地址：127.0.0.1</p>
<p>域名：便捷地记录ip地址</p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a> kuoz.top</p>
<p>域名使用中通过DNS解析成IP再进行访问的</p>
<h3 id="端口号">端口号</h3>
<p>端口号可以唯一标识主机中的进程</p>
<p>不同的进程分配不同的端口号</p>
<p>范围：0~65535</p>
<h3 id="网络通信协议">网络通信协议</h3>
<p>OSI模型：过于理想化，没能实现</p>
<p>TCP/IP：分为应用层、传输层、网络层、物理+数据链路层</p>
<h2 id="InetAddress类">InetAddress类</h2>
<p>InetAddress类的一个实例就代表一个具体的ip地址</p>
<p>实例化方式：</p>
<p>InetAddress getByName(String host)</p>
<p>InetAddress getLocalHost()</p>
<h2 id="TCP协议和UDP协议">TCP协议和UDP协议</h2>
<p>计算机网络的重要重要指示，在此处简要了解。</p>
<h2 id="TCP的Socket网络编程">TCP的Socket网络编程</h2>
<p>网络上具有唯一标识的IP地址和端口号的组合，唯一可识别的标识符套接字（Socket）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建Socket实例</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;10.10.208.62&quot;</span>);</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(address, port);</span><br><span class="line">    <span class="comment">//通过Socket创建输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    os.write(<span class="string">&quot;嗨嗨嗨, 服务器我来辣!&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">//关闭Socket及相关流</span></span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建serverSocket实例</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    <span class="comment">//接收来自于客户端的Socket</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端连接成功，等待接收数据...&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;收到了来自&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;的连接&quot;</span>);</span><br><span class="line">    <span class="comment">//通过Socket创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//读写过程</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//当byte太小时，这里中文会因为中间被截断而出乱码，通过baos来解决</span></span><br><span class="line">        <span class="comment">//String message = new String(buffer, 0, len);</span></span><br><span class="line">        <span class="comment">//解决方法</span></span><br><span class="line">        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(baos.toString());</span><br><span class="line">    System.out.print(<span class="string">&quot;\n接收完毕&quot;</span>);</span><br><span class="line">    <span class="comment">//关闭Socket和相关流</span></span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端需要接收服务器发送的回复信息时出现的死锁问题：</p>
<p>客户端向服务器发送数据后，服务器向客户端<strong>回复信息</strong>，客户端接收服务器的接受信息。</p>
<p>如果直接在客户端创建输入流并打印出来，而不进行操作，那么服务器端会因为认为Socket没有终止发送信息而不回复<strong>回复信息</strong>，客户端没有接收到数据，那么也不会关闭Socket，这样就相互锁在了一起。</p>
<p>解决方法是在客户端发送数据后<code>socket.shutdownOutput();</code>来表示已经发送完毕。</p>
<h2 id="UDP网络编程">UDP网络编程</h2>
<p>TCP有三次握手，建立连接，是可靠的</p>
<p>UDP不需要建立连接，是不可靠的</p>
<h2 id="URL编程">URL编程</h2>
<p>URL(Uniform Resource Locator)：统一资源定位符</p>
<p>一个具体的URL就对应着互联网上某一资源的地址</p>
<p>URL的格式：</p>
<p>http://        127.0.0.1:8080/…？name=Tom</p>
<p>应用层协议 ip地址 端口号 资源地址 参数列表</p>
<p>URL类</p>
<p>Java中提供了URL类来进行URL的相关操作</p>
<p>常见的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取相应的url值</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProtocol</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPort</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFile</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getQuery</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//建立与服务器的连接</span></span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection;</span><br><span class="line"><span class="comment">//通过connection创建输入流并进行相应的读写......</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://CV-Elevation.github.io">KuoZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">http://cv-elevation.github.io/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://CV-Elevation.github.io" target="_blank">KuoZ's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a><a class="post-meta__tags" href="/tags/TCP/">TCP</a><a class="post-meta__tags" href="/tags/Socket/">Socket</a><a class="post-meta__tags" href="/tags/URl/">URl</a></div><div class="post-share"><div class="social-share" data-image="/img/holo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/25/Maven/" title="Maven"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Maven</div></div><div class="info-2"><div class="info-item-1">Maven 概述 Maven是一款管理和构建Java项目的工具。基于POM（项目对象模型）的概念，通过一小段描述来管理项目 Maven坐标，唯一标识和定位一个项目 groupId：组织 artifactId：模块名称 version：版本 仓库：用于存储资源，管理jar包 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 远程仓库：一般由公司团队搭建的私有仓库 使用顺序：本地仓库&gt;远程仓库&gt;中央仓库 依赖管理 依赖：指当前项目运行所需的jar包 配置依赖（在IDEA中）  在pom.xml中编写标签 在标签中使用引入坐标 定义坐标的groupId，artifactId，version 点击刷新按钮，引入最新加入的坐标  12345678&lt;dependencyies&gt;	&lt;dependency&gt;    	&lt;groupId&gt;&lt;/groupId&gt;        &lt;artifactId&gt;&lt;/artifactId&gt;        &lt;version&gt;&lt;/version&gt;    &lt;/dependency&gt;    ...&lt;/dependencyies&gt; 依赖传递 依赖具有传递性   直接依赖：在当前项目中通过依赖配置建立的关系   间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源   排除依赖：主动断开依赖的资源，被排除的资源无需指定版本   123456&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;&lt;/groupId&gt;        &lt;artifactId&gt;&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;   依赖范围    scope值 主程序 测试程序 打包（运行） 范例     compile(默认) Y Y Y log4j   test - Y - junit   provided Y Y - servlet-api   runtime - Y Y jdbc驱动    可以通过下面的xml标签来设置依赖范围 1&lt;scope&gt;...&lt;/scope&gt; 生命周期 每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。（运行后面的阶段，前面的阶段也会运行） 生命周期阶段（常见）    常见生命周期阶段      clean 移除上一次构建生成的文件   compile 编译项目源代码   test 使用合适的单元测试框架运行测试   package 将编译后的文件打包，如：jar、war等   install 安装项目到本地仓库    </div></div></div></a><a class="pagination-related" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SpringBoot入门</div></div><div class="info-2"><div class="info-item-1">修改历史：  增加了Web入门的基础知识，完善了结构  SpringBoot入门 0.概述 本篇只是对springboot的基本使用的总结，学习视频-&gt;Day05-01. 请求响应-概述_哔哩哔哩_bilibili，使用postman进行调试。 1.Web入门 HTTP协议 概述 HTTP协议（HyperTextTransferProtocol），超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 特点：  TCP协议：面向连接，安全 基于请求-响应模型：一次请求对应一次响应 HTTP是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的  缺点：多次请求无法共享数据 优点：速度快    请求协议 请求数据包括三个部分： 请求行：请求数据第一行（请求方式，资源路径、协议） 请求头：第二行开始，格式key: value 请求体：POST请求，存放请求参数 两种请求方式对比：   请求方式-get：请求参数在请求行中，没有请求体。get请求大小是有限制的。   请求方式-post：请求参数在请求体中，post请求大小是没有限制的。   响应协议 响应数据包括三部分：   响应行：相应数据第一行（协议、状态码、描述）   响应头：key: value   响应体：存放响应数据   常见状态码：    状态码 描述     1xx 响应中   2xx 成功   3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理   4xx 客户端错误-处理发生错误，责任在客户端。如请求了不存在的资源、客户端未被授权、禁止访问   5xx 服务器错误-处理发生错误，责任在服务端。如程序抛出异常    目前主要了解：200 处理成功，404 请求资源不存在，500 服务器端异常 更多状态码见网站： 状态 | Status - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云 协议解析 服务器端要做的事情，一方面是要根据请求协议，解析浏览器发送的请求；另一方面是要根据响应协议，发送响应数据。 这种解析的工作较为固定，有不少Web服务器已经完成了这些工作，这样后端就只用关注业务逻辑的实现。常见的Web服务器有：Tomcat、IBM、jetty、WebLogic等 Tomcat服务器 具体内容暂时不用详细了解，SpringBoot已经内嵌了Tomcat服务器，所以不用专门下载。介绍在此省略 2.请求 此处请求的含义：后端接收来自浏览器端的请求指令，进行解析 简单参数 请求： GET指令：http://localhost:8080/simpleParam?name=miku&amp;age=16 POST指令：http://localhost:8080/simpleParam请求体：name=Miku&amp;age=16 Java代码： 原始方式： 12345678910//在原始的Web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(HttpServletRequest request) &#123;    String name = request.getParameter(&quot;name&quot;);//需要与请求参数的key保持一致    String ageStr = request.getParameter(&quot;age&quot;);//需要与请求参数的key保持一致    int age = Integer.parseInt(ageStr);    System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age);    return &quot;OK&quot;;&#125;//繁琐，并且需要进行手动类型转换 SpringBoot方式： 简单参数，参数名与形参列表名相同，定义形参即可接收参数 12345@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(int age,String name) &#123;    System.out.println(name + &quot;:&quot; + age);    return...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/05/JavaSE-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="JavaSE-File类与IO流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-05</div><div class="info-item-2">JavaSE-File类与IO流</div></div><div class="info-2"><div class="info-item-1">File类与IO流 File类的实例化 File类位于java.io包下，本章中涉及到的相关流也都声明在java.io包下。 File类的一个对象，对应于操作系统下的一个文件或文件目录（或文件夹） 123456      /*相对路径：相对于某一个文件目录来讲的相对位置。在IDEA中      * 在IDEA中，如果使用单元测试方法，相对路径是相对于当前的module      *          如果使用main方法，相对路径是相对于当前的project      * */      File file1 = new File(&quot;d:/io/test.txt&quot;);File file2 = new File(&quot;iotest&quot;); 12345678//public File(String parent, String child)//参数1：一定是一个文件目录//参数2：文件目录或者是一个文件      File file1 = new File(&quot;d:/io&quot;, &quot;test.txt&quot;);      //public File(File parent, String child)//参数1：一定是一个文件目录//参数2：文件目录或者是一个文件      File file2 = new File(file1,&quot;file3.txt&quot;); IO流 流(Stream)的分类：  流向不同：输入流、输出流 处理单位不同：字符流、字节流 角色不同：节点流、处理流     （抽象基类） 输入流 输出流     字节流 InputStream OutputStream   字符流 Reader Writer    FIleReader、FileWriter： 步骤：  创建读写的File对象 创建输入流或输出流 具体读入或写出  读入：read(char[] cbuffer) 写出：write(String str)/write(char[] cbuffer,0,len)   关闭流资源，防止内存泄露  使用举例：复制hello.txt文件到hello_copy.txt 123456789101112131415161718192021222324252627282930313233@Testpublic void test2()&#123;    FileReader fr = null;    FileWriter fw = null;    try &#123;        File file = new File(&quot;hello.txt&quot;);        File dest = new File(&quot;hello_copy.txt&quot;);        fr = new FileReader(file);        fw = new FileWriter(dest);        char[] cbuffer = new char[5];        int len;//记录每次读入字符个数        while ((len = fr.read(cbuffer)) != -1) &#123;            fw.write(cbuffer, 0, len);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        //关闭流资源        try &#123;            if(fr != null) fr.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        try &#123;            if(fw != null) fw.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;   ...</div></div></div></a><a class="pagination-related" href="/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/" title="JavaSE-Java8的两个重要特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">JavaSE-Java8的两个重要特性</div></div><div class="info-2"><div class="info-item-1">jdk8 新特性 函数式接口： 函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface) 为什么要有函数式接口？因为只有给函数式接口创建对象时，才可以使用lambda表达式。 java8中声明的函数式接口所在包：java.util.function 4个基本的函数式接口：（直接copy宋的课件）    函数式接口 称谓 参数类型 用途     Consumer&lt;T&gt;   消费型接口 T 对类型为T的对象应用操作，包含方法：  void accept(T t)     Supplier&lt;T&gt;   供给型接口 无 返回类型为T的对象，包含方法：T get()     Function&lt;T, R&gt;   函数型接口 T 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)     Predicate&lt;T&gt;   判断型接口 T 确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：boolean test(T t)      lambda表达式 lambda表达式怎么用？ 语法规则： -&gt;的左边：lambda的形参列表，参数的类型都可以省略。如果形参列表只有一个，则一对()也可以省略。 -&gt;的右边：lambda体，只有一行执行语句时，则一对{}可以省略，如果有return，则也要省略。 写法举例 1Comparator&lt;Integer&gt; com = (o1 , o2) -&gt; Integer.compara(o1,o2); lambda表达式的本质： 一方面，lambda表达式作为接口实现类的对象；另一方面，lambda表达式是匿名函数。 方法引用   方法引用可以看作是lambda表达式的进一步刻画。   当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。  当满足一定的条件是，我们还可以使用方法引用或构造器引用替换lambda表达式。    方法引用作为了函数式接口的实例。 格式：  对象 :: 实例方法 要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。 注意此方法b是非静态方法，需要对象调用。 类 :: 静态方法 要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个静态方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。 注意此方法b是静态方法，需要类调用。 类 :: 实例方法 要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第一个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。 注意此方法b是非静态方法，需要对象调用。但是形式上，写出对象a所属的类。  构造器引用 格式：类名 :: new 调用了类名对应的类中某一个确定的构造器。具体调用的是类中的哪一个构造器，取决于函数式接口的抽象方法的形参列表。 数组引用 格式：数组名 :: new StreamAPI Stream使用的流程  实例化 一系列的中间操作 执行终止操作  实例化： 三种方法： 方法一：通过集合 例如：对于List结构，直接使用list.stream()就能创建stream实例 方法二：通过数组 类似方法一，使用Arrays的静态方法stream()Arrays.stream(arr) 方法三：streamof public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流 例如： 12Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5);stream.forEach(System.out::println); 中间操作： 筛选与切片 123456789101112131415@Testpublic void test1() &#123;    //创建Stream    List&lt;Employee&gt; list = EmployeeData.empData();    Stream&lt;Employee&gt; stream = list.stream();    //filter(Predicate p) 过滤    stream.filter(e -&gt; e.getAge() &gt;...</div></div></div></a><a class="pagination-related" href="/2025/05/03/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="JavaSE-多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-03</div><div class="info-item-2">JavaSE-多线程</div></div><div class="info-2"><div class="info-item-1">多线程 概念 程序：为完成任务，用某种语言编写的一组指令的集合。 进程：程序的一次执行过程，或是正在内存中运行的应用程序。 线程：进程可以进一步细化为线程，是程序内部的一条执行路径。线程是CPU调度和执行的最小单位。   不同进程之间是不共享内存的。   进程之间的数据交换和通信的成本很高。   线程调度策略 分时调度：所有线程轮流使用CPU的使用权。并且平均分配每个线程占用CPU的时间 抢占式调度：让优先级高的线程以较大的概率优先使用CPU。如果线程的优先级相同，那么就会随机选一个。Java使用的是抢占式调度。 并行和并发：   并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务   并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。   也就是说，只有多核CPU才能并行，单核CPU本身就不能同时处理多个进程，只能把一段时间拆成多块来分别执行不同的进程   多线程的优点   提供应用程序的响应。   提高计算机CPU的利用率。   改善程序结构。将既长又复杂的进程拆为多个线程，独立运行，便于理解和修改。   多线程创建方式 方式一：继承Thread类的方式   创建一个继承于Thread类的子类   重写Thread类的run()   创建当前Thread的子类对象   通过对象调用start()   创建线程代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ThreadTest &#123;    public static void main(String[] args) &#123;        //方式1：创建子类        MyThread myThread = new MyThread();        myThread.start();        MyThread2 myThread2 = new MyThread2();        myThread2.start();        //方式2：创建匿名子类        new Thread()&#123;            @Override            public void run() &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    if(i%2==0)&#123;                        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);                    &#125;                &#125;            &#125;        &#125;.start();        new Thread()&#123;            @Override            public void run() &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    if(i%2!=0)&#123;                        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);                    &#125;                &#125;            &#125;        &#125;.start();    &#125;&#125;class MyThread extends Thread&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            if(i%2==0)&#123;                System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);            &#125;        &#125;    &#125;&#125;class MyThread2 extends...</div></div></div></a><a class="pagination-related" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-16</div><div class="info-item-2">JavaSE-反射</div></div><div class="info-2"><div class="info-item-1">学到Spring框架发现自己JavaSE的反射还没学，就滚过来学反射了。 黑马的这个课讲的真不错，比尚硅谷的那个要简练一些，很轻松就能听懂了。 反射  Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.  官方对反射的描述：反射允许以编程方式访问已加载类的字段、方法和构造函数的信息，并在安全限制范围内使用反射字段、方法和构造函数来操作其底层对应项。 总之反射就是要获取某个类的Class文件，并解剖出它的成员变量、成员方法和构造方法。 反射第一步：获取class 要获取class，总共有三种方法  Class.forName(&quot;全类名&quot;) 类名.class 对象.getClass()  说明：  1中的全类名指的是包名+类名，一般可以直接复制粘贴 3的getClass方法是Object里的方法，所以所有对象都可以调用 三种方法虽然都可以获取class，但是对应的阶段不同  1对应的是源代码阶段 2对应的是加载到内存的阶段，一般作参数传递 3对应的是运行时阶段，只有这个类的对象创建时才能使用    反射第二步：获得并使用构造方法、属性、成员方法 Java中有一个重要的思想就是万事万物皆对象，相应的，构造方法、属性和成员方法也有其对应的类 属性（Field类）、成员方法（Method类）、构造方法（Constructor） 1.获得并使用构造方法  Class类中的方法：  1234Constructor&lt;?&gt;[] getConstrutors();Constructor&lt;?&gt;[] getDeclaredConstrutors();Constructor&lt;?&gt; getConstrucor(参数列表（注意传参数对应的class对象）);Constructor&lt;?&gt; getDeclaredConstrucor(参数列表（注意传参数对应的class对象）);  使用Constructor类的方法，获得修饰符、名字、形参、对象创建  123public int getModifiers();//获得权限修饰符getName();getParameters();//获取参数列表 （IDEA底层的代码提示其实就是用的反射） 关于modifiers()    变量和类型 常量字段 值     public static final int ABSTRACT 1024   public static final int FINAL 16   public static final int INTERFACE 512   public static final int NATIVE 256   public static final int PRIVATE 2   public static final int PROTECTED 4   public static final int PUBLIC 1   public static final int STATIC 8   public static final int STRICT 2048   public static final int SYNCHRONIZED 32   public static final int TRANSIENT 128   public static final int VOLATILE 64    使用暴力反射进行对象的创建： 对于私有构造器的使用，注意使用setAccessible(true)跳过权限验证 123456Class clazz = Class.forName(&quot;User&quot;);Constructor cons = clazz.getDeclaredConstructor(String.class);System.out.println(cons.getModifiers());cons.setAccessible(true);//设定权限验证User user = (User)...</div></div></div></a><a class="pagination-related" href="/2025/05/03/JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API/" title="JavaSE-常用类与基础API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-03</div><div class="info-item-2">JavaSE-常用类与基础API</div></div><div class="info-2"><div class="info-item-1">常用类与基础API String类的深入认识 类的声明 123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,               Constable, ConstantDesc 以上是java源码中对于String类的声明，我们可以注意到： final：String是不可继承的 Serializable：可序列化的接口。凡是实现此接口的类的对象就可以通过网络或本地流进行数据的传输 comparable：凡是实现此接口的类，其对象都可以比较大小 内部声明的属性 jdk8及之前：private final char value[]；//存储字符串的容器 final：指明此value数组一旦初始化，其地址就不可变 jdk9开始，为节省内存空间做了优化：private final byte value[]//存储字符串的容器 字符串常量的存储位置  字符串常量都存储在字符串常量池(StringTable)中 字符串常量池不允许存储两个相同的常量 内存上，jdk7之前存放在方法区，jdk7之后存放在堆空间  String的不可变性  当对字符串进行重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有的位置修改 当对现有的字符串进行拼接时，需要重新开辟空间以保存拼接以后的字符串，不能在原有位置修改 当调用字符串的replace()替换现有的某个字符时，需要重新开辟空间保存修改以后的字符串，不能在原有位置修改  String实例化的两种方式 第一种：String s1 = &quot;hello&quot; 第二种：String s2 = new String(&quot;hello&quot;) 连接符：  常量+常量，存储在字符串常量池，返回字面量的地址。注：此时的常量可能是字面量，也可能是final修饰的常量 常量+变量或者变量+变量，通过new创建一个新的字符串，返回堆空间中此字符串对象的地址 调用字符串的intern()返回的是字符串常量池中字面量的地址 concat()：不管是常量还是变量，都返回一个新new的对象  String类构造器 12345678910111213// 无参构造（但实际无意义，因为 String 是不可变的）public String();// 通过字符串字面量构造（实际很少直接使用）public String(String original);// 通过字节数组构造（使用平台默认字符集解码）public String(byte[] bytes);// 通过字节数组构造（指定字符集解码）public String(byte[] bytes, String charsetName);// 通过字节数组的指定范围构造（offset 起始位置，length 长度）public String(byte[] bytes, int offset, int length);// 通过字符数组构造public String(char[] value);public String(char[] value, int offset, int count); Stirng类与常见的其它结构之间的转换  Stirng和基本数据类型之间的转换在包装类中已经写过，在此省略，详见 面向对象（高级）-包装类 String和char[]的转换  String–&gt;char[]：调用toCharArray()，char[] arr = str.toCharArray() char[]–&gt;String：调用String的构造器   String和byte[]的转换  编码：String–&gt;byte[]：调用getBytes()，()内可以用&quot;字符集名称&quot;指明字符集，不写则使用默认字符集 关于字符集：utf-8中汉字占3个字节，一个字母使用1个字节；gbk中一个汉字占2个字节，一个字母占1个字节。两者都向下兼容ascii码。 解码：byte[]–&gt;String：使用构造器，如果需要也要指定字符集 编码和解码指定字符集要相同，否则会乱码。    String常用的方法 String类包含有查找、截取、字符/字符数组、开头结尾、替换等常用API，内容很多且很啰嗦，建议在使用中学习，在此省略。 详细内容参见Java String 类 |...</div></div></div></a><a class="pagination-related" href="/2025/05/04/JavaSE-%E6%B3%9B%E5%9E%8B/" title="JavaSE-泛型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">JavaSE-泛型</div></div><div class="info-2"><div class="info-item-1">泛型 泛型在集合、比较器中的使用 1234567891011121314151617181920212223//泛型在List中的使用@Testpublic void test1()&#123;    //举例：将学生成绩保存在ArrayList中    //标准写法：    //ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    //jdk7的新特性：类型推断    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    list.add(56); //自动装箱    list.add(76);    list.add(88);    list.add(89);    //当添加非Integer类型数据时，编译不通过    //list.add(&quot;Tom&quot;);//编译报错    Iterator&lt;Integer&gt; iterator = list.iterator();    while(iterator.hasNext())&#123;        //不需要强转，直接可以获取添加时的元素的数据类型        Integer score = iterator.next();        System.out.println(score);    &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536//泛型在Map中的使用@Testpublic void test2()&#123;    HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;Tom&quot;,67);    map.put(&quot;Jim&quot;,56);    map.put(&quot;Rose&quot;,88);    //编译不通过    //        map.put(67,&quot;Jack&quot;);    //遍历key集    Set&lt;String&gt; keySet = map.keySet();    for(String str:keySet)&#123;        System.out.println(str);    &#125;    //遍历value集    Collection&lt;Integer&gt; values = map.values();    Iterator&lt;Integer&gt; iterator = values.iterator();    while(iterator.hasNext())&#123;        Integer value = iterator.next();        System.out.println(value);    &#125;    //遍历entry集    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();    while(iterator1.hasNext())&#123;        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();        String key = entry.getKey();        Integer value = entry.getValue();        System.out.println(key + &quot;:&quot; + value);    &#125;&#125; 1234567891011121314151617181920class CircleComparator1 implements Comparator&lt;Circle&gt; &#123;    @Override    public int compare(Circle o1, Circle o2) &#123;        //不再需要强制类型转换，代码更简洁        return Double.compare(o1.getRadius(),...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KuoZ</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CV-Elevation"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这是一个专属于我（KuoZ）的空间，它用来记录我的学习笔记、硬件或软件开发中的经验、还有吹水等等内容。本网站使用HEXO框架搭建。旧的两篇博客在博客园https://www.cnblogs.com/pulse1454</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">网络编程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">网络通信协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E5%92%8CUDP%E5%8D%8F%E8%AE%AE"><span class="toc-text">TCP协议和UDP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">TCP的Socket网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">UDP网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL%E7%BC%96%E7%A8%8B"><span class="toc-text">URL编程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" title="SpringMVC之登录校验">SpringMVC之登录校验</a><time datetime="2025-07-13T07:21:29.000Z" title="发表于 2025-07-13 15:21:29">2025-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Redis/" title="Redis">Redis</a><time datetime="2025-07-04T10:00:54.000Z" title="发表于 2025-07-04 18:00:54">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/" title="Mybatis入门">Mybatis入门</a><time datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门">SpringBoot入门</a><time datetime="2025-06-03T14:30:09.000Z" title="发表于 2025-06-03 22:30:09">2025-06-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/miku2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By KuoZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>