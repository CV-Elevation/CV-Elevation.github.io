<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaSE-Java8的两个重要特性 | KuoZ's blog</title><meta name="author" content="KuoZ"><meta name="copyright" content="KuoZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="jdk8 新特性 函数式接口： 函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface) 为什么要有函数式接口？因为只有给函数式接口创建对象时，才可以使用lambda表达式。 java8中声明的函数式接口所在包：java.util.function 4个基本的函数式接口：（直接copy宋的课件）    函数式接口 称谓 参数类型 用途">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE-Java8的两个重要特性">
<meta property="og:url" content="http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="KuoZ&#39;s blog">
<meta property="og:description" content="jdk8 新特性 函数式接口： 函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface) 为什么要有函数式接口？因为只有给函数式接口创建对象时，才可以使用lambda表达式。 java8中声明的函数式接口所在包：java.util.function 4个基本的函数式接口：（直接copy宋的课件）    函数式接口 称谓 参数类型 用途">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cv-elevation.github.io/img/holo.jpg">
<meta property="article:published_time" content="2025-05-06T13:14:11.000Z">
<meta property="article:modified_time" content="2025-06-28T12:38:45.145Z">
<meta property="article:author" content="KuoZ">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cv-elevation.github.io/img/holo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaSE-Java8的两个重要特性",
  "url": "http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/",
  "image": "http://cv-elevation.github.io/img/holo.jpg",
  "datePublished": "2025-05-06T13:14:11.000Z",
  "dateModified": "2025-06-28T12:38:45.145Z",
  "author": [
    {
      "@type": "Person",
      "name": "KuoZ",
      "url": "http://cv-elevation.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/Myfavicon2.ico"><link rel="canonical" href="http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE-Java8的两个重要特性',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/miku2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KuoZ's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JavaSE-Java8的两个重要特性</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JavaSE-Java8的两个重要特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-06T13:14:11.000Z" title="发表于 2025-05-06 21:14:11">2025-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-28T12:38:45.145Z" title="更新于 2025-06-28 20:38:45">2025-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>5分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>jdk8 新特性</h1>
<h2 id="函数式接口：">函数式接口：</h2>
<p>函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface)</p>
<p>为什么要有函数式接口？因为只有给函数式接口创建对象时，才可以使用lambda表达式。</p>
<p>java8中声明的函数式接口所在包：java.util.function</p>
<p>4个基本的函数式接口：（直接copy宋的课件）</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>称谓</th>
<th>参数类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Consumer&lt;T&gt;  </code></td>
<td>消费型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)  </code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;  </code></td>
<td>供给型接口</td>
<td>无</td>
<td>返回类型为T的对象，包含方法：<code>T get()  </code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;  </code></td>
<td>函数型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)  </code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;  </code></td>
<td>判断型接口</td>
<td>T</td>
<td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)  </code></td>
</tr>
</tbody>
</table>
<h2 id="lambda表达式">lambda表达式</h2>
<p>lambda表达式怎么用？</p>
<p>语法规则：</p>
<p>-&gt;的左边：lambda的形参列表，参数的类型都可以省略。如果形参列表只有一个，则一对()也可以省略。</p>
<p>-&gt;的右边：lambda体，只有一行执行语句时，则一对{}可以省略，如果有return，则也要省略。</p>
<p>写法举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (o1 , o2) -&gt; Integer.compara(o1,o2);</span><br></pre></td></tr></table></figure>
<p>lambda表达式的本质：</p>
<p>一方面，lambda表达式作为接口实现类的对象；另一方面，lambda表达式是匿名函数。</p>
<h2 id="方法引用">方法引用</h2>
<ul>
<li>
<p>方法引用可以看作是lambda表达式的进一步刻画。</p>
</li>
<li>
<p>当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。</p>
<ul>
<li>当满足一定的条件是，我们还可以使用方法引用或构造器引用替换lambda表达式。</li>
</ul>
</li>
</ul>
<p>方法引用作为了函数式接口的实例。</p>
<p>格式：</p>
<ol>
<li>对象 :: 实例方法<br>
要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。<br>
注意此方法b是非静态方法，需要对象调用。</li>
<li>类 :: 静态方法<br>
要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个静态方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。<br>
注意此方法b是静态方法，需要类调用。</li>
<li>类 :: 实例方法<br>
要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第一个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。<br>
注意此方法b是非静态方法，需要对象调用。但是形式上，写出对象a所属的类。</li>
</ol>
<p><strong>构造器引用</strong></p>
<p>格式：<code>类名 :: new</code></p>
<p>调用了类名对应的类中某一个确定的构造器。具体调用的是类中的哪一个构造器，取决于函数式接口的抽象方法的形参列表。</p>
<p><strong>数组引用</strong></p>
<p>格式：<code>数组名 :: new</code></p>
<h2 id="StreamAPI">StreamAPI</h2>
<p>Stream使用的流程</p>
<ol>
<li>实例化</li>
<li>一系列的中间操作</li>
<li>执行终止操作</li>
</ol>
<p><strong>实例化：</strong></p>
<p>三种方法：</p>
<p>方法一：通过集合</p>
<p>例如：对于List结构，直接使用<code>list.stream()</code>就能创建stream实例</p>
<p>方法二：通过数组</p>
<p>类似方法一，使用Arrays的静态方法stream()<code>Arrays.stream(arr)</code></p>
<p>方法三：streamof</p>
<p><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) </code>: 返回一个流</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><strong>中间操作：</strong></p>
<p>筛选与切片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建Stream</span></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">//filter(Predicate p) 过滤</span></span><br><span class="line">    stream.filter(e -&gt; e.getAge() &gt; <span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//limit(long maxSize) 限制元素个数</span></span><br><span class="line">    list.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//skip(long n) 跳过前n个元素</span></span><br><span class="line">    list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//distinct() 去掉重复元素</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">22</span>,<span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//map(Function f) 映射</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//        list.stream().map(s -&gt; s.toUpperCase()).forEach(System.out::print);</span></span><br><span class="line">        list.stream().map(String :: toUpperCase).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//sorted(Comparator c) 排序</span></span><br><span class="line">    Integer [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.stream(arr).sorted((o1, o2) -&gt; o2-o1).forEach(System.out::print);</span><br><span class="line"></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    list.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>终止操作：</strong></p>
<p>匹配与查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    <span class="comment">//allMatch(Predicate p) 检查是否匹配所有元素</span></span><br><span class="line">    System.out.println(list.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">20</span>));</span><br><span class="line">    <span class="comment">//anyMatch(Predicate p) 检查是否至少匹配一个元素</span></span><br><span class="line">    System.out.println(list.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="number">20</span>));</span><br><span class="line">    <span class="comment">//findFirst() 返回第一个元素</span></span><br><span class="line">    System.out.println(list.stream().findFirst());</span><br><span class="line">    <span class="comment">//forEach(Consumer c) 迭代</span></span><br><span class="line">    list.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归约</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    <span class="comment">//reduce(T identity, BinaryOperator b) 归约</span></span><br><span class="line">    System.out.println(list.stream().map(Employee::getAge).reduce(<span class="number">0</span>,Integer::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.empData();</span><br><span class="line">    <span class="comment">//collect(Collectors.toList()) 收集到List</span></span><br><span class="line">    List&lt;Integer&gt; list1 = list.stream().map(Employee::getAge).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//collect(Collectors.toSet()) 收集到Set</span></span><br><span class="line">    Set&lt;Integer&gt; set = list.stream().map(Employee::getAge).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//collect(Collectors.toMap()) 收集到Map</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = list.stream().map(Employee::getAge).collect(Collectors.toMap(e -&gt; e, e -&gt; e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaSE学习先到这里，中间跳了集合源码、网络编程、反射的内容，之后的考试是真的有点多（光电你罪该万死，数电、单片机、量子力学、热统都让我一个学期考还一堆实验课Щ(◣д◢)Щ），后续打算边用边学，保持写代码的习惯。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://CV-Elevation.github.io">KuoZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/">http://cv-elevation.github.io/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://CV-Elevation.github.io" target="_blank">KuoZ's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post-share"><div class="social-share" data-image="/img/holo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/05/JavaSE-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="JavaSE-File类与IO流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaSE-File类与IO流</div></div><div class="info-2"><div class="info-item-1">File类与IO流 File类的实例化 File类位于java.io包下，本章中涉及到的相关流也都声明在java.io包下。 File类的一个对象，对应于操作系统下的一个文件或文件目录（或文件夹） 123456      /*相对路径：相对于某一个文件目录来讲的相对位置。在IDEA中      * 在IDEA中，如果使用单元测试方法，相对路径是相对于当前的module      *          如果使用main方法，相对路径是相对于当前的project      * */      File file1 = new File(&quot;d:/io/test.txt&quot;);File file2 = new File(&quot;iotest&quot;); 12345678//public File(String parent, String child)//参数1：一定是一个文件目录//参数2：文件目录或者是一个文件      File file1 = new File(&quot;d:/io&quot;, &quot;test.txt&quot;);      //public File(File parent, String child)//参数1：一定是一个文件目录//参数2：文件目录或者是一个文件      File file2 = new File(file1,&quot;file3.txt&quot;); IO流 流(Stream)的分类：  流向不同：输入流、输出流 处理单位不同：字符流、字节流 角色不同：节点流、处理流     （抽象基类） 输入流 输出流     字节流 InputStream OutputStream   字符流 Reader Writer    FIleReader、FileWriter： 步骤：  创建读写的File对象 创建输入流或输出流 具体读入或写出  读入：read(char[] cbuffer) 写出：write(String str)/write(char[] cbuffer,0,len)   关闭流资源，防止内存泄露  使用举例：复制hello.txt文件到hello_copy.txt 123456789101112131415161718192021222324252627282930313233@Testpublic void test2()&#123;    FileReader fr = null;    FileWriter fw = null;    try &#123;        File file = new File(&quot;hello.txt&quot;);        File dest = new File(&quot;hello_copy.txt&quot;);        fr = new FileReader(file);        fw = new FileWriter(dest);        char[] cbuffer = new char[5];        int len;//记录每次读入字符个数        while ((len = fr.read(cbuffer)) != -1) &#123;            fw.write(cbuffer, 0, len);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        //关闭流资源        try &#123;            if(fr != null) fr.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        try &#123;            if(fw != null) fw.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;   ...</div></div></div></a><a class="pagination-related" href="/2025/05/24/MySQL/" title="MySQL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL</div></div><div class="info-2"><div class="info-item-1">修改历史：  2025-07-01 修复了sql语句的代码快无法高亮的问题  MySQL-基础 数据库管理系统DBMS MySQL数据模型 客户端-&gt;DBMS-&gt;多个数据库-&gt;多个二维表 SQL语句 DDL(Data Definition Language)数据定义语言（数据库、表、字段） DML(Data Manipulation Language)数据操作语言 DQL(Data Query Language)数据查询语言 DCL(Data Control Language)数据控制语言，管理数据库用户，控制数据库的访问权限 DDL-数据定义 数据库操作    大类 语句 作用     查询 show databases 查询所有数据库    select database() 查询当前数据库   创建 create database [if not exists] 数据库名 （如果不存在）创建一个数据库   使用 use 数据库名; 使用数据库   删除 drop database [if exists] 数据库名 删除数据库    表操作-查询    语句 作用     show tables; 查询当前数据库所有表   desc 表名; 查询表结构   show create table 表名; 查询指定表的建表语句    表操作-创建 12345create table 表名(	字段1 字段类型 [约束] [comment 字段1注释],    ……    字段n 字段类型 [约束] [comment 字段1注释])[comment 表注释]; 关于约束：    约束 描述 关键字     非空约束 限制字段值不能为null not null   唯一约束 保证字段所有数据唯一 unique   主键约束 主键是一行数据的唯一标识，非空且唯一 primary key   默认约束 字段未指定值则用默认值 default   外键约束 让两张表的数据建立连接 foreign key    字段数据类型 数值    类型 大小（byte） 描述     tinyint 1 小整数值   smallint 2 大整数值   mediumint 3 大整数值   int 4 大整数值   bigint 8 极大整数值   float 4 单精度浮点数   double 8 双精度浮点数   decimal  小数值（精确定点数)    例如double,需使用double(整个数的长度，小数部分长度) 字符串    类型 描述     char 定长字符串   varchar 变长字符串   tinyblob 不超过255个字符的二进制数据   tinytext 短文本字符串   blob 二进制形式的长文本数据   text 长文本数据   midiumblob 二进制形式的中等长度文本数据   midiumtext 中等长度文本数据   longblob 二进制形式的极大文本数据   longtext 极大文本数据    日期时间     大小 范围 格式 描述     date 3 1000-01-01至9999-12-31 YYYY-MM-DD 日期值   time 3 -838:59:59至838:59:59 HH:MM:SS 时间值或持续时间   year 1 1901至2155 YYYY 年份值   datatime 8 1000-01-01 00:00:00至9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值   timestamp 4 1970-01-01 00:00:01至2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳    修改、删除表结构 语言可以不掌握，但是要会图形化操作 DML-数据操作 添加数据： insert into 表名(字段1，字段2，……) values(值1,值2,……);  字符串应该和日期型数据应该包含在引号内 插入的数据大小，应该在字段的规定范围内  修改数据 update 表名 set 字段名1=值1,字段名2=值2,…[where 条件] 删除数据 delete from 表名 [where 条件] DQL-数据查询 基本查询： 基本查询 select 字段列表 from 表名; select * from 表名;（不建议在开发中使用这种方式，因为不直观） 起别名 select 字段 as ‘别名’ from 表名;as可省略 去重 select distinct 字段名称 from 表名; 条件查询： select 字段列表 from 表名...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/05/JavaSE-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="JavaSE-File类与IO流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-05</div><div class="info-item-2">JavaSE-File类与IO流</div></div><div class="info-2"><div class="info-item-1">File类与IO流 File类的实例化 File类位于java.io包下，本章中涉及到的相关流也都声明在java.io包下。 File类的一个对象，对应于操作系统下的一个文件或文件目录（或文件夹） 123456      /*相对路径：相对于某一个文件目录来讲的相对位置。在IDEA中      * 在IDEA中，如果使用单元测试方法，相对路径是相对于当前的module      *          如果使用main方法，相对路径是相对于当前的project      * */      File file1 = new File(&quot;d:/io/test.txt&quot;);File file2 = new File(&quot;iotest&quot;); 12345678//public File(String parent, String child)//参数1：一定是一个文件目录//参数2：文件目录或者是一个文件      File file1 = new File(&quot;d:/io&quot;, &quot;test.txt&quot;);      //public File(File parent, String child)//参数1：一定是一个文件目录//参数2：文件目录或者是一个文件      File file2 = new File(file1,&quot;file3.txt&quot;); IO流 流(Stream)的分类：  流向不同：输入流、输出流 处理单位不同：字符流、字节流 角色不同：节点流、处理流     （抽象基类） 输入流 输出流     字节流 InputStream OutputStream   字符流 Reader Writer    FIleReader、FileWriter： 步骤：  创建读写的File对象 创建输入流或输出流 具体读入或写出  读入：read(char[] cbuffer) 写出：write(String str)/write(char[] cbuffer,0,len)   关闭流资源，防止内存泄露  使用举例：复制hello.txt文件到hello_copy.txt 123456789101112131415161718192021222324252627282930313233@Testpublic void test2()&#123;    FileReader fr = null;    FileWriter fw = null;    try &#123;        File file = new File(&quot;hello.txt&quot;);        File dest = new File(&quot;hello_copy.txt&quot;);        fr = new FileReader(file);        fw = new FileWriter(dest);        char[] cbuffer = new char[5];        int len;//记录每次读入字符个数        while ((len = fr.read(cbuffer)) != -1) &#123;            fw.write(cbuffer, 0, len);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        //关闭流资源        try &#123;            if(fr != null) fr.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        try &#123;            if(fw != null) fw.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;   ...</div></div></div></a><a class="pagination-related" href="/2025/05/03/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="JavaSE-多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-03</div><div class="info-item-2">JavaSE-多线程</div></div><div class="info-2"><div class="info-item-1">多线程 概念 程序：为完成任务，用某种语言编写的一组指令的集合。 进程：程序的一次执行过程，或是正在内存中运行的应用程序。 线程：进程可以进一步细化为线程，是程序内部的一条执行路径。线程是CPU调度和执行的最小单位。   不同进程之间是不共享内存的。   进程之间的数据交换和通信的成本很高。   线程调度策略 分时调度：所有线程轮流使用CPU的使用权。并且平均分配每个线程占用CPU的时间 抢占式调度：让优先级高的线程以较大的概率优先使用CPU。如果线程的优先级相同，那么就会随机选一个。Java使用的是抢占式调度。 并行和并发：   并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务   并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。   也就是说，只有多核CPU才能并行，单核CPU本身就不能同时处理多个进程，只能把一段时间拆成多块来分别执行不同的进程   多线程的优点   提供应用程序的响应。   提高计算机CPU的利用率。   改善程序结构。将既长又复杂的进程拆为多个线程，独立运行，便于理解和修改。   多线程创建方式 方式一：继承Thread类的方式   创建一个继承于Thread类的子类   重写Thread类的run()   创建当前Thread的子类对象   通过对象调用start()   创建线程代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ThreadTest &#123;    public static void main(String[] args) &#123;        //方式1：创建子类        MyThread myThread = new MyThread();        myThread.start();        MyThread2 myThread2 = new MyThread2();        myThread2.start();        //方式2：创建匿名子类        new Thread()&#123;            @Override            public void run() &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    if(i%2==0)&#123;                        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);                    &#125;                &#125;            &#125;        &#125;.start();        new Thread()&#123;            @Override            public void run() &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    if(i%2!=0)&#123;                        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);                    &#125;                &#125;            &#125;        &#125;.start();    &#125;&#125;class MyThread extends Thread&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            if(i%2==0)&#123;                System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);            &#125;        &#125;    &#125;&#125;class MyThread2 extends...</div></div></div></a><a class="pagination-related" href="/2025/05/04/JavaSE-%E6%B3%9B%E5%9E%8B/" title="JavaSE-泛型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">JavaSE-泛型</div></div><div class="info-2"><div class="info-item-1">泛型 泛型在集合、比较器中的使用 1234567891011121314151617181920212223//泛型在List中的使用@Testpublic void test1()&#123;    //举例：将学生成绩保存在ArrayList中    //标准写法：    //ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    //jdk7的新特性：类型推断    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    list.add(56); //自动装箱    list.add(76);    list.add(88);    list.add(89);    //当添加非Integer类型数据时，编译不通过    //list.add(&quot;Tom&quot;);//编译报错    Iterator&lt;Integer&gt; iterator = list.iterator();    while(iterator.hasNext())&#123;        //不需要强转，直接可以获取添加时的元素的数据类型        Integer score = iterator.next();        System.out.println(score);    &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536//泛型在Map中的使用@Testpublic void test2()&#123;    HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;Tom&quot;,67);    map.put(&quot;Jim&quot;,56);    map.put(&quot;Rose&quot;,88);    //编译不通过    //        map.put(67,&quot;Jack&quot;);    //遍历key集    Set&lt;String&gt; keySet = map.keySet();    for(String str:keySet)&#123;        System.out.println(str);    &#125;    //遍历value集    Collection&lt;Integer&gt; values = map.values();    Iterator&lt;Integer&gt; iterator = values.iterator();    while(iterator.hasNext())&#123;        Integer value = iterator.next();        System.out.println(value);    &#125;    //遍历entry集    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();    while(iterator1.hasNext())&#123;        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();        String key = entry.getKey();        Integer value = entry.getValue();        System.out.println(key + &quot;:&quot; + value);    &#125;&#125; 1234567891011121314151617181920class CircleComparator1 implements Comparator&lt;Circle&gt; &#123;    @Override    public int compare(Circle o1, Circle o2) &#123;        //不再需要强制类型转换，代码更简洁        return Double.compare(o1.getRadius(),...</div></div></div></a><a class="pagination-related" href="/2025/05/03/JavaSE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API/" title="JavaSE-常用类与基础API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-03</div><div class="info-item-2">JavaSE-常用类与基础API</div></div><div class="info-2"><div class="info-item-1">常用类与基础API String类的深入认识 类的声明 123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,               Constable, ConstantDesc 以上是java源码中对于String类的声明，我们可以注意到： final：String是不可继承的 Serializable：可序列化的接口。凡是实现此接口的类的对象就可以通过网络或本地流进行数据的传输 comparable：凡是实现此接口的类，其对象都可以比较大小 内部声明的属性 jdk8及之前：private final char value[]；//存储字符串的容器 final：指明此value数组一旦初始化，其地址就不可变 jdk9开始，为节省内存空间做了优化：private final byte value[]//存储字符串的容器 字符串常量的存储位置  字符串常量都存储在字符串常量池(StringTable)中 字符串常量池不允许存储两个相同的常量 内存上，jdk7之前存放在方法区，jdk7之后存放在堆空间  String的不可变性  当对字符串进行重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有的位置修改 当对现有的字符串进行拼接时，需要重新开辟空间以保存拼接以后的字符串，不能在原有位置修改 当调用字符串的replace()替换现有的某个字符时，需要重新开辟空间保存修改以后的字符串，不能在原有位置修改  String实例化的两种方式 第一种：String s1 = &quot;hello&quot; 第二种：String s2 = new String(&quot;hello&quot;) 连接符：  常量+常量，存储在字符串常量池，返回字面量的地址。注：此时的常量可能是字面量，也可能是final修饰的常量 常量+变量或者变量+变量，通过new创建一个新的字符串，返回堆空间中此字符串对象的地址 调用字符串的intern()返回的是字符串常量池中字面量的地址 concat()：不管是常量还是变量，都返回一个新new的对象  String类构造器 12345678910111213// 无参构造（但实际无意义，因为 String 是不可变的）public String();// 通过字符串字面量构造（实际很少直接使用）public String(String original);// 通过字节数组构造（使用平台默认字符集解码）public String(byte[] bytes);// 通过字节数组构造（指定字符集解码）public String(byte[] bytes, String charsetName);// 通过字节数组的指定范围构造（offset 起始位置，length 长度）public String(byte[] bytes, int offset, int length);// 通过字符数组构造public String(char[] value);public String(char[] value, int offset, int count); Stirng类与常见的其它结构之间的转换  Stirng和基本数据类型之间的转换在包装类中已经写过，在此省略，详见 面向对象（高级）-包装类 String和char[]的转换  String–&gt;char[]：调用toCharArray()，char[] arr = str.toCharArray() char[]–&gt;String：调用String的构造器   String和byte[]的转换  编码：String–&gt;byte[]：调用getBytes()，()内可以用&quot;字符集名称&quot;指明字符集，不写则使用默认字符集 关于字符集：utf-8中汉字占3个字节，一个字母使用1个字节；gbk中一个汉字占2个字节，一个字母占1个字节。两者都向下兼容ascii码。 解码：byte[]–&gt;String：使用构造器，如果需要也要指定字符集 编码和解码指定字符集要相同，否则会乱码。    String常用的方法 String类包含有查找、截取、字符/字符数组、开头结尾、替换等常用API，内容很多且很啰嗦，建议在使用中学习，在此省略。 详细内容参见Java String 类 |...</div></div></div></a><a class="pagination-related" href="/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="JavaSE-网络编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-27</div><div class="info-item-2">JavaSE-网络编程</div></div><div class="info-2"><div class="info-item-1">网络编程 软件架构： CS架构：客户端-服务器 BS架构：浏览器-服务器 不过现在的很多软件都是一种混合开发，就是将CS架构和BS架构融合起来。 网络编程三要素 如何准确定位一台或多态主机：使用IP地址 如何定位主机上的特定的应用：使用端口号 如何可靠、高效地进行数据传输：规范通信协议 IP地址 IP地址：网络中的一台计算机设备做唯一编号 IP地址分类： 分类方式一： IPv4：占用4个字节，表示为a.b.c.d的形式，以点分十进制表示 IPv6：占用16个字节 分类方式二： 公网地址（万维网使用）和私网地址（局域网使用）192.168.开头的就是私有地址 本地回路地址：127.0.0.1 域名：便捷地记录ip地址 www.baidu.com kuoz.top 域名使用中通过DNS解析成IP再进行访问的 端口号 端口号可以唯一标识主机中的进程 不同的进程分配不同的端口号 范围：0~65535 网络通信协议 OSI模型：过于理想化，没能实现 TCP/IP：分为应用层、传输层、网络层、物理+数据链路层 InetAddress类 InetAddress类的一个实例就代表一个具体的ip地址 实例化方式： InetAddress getByName(String host) InetAddress getLocalHost() TCP协议和UDP协议 计算机网络的重要重要指示，在此处简要了解。 TCP的Socket网络编程 网络上具有唯一标识的IP地址和端口号的组合，唯一可识别的标识符套接字（Socket） 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void client() throws IOException &#123;    //创建Socket实例    int port = 8888;    InetAddress address = InetAddress.getByName(&quot;10.10.208.62&quot;);    Socket socket = new Socket(address, port);    //通过Socket创建输出流    OutputStream os = socket.getOutputStream();    //发送数据    os.write(&quot;嗨嗨嗨, 服务器我来辣!&quot;.getBytes());    //关闭Socket及相关流    os.close();    socket.close();&#125;@Testpublic void server() throws IOException &#123;    //创建serverSocket实例    int port = 8888;    ServerSocket serverSocket = new ServerSocket(port);    //接收来自于客户端的Socket    Socket socket = serverSocket.accept();    System.out.println(&quot;客户端连接成功，等待接收数据...&quot;);    System.out.println(&quot;收到了来自&quot;+socket.getInetAddress().getHostAddress()+&quot;的连接&quot;);    //通过Socket创建输入流    InputStream is = socket.getInputStream();    //读写过程    byte[] buffer = new byte[5];    ByteArrayOutputStream baos = new ByteArrayOutputStream();    int len;    while((len = is.read(buffer)) != -1) &#123;        //当byte太小时，这里中文会因为中间被截断而出乱码，通过baos来解决        //String message = new String(buffer, 0, len);        //解决方法        baos.write(buffer, 0, len);    &#125;    System.out.print(baos.toString());    System.out.print(&quot;\n接收完毕&quot;);    //关闭Socket和相关流    is.close();   ...</div></div></div></a><a class="pagination-related" href="/2025/05/04/JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="JavaSE-集合框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">JavaSE-集合框架</div></div><div class="info-2"><div class="info-item-1">集合框架 Java集合框架体系 java.util.Collection：存储一个一个的数据  子接口：List：存储有序、可重复的数据（“动态”数组）  ArrayList(主要实现类)、LinkedList、Vector   子接口：Set：存储无序、不可重复的数据（中学数学中的集合）  HashSet(主要实现类)、LinkedHashSet、TreeSet    java.util.Map：存储一对一对的数据（key-value键值对，类似于中学数学的函数）    HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties    Collection接口 常用方法 Collection中有15个常用的方法，其实现类可以使用 集合和数组的转换 集合–&gt;数组toArray 数组–&gt;集合调用Arrays的静态方法asList 向Collection中添加元素的要求：元素所属类一定要重写equals方法 因为Collection的相关方法（contains、remove）在使用时要调用equals方法 遍历 iterator迭代器： iterator迭代器常用来遍历集合元素 123while(iterator.hasNext())&#123;    System.out.println(iterator.next());//next()指针下移，将下移以后的元素返回&#125; （补充）增强for循环： 作用：遍历数组和集合 格式： 123for(要遍历的集合或数组的元素类型 临时变量 : 要遍历的集合或数组变量)&#123;    操作临时变量输出&#125; 说明：  针对于集合来讲，增强for循环底层仍使用的是迭代器 增强for循环执行的过程中，是将集合或数组中的元素依次赋值给临时变量，注意，循环体中对临时变量的修改，可能不会导致原有集合或数组元素的修改  List接口 常用方法 第一部分： Collection中声明的15个方法 第二部分：因为LIst是有序的，所以会增加一些索引方法 常用方法大致可分为：增、删、改、查、插、长度、遍历    方法声明 说明     add(Object ele) 添加ele元素   addAll(Collection eles) 将eles中的所有元素添加进来   remove(Object ele) 删除指定索引的元素，并返回此元素   remove(int index) 删除指定索引的元素，并返回此元素   set(int index , Object ele) 设置指定索引位置的元素为ele   get(int index) 获取指定索引元素   add(int index , Object ele) 在指定索引插入ele元素   addAll(int index , Collection...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KuoZ</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CV-Elevation"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这是一个专属于我（KuoZ）的空间，它用来记录我的学习笔记、硬件或软件开发中的经验、还有吹水等等内容。本网站使用HEXO框架搭建。旧的两篇博客在博客园https://www.cnblogs.com/pulse1454</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">jdk8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-text">函数式接口：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StreamAPI"><span class="toc-text">StreamAPI</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Redis/" title="Redis">Redis</a><time datetime="2025-07-04T10:00:54.000Z" title="发表于 2025-07-04 18:00:54">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/" title="Mybatis入门">Mybatis入门</a><time datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门">SpringBoot入门</a><time datetime="2025-06-03T14:30:09.000Z" title="发表于 2025-06-03 22:30:09">2025-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="JavaSE-网络编程">JavaSE-网络编程</a><time datetime="2025-05-27T10:21:16.000Z" title="发表于 2025-05-27 18:21:16">2025-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/Maven/" title="Maven">Maven</a><time datetime="2025-05-25T12:43:27.000Z" title="发表于 2025-05-25 20:43:27">2025-05-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/miku2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By KuoZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>