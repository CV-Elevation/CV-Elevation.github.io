<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Mybatis入门 | KuoZ's blog</title><meta name="author" content="KuoZ"><meta name="copyright" content="KuoZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="修改历史：  2025-06-28 修改了部分错误，优化了文档结构 2025-07-01 修复了代码块sql语句无法高亮的问题  Mybatis入门  0.序 Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili。 1.入门 快速入门 开启一个模版程序，实现使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Mybatis入门">
<meta property="og:url" content="http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="KuoZ&#39;s blog">
<meta property="og:description" content="修改历史：  2025-06-28 修改了部分错误，优化了文档结构 2025-07-01 修复了代码块sql语句无法高亮的问题  Mybatis入门  0.序 Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili。 1.入门 快速入门 开启一个模版程序，实现使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cv-elevation.github.io/img/holo.jpg">
<meta property="article:published_time" content="2025-06-08T12:02:16.000Z">
<meta property="article:modified_time" content="2025-07-01T09:29:27.924Z">
<meta property="article:author" content="KuoZ">
<meta property="article:tag" content="Mybatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cv-elevation.github.io/img/holo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mybatis入门",
  "url": "http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/",
  "image": "http://cv-elevation.github.io/img/holo.jpg",
  "datePublished": "2025-06-08T12:02:16.000Z",
  "dateModified": "2025-07-01T09:29:27.924Z",
  "author": [
    {
      "@type": "Person",
      "name": "KuoZ",
      "url": "http://cv-elevation.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/Myfavicon2.ico"><link rel="canonical" href="http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mybatis入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/miku2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KuoZ's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Mybatis入门</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Mybatis入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-01T09:29:27.924Z" title="更新于 2025-07-01 17:29:27">2025-07-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>修改历史：</p>
<ul>
<li>2025-06-28 修改了部分错误，优化了文档结构</li>
<li>2025-07-01 修复了代码块sql语句无法高亮的问题</li>
</ul>
<h1>Mybatis入门</h1>
<img src="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/Mybatis.jpg" width="40%">
<h2 id="0-序">0.序</h2>
<p>Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=117">Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili</a>。</p>
<h2 id="1-入门">1.入门</h2>
<p><strong>快速入门</strong></p>
<p>开启一个模版程序，实现使用Mybatis查询所有用户数据</p>
<ol>
<li>准备工作（创建springboot文件，定义实际类User，数据库表user）</li>
<li>添加mybatis相关依赖，配置mybatis（数据库连接信息）</li>
<li>编写SQL语句（注解/XML）</li>
</ol>
<p>具体操作流程如下：</p>
<ul>
<li>
<p>创建springboot文件：与springboot入门中的创建方法基本一致，注意要勾选Mybatis Framework和MySQL Driver依赖。</p>
</li>
<li>
<p>定义实际类：实际类要与数据库中user的字段保证一致，常见的几种类型对应：int-&gt;Integer，varchar-&gt;String，tinyint-&gt;Short，主要使用其包装类。同时声明相应的getset方法、构造器、toString方法。</p>
</li>
<li>
<p>在properties配置文件中加入以下内容，格式比较固定，url要根据相应的数据库名称确定，密码设定为自己的密码</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写SQL语句（注解/XML）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//在运行时，MyBatis会扫描这个接口，并为其生成一个实现类对象（代理对象），并交给IOC管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单元测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//springboot整合单元测试的注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完成后的文件结构如图</p>
<img src="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/module.png" width="50%">
<p><strong>配置SQL提示</strong></p>
<p>在上边的SQL语句中，如果没有配置，那么就不会显示相应的提示，即使写错了也不会提醒，这对于开发是非常不利的。好在Idea中可以为其配置MySQL数据库连接。</p>
<ul>
<li>选中SQL语句，右键，配置为MySQL语句</li>
<li>点击右侧边栏的数据库选项，点击加号，数据源选择MySQL，填写host、port、用户和密码、数据库</li>
</ul>
<p><strong>数据库连接池</strong></p>
<ul>
<li>数据库连接池是个容器，负责分配、管理数据库连接</li>
<li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li>
<li>能够释放空闲时间超过最大空闲时间的连接，避免因为没有释放连接引起的数据库连接遗漏</li>
<li>好处：资源重用 提升系统响应速度 避免数据库连接遗漏</li>
</ul>
<p>标准接口：DataSource</p>
<ul>
<li>官方提供的数据库连接池接口，由第三方组织实现此接口</li>
<li>功能：获取连接</li>
</ul>
<p>常见产品：C3P0、DBCP、Druid、Hikari</p>
<p><strong>lombok</strong></p>
<p>在入门-快速入门的实际类编写中我们自己手动构造了getset、toString等方法，较为繁琐。改进方法就是使用lombok。lombok是一个实用Java类库，能通过注解的形式自动生成getset方法、构造器、toString等方法，并可以自动化生成日志日志变量，简化Java开发、提高效率。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Getter、@Setter</td>
<td>提供getset方法</td>
</tr>
<tr>
<td>@ToString</td>
<td>提供tostring方法</td>
</tr>
<tr>
<td>@EqualsAndHashCode</td>
<td>重写equals和hashCode方法</td>
</tr>
<tr>
<td>@Data</td>
<td>上边三个的整合</td>
</tr>
<tr>
<td>@NoArgsConstructor</td>
<td>无参构造器</td>
</tr>
<tr>
<td>@AllArgsConstructor</td>
<td>含参构造器</td>
</tr>
</tbody>
</table>
<p>直接添加注解是会报错的，还需要导入lombok的依赖，可以写注解然后根据IDEA自动导入依赖。</p>
<h2 id="2-CRUD操作">2.CRUD操作</h2>
<p>CRUD操作是mybatis使用的核心，这一部分以实操为主</p>
<p>首先进行工程的<strong>准备工作</strong>，和入门的工程基本一致。</p>
<p>关于实体类的创建的注意点：</p>
<ul>
<li>注意在数据库表结构中字段名是使用下划线分隔的，但是在实体类中我们采用驼峰命名</li>
</ul>
<h3 id="在mybatis中实现删除操作">在mybatis中实现删除操作</h3>
<p>根据主键删除</p>
<p>在Mapper接口中编写如下方法和语句，#{…}是占位符，用于将方法的参数提取出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id =#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="日志输出">日志输出</h3>
<p>在配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis的日志，指定输出到控制台</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<p>再次运行程序，控制台中日志的输出如下</p>
<p><code>==&gt;  Preparing: delete from user where id =? ==&gt; Parameters: 9(Integer) &lt;==    Updates: 1</code></p>
<p>可以看到输出的SQL语句带有“？”，这个就被称为<strong>预编译SQL</strong>。</p>
<p>它有两大优势：</p>
<ul>
<li>性能更高</li>
<li>更安全（防止SQL注入）</li>
</ul>
<p><strong>为什么性能更高？</strong></p>
<p>需要从SQL语句具体的执行过程来分析</p>
<p>SQL语句执行</p>
<pre><code class="highlight mermaid">graph LR
    A[Java] ==&gt; B(SQL语法解析检查)
    
    subgraph SQL处理流程[缓存]
        B ==&gt; C(优化SQL)
        C ==&gt; D(编译SQL)
    end
    
    D ==&gt; E(执行SQL)</code></pre>
<p>对比两种方式</p>
<p>第一种</p>
<p><code>delete from user where id =1</code></p>
<p><code>delete from user where id =2</code></p>
<p><code>delete from user where id =3</code></p>
<p>第二种</p>
<p><code>delete from user where id = ?</code></p>
<p><code>1</code></p>
<p><code>2</code></p>
<p><code>3</code></p>
<p>这两种性能的差别就是因为这个缓存的过程，在Java发送SQL语句之后，会先经过检查、优化、编译，然后被缓存起来，之后再发送的时候会先检查缓存种是否有这个SQL语句，如果有就直接执行了。</p>
<p>第一种的话由于三条SQL语句每条都不相同，所以需要编译三次，而第二种的话由于是预编译的形式，所以只用编译一次，后边三条SQL语句就可以直接执行。</p>
<p>由此我产生一个问题，使用多态性是否也同样能提高Java的效率？</p>
<p><strong>为什么更安全？</strong></p>
<p>这里主要是与另一种占位符作对比</p>
<p>#{…}</p>
<ul>
<li>
<p>执行SQL时，会将#{…}替换为？，生成预编译SQL，会自动设置参数值</p>
</li>
<li>
<p>使用时机：参数传递，都使用#{…}</p>
</li>
</ul>
<p>${…}</p>
<ul>
<li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li>
<li>使用时机：很少使用，如果对表名、列表进行动态设置时使用</li>
</ul>
<p>SQL注入：通过操作输入的数据来修改实现定义好的SQL语句，以达到执行代码对服务器进行攻击的方法</p>
<p>举个栗子🌰</p>
<p>账户的登录操作其实就是查询数据库中用户表的相应username和password是否都存在</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;miku&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果count(*)&gt;=1，那么我们就认为密码正确，就可以放行了。</p>
<p><strong>若使用的是${…}</strong></p>
<p>那么就是直接拼接的形式，如果传入的是这样的(“miku”,”‘ ’ or ‘1’=‘1”)</p>
<p>SQL语句就会变成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;miku&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就是一个恒成立的条件，那么也会直接放行。</p>
<p>这里只是举个例子，实际上现在是个网站都会防SQL注入，渗透也没有这么简单。</p>
<p><strong>若使用的是#{…}</strong></p>
<p>那么就会直接传递给？，就会直接拿传递的参数去数据库查询，不会更改SQL的基本逻辑。</p>
<h3 id="在mybatis中实现新增操作">在mybatis中实现新增操作</h3>
<p><strong>基本插入</strong></p>
<p>最简单的插入，不含占位符，无参数传递， <s>也最没有用</s></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(user.username, user.name, user.gender, user.age) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;values(&#x27;test&#x27;,&#x27;测试插入SQL&#x27;,1, 18)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>使用占位符传递，注意与实用类的属性名保持一致，使用小驼峰命名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(id,user.username, user.name, user.gender, user.age) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;values(#&#123;id&#125;,#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>获取主键</strong></p>
<p>在@Insert注解上添加注解@Options(keyProperty = “id”,useGeneratedKeys = true)会自动将生成的主键值，赋值给emp对象的id属性</p>
<h3 id="在mybatis中实现更新操作">在mybatis中实现更新操作</h3>
<p>很简单，会SQL语句就会更新操作</p>
<p>直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update user set username=#&#123;username&#125;&quot;+</span></span><br><span class="line"><span class="meta">&quot;, name=#&#123;name&#125;,gender=#&#123;gender&#125;, age=#&#123;age&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="在mybatis中实现查询操作">在mybatis中实现查询操作</h3>
<p><strong>根据Id查询</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就是设置一个传参的SQL语句就可以了</p>
<p>但是有一个问题，比如日期update_time这些MySQL和Java命名规范不一样的字段，是不会进行自动封装的，也就是说直接查是查不到的。相应有三种解决方案：</p>
<ul>
<li>配置自动映射</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>这是最简单也是最推荐的一种方案，只要保证符合命名规范，就能够自动封装</p>
<ul>
<li>使用别名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select update_time updateTime from user where id = #&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用@Results注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;updateTime&quot;, column = &quot;update_time&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;entryDate&quot;, column = &quot;entry_date&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure>
<p>后两种都比较繁琐，很少用</p>
<p><strong>条件查询</strong></p>
<p>考虑下面一个需求：</p>
<p>查询员工，根据员工的姓名、性别、入职时间搜索满足条件的员工信息。要求：员工姓名支持模糊匹配，性别精确匹配，入职时间进行范围查询。对查询的结果根据最后修改时间进行倒序排序。</p>
<p>编写出的SQL语句应该是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> entry_date <span class="keyword">between</span> </span><br><span class="line"><span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>用Mybatis实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and entry_date between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name ,Short gender,LocalDate begin,LocalDate end)</span>; </span><br></pre></td></tr></table></figure>
<p>注意，在这里使用了concat (‘%’,#{name},‘%’)函数，这是因为如果直接替换为‘%#{name}%’，是不合法的，因为?占位符不能出现在引号内，只能使用${…}，可是这样就会有性能低、安全性低的问题。那么就使用了SQL的函数concat，它用于将多个字符串拼接起来，这样就解决了问题。</p>
<p><strong>参数名说明</strong></p>
<p>在SpringBoot1.X版本，参数名前必须要加上@Param(“字段名”)，才能进行传递，这是因为在这个版本是不会把形参名保留下来，所以就必须要加上注解。</p>
<h2 id="3-XML映射文件">3.XML映射文件</h2>
<p>定义规范</p>
<ul>
<li>XML的文件名称与Mapper接口的名称一致，并且放置在相同包下（同包同名）</li>
<li>XML的namespace属性与Mapper接口的全限定名一致</li>
<li>XML中SQL语句的id与Mapper接口中的方法名一致，有返回值的要写resultType属性，这个是单条记录所封装的类型（也就是说如List结构，要写他的单挑记录的数据类型）</li>
</ul>
<h2 id="4-动态SQL">4.动态SQL</h2>
<p>学习动态SQL就是要学习其响应的标签</p>
<p>1.<if></if></p>
<ul>
<li>用判断条件是否成立，如果条件为true，则拼接SQL</li>
<li>形式：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.<where></where></p>
<ul>
<li>where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句开头的and或or</li>
</ul>
<p>3.<set></set></p>
<ul>
<li>动态地在行首插入set关键字，并会删除额外的逗号。（用在update语句中）</li>
</ul>
<p>4.<foreach></foreach></p>
<ul>
<li>SQL语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>接口方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBytes</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>XML映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBytes&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>标签属性说明：</p>
<p>collection：集合名称</p>
<p>item：集合遍历出来的元素/项，与下边占位符名称一致</p>
<p>separator：每一次遍历使用的分隔符</p>
<p>open：遍历开始前拼接的片段</p>
<p>close：遍历结束后拼接的片段</p>
<p>5.<sql> <include></include></sql></p>
<p>为提高复用性，可以将sql用<sql>标签记录，并使用<include>标签调用</include></sql></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--纪录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line">    select id,username,name,gender,age from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://CV-Elevation.github.io">KuoZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/">http://cv-elevation.github.io/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://CV-Elevation.github.io" target="_blank">KuoZ's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mybatis/">Mybatis</a></div><div class="post-share"><div class="social-share" data-image="/img/holo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SpringBoot入门</div></div><div class="info-2"><div class="info-item-1">修改历史：  增加了Web入门的基础知识，完善了结构  SpringBoot入门 0.概述 本篇只是对springboot的基本使用的总结，学习视频-&gt;Day05-01. 请求响应-概述_哔哩哔哩_bilibili，使用postman进行调试。 1.Web入门 HTTP协议 概述 HTTP协议（HyperTextTransferProtocol），超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 特点：  TCP协议：面向连接，安全 基于请求-响应模型：一次请求对应一次响应 HTTP是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的  缺点：多次请求无法共享数据 优点：速度快    请求协议 请求数据包括三个部分： 请求行：请求数据第一行（请求方式，资源路径、协议） 请求头：第二行开始，格式key: value 请求体：POST请求，存放请求参数 两种请求方式对比：   请求方式-get：请求参数在请求行中，没有请求体。get请求大小是有限制的。   请求方式-post：请求参数在请求体中，post请求大小是没有限制的。   响应协议 响应数据包括三部分：   响应行：相应数据第一行（协议、状态码、描述）   响应头：key: value   响应体：存放响应数据   常见状态码：    状态码 描述     1xx 响应中   2xx 成功   3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理   4xx 客户端错误-处理发生错误，责任在客户端。如请求了不存在的资源、客户端未被授权、禁止访问   5xx 服务器错误-处理发生错误，责任在服务端。如程序抛出异常    目前主要了解：200 处理成功，404 请求资源不存在，500 服务器端异常 更多状态码见网站： 状态 | Status - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云 协议解析 服务器端要做的事情，一方面是要根据请求协议，解析浏览器发送的请求；另一方面是要根据响应协议，发送响应数据。 这种解析的工作较为固定，有不少Web服务器已经完成了这些工作，这样后端就只用关注业务逻辑的实现。常见的Web服务器有：Tomcat、IBM、jetty、WebLogic等 Tomcat服务器 具体内容暂时不用详细了解，SpringBoot已经内嵌了Tomcat服务器，所以不用专门下载。介绍在此省略 2.请求 此处请求的含义：后端接收来自浏览器端的请求指令，进行解析 简单参数 请求： GET指令：http://localhost:8080/simpleParam?name=miku&amp;age=16 POST指令：http://localhost:8080/simpleParam请求体：name=Miku&amp;age=16 Java代码： 原始方式： 12345678910//在原始的Web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(HttpServletRequest request) &#123;    String name = request.getParameter(&quot;name&quot;);//需要与请求参数的key保持一致    String ageStr = request.getParameter(&quot;age&quot;);//需要与请求参数的key保持一致    int age = Integer.parseInt(ageStr);    System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age);    return &quot;OK&quot;;&#125;//繁琐，并且需要进行手动类型转换 SpringBoot方式： 简单参数，参数名与形参列表名相同，定义形参即可接收参数 12345@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(int age,String name) &#123;    System.out.println(name + &quot;:&quot; + age);    return...</div></div></div></a><a class="pagination-related" href="/2025/07/04/Redis/" title="Redis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis</div></div><div class="info-2"><div class="info-item-1">Redis基础部分 介绍 Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征：  键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码） 支持数据持久化 支持主从集群、分片集群 支持多语言客户端  redis安装 关于redis，这里推荐装linux版的。 所以建议先学习安装linux和它的常用vi命令。这里做几点建议：  win10及以上可以直接使用自带的wsl2来安装linux子系统，具体教程b站上有。我使用的是Ubuntu，并且没有什么问题 redis的安装和测试可以参考这个教程如何在 Ubuntu 20.04 上安装和配置 Redis-阿里云开发者社区  redis常用的命令 命令不用死记，建议去redis官网查询命令 又或者，你也可以在命令行中使用help [command]来查询,例如：  下边总结常用的命令   KEYS：查看符合模版的所有key，不建议在生产环境设备上使用，因为效率过低   DEL：删除一个指定的key   EXISTS：判断key是否存在   EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除   TTL：查看一个key的剩余有效期   String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型 其value是字符串，不过根据字符串的格式不同，又可以分为3类：string、int、float String的常见命令  SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的value MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY：让一个整型的key自增并指定步长 INCRYBYFLOAT：让一个浮点类型的数字自增并指定步长 SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX：添加一个String类型的键值对，并指定有效值  Key的层级格式： Redis的key允许有多个单词形成层级结构，多个单词之间用‘:’隔开，这样就会形成层级结构。 Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：  Hash的常见命令：  HSET key field value：添加或修改hash类型key的field的值 HGET key field：获取一个hash类型key的field值 HMSET：批量添加多个hash类型key的field值 HMGET：获取获取多个hash类型key的field值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有field HVALS：获取一个hash类型的key中的所有value HINCRBY：让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行  List类型 Redis中的List类型与Java中的LinkedList基本一致 List的常见命令：  LPUSH key element…：想列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element…：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil  如何利用List结构模拟一个栈?  入口和出口在同一边  如何利用List结构模拟一个队列？  入口和出口在不同边  如何利用List结构模拟一个阻塞队列？  入口和出口在不同边 出队时采用BLPOP或BRPOP  Set类型 Redis的Set结构和Java中的HashSet类似，可以看做是一个value为null的HashMap。 Set的常见指令：  SADD key member …：向Set中添加一个或多个元素 SREM key member …：移除set中的指定元素 SCARD key：返回set中元素的个数 SISMEMBER key...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KuoZ</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CV-Elevation"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这是一个专属于我（KuoZ）的空间，它用来记录我的学习笔记、硬件或软件开发中的经验、还有吹水等等内容。本网站使用HEXO框架搭建。旧的两篇博客在博客园https://www.cnblogs.com/pulse1454</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Mybatis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%BA%8F"><span class="toc-text">0.序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="toc-text">1.入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CRUD%E6%93%8D%E4%BD%9C"><span class="toc-text">2.CRUD操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8mybatis%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">在mybatis中实现删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="toc-text">日志输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8mybatis%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%96%B0%E5%A2%9E%E6%93%8D%E4%BD%9C"><span class="toc-text">在mybatis中实现新增操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8mybatis%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C"><span class="toc-text">在mybatis中实现更新操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8mybatis%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">在mybatis中实现查询操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-XML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-text">3.XML映射文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81SQL"><span class="toc-text">4.动态SQL</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" title="SpringMVC之登录校验">SpringMVC之登录校验</a><time datetime="2025-07-13T07:21:29.000Z" title="发表于 2025-07-13 15:21:29">2025-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Redis/" title="Redis">Redis</a><time datetime="2025-07-04T10:00:54.000Z" title="发表于 2025-07-04 18:00:54">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/" title="Mybatis入门">Mybatis入门</a><time datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门">SpringBoot入门</a><time datetime="2025-06-03T14:30:09.000Z" title="发表于 2025-06-03 22:30:09">2025-06-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/miku2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By KuoZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>