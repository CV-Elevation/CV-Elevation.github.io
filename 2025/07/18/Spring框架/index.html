<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring框架 | KuoZ's blog</title><meta name="author" content="KuoZ"><meta name="copyright" content="KuoZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Spring Framework Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门Spring-01-初识Spring_哔哩哔哩_bilibili 要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Sprin">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring框架">
<meta property="og:url" content="http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="KuoZ&#39;s blog">
<meta property="og:description" content="Spring Framework Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门Spring-01-初识Spring_哔哩哔哩_bilibili 要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Sprin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cv-elevation.github.io/img/holo.jpg">
<meta property="article:published_time" content="2025-07-18T08:53:50.000Z">
<meta property="article:modified_time" content="2025-07-18T08:54:55.694Z">
<meta property="article:author" content="KuoZ">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cv-elevation.github.io/img/holo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring框架",
  "url": "http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/",
  "image": "http://cv-elevation.github.io/img/holo.jpg",
  "datePublished": "2025-07-18T08:53:50.000Z",
  "dateModified": "2025-07-18T08:54:55.694Z",
  "author": [
    {
      "@type": "Person",
      "name": "KuoZ",
      "url": "http://cv-elevation.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/Myfavicon2.ico"><link rel="canonical" href="http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring框架',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="KuoZ's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/miku2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KuoZ's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring框架</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spring框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-18T08:53:50.000Z" title="发表于 2025-07-18 16:53:50">2025-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-18T08:54:55.694Z" title="更新于 2025-07-18 16:54:55">2025-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Spring Framework</h1>
<p>Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fi4y1S7ix?spm_id_from=333.788.videopod.episodes&amp;vd_source=fcaafec007e4b65465664a3d124792c0&amp;p=3">Spring-01-初识Spring_哔哩哔哩_bilibili</a></p>
<p>要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Spring源码的部分进一步学习。</p>
<p><strong>Spring系统架构</strong></p>
<img src="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/image-20250614224253416.png" alt="image-20250614224253416" style="zoom:30%;">
<p><strong>IoC（Inversion of Control）控制翻转</strong></p>
<p>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象的创建控制权由程序转移到外部，这个思想就是<strong>控制翻转</strong>。</p>
<p>IoC、Bean和DI：</p>
<ul>
<li>
<p>Spring提供了一个容器，称为IoC容器，用来充当Ioc思想中的“外部”</p>
</li>
<li>
<p>IoC容器负责对象的创建、初始化的一系列工作，被创建或管理的对象在IoC容器中统称为<strong>Bean</strong></p>
</li>
<li>
<p>DI（依赖注入）在容器中建立起bean与bean之间的关系</p>
</li>
</ul>
<p>我们这样做的目的是充分解耦，具体做法可以概括如下：</p>
<ul>
<li>使用IoC容器管理bean（IoC）</li>
<li>在IoC容器中将有依赖关系的bean进行关系绑定（DI）</li>
</ul>
<h2 id="bean管理">bean管理</h2>
<h3 id="bean作用范围">bean作用范围</h3>
<p>bean的作用范围对应着scope属性，主要就是控制其是否为单例。</p>
<p>为什么bean默认为单例？</p>
<ul>
<li>IoC容器就适合管理单例的对象，这样才能有效地提高效率。</li>
</ul>
<p>适合交给容器管理的bean</p>
<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
<p>不适合交给容器管理的bean</p>
<ul>
<li>封装实体的域对象、</li>
</ul>
<h3 id="bean的实例化">bean的实例化</h3>
<ol>
<li>构造方法（常用）</li>
</ol>
<p>提供可访问的构造方法</p>
<p>配置</p>
<ul>
<li>无参构造器如果不存在，会抛出BeanCreationException</li>
</ul>
<ol start="2">
<li>静态工厂（了解）</li>
<li>实例工厂（了解）</li>
<li>使用FactoryBean实例化，其中有三个方法，用来得到Bean实例、设定Bean类型、设定是否为单例（实用）</li>
</ol>
<h3 id="bean的生命周期">bean的生命周期</h3>
<ul>
<li>bean生命周期：bean从创建到销毁的整体过程</li>
<li>bean生命周期控制：在bean创建后到销毁前做的一些事情</li>
</ul>
<p><strong>生命周期控制</strong></p>
<ul>
<li>配置的方式</li>
<li>接口控制</li>
</ul>
<p><strong>bean的生命周期</strong></p>
<p>初始化容器</p>
<ol>
<li>创建对象（内存分配）</li>
<li>执行构造方法</li>
<li>执行属性注入（set操作）</li>
<li>执行bean初始化方法</li>
</ol>
<p>使用bean</p>
<ol>
<li>执行业务操作</li>
</ol>
<p>关闭/销毁容器</p>
<ol>
<li>执行bean销毁方法</li>
</ol>
<p><strong>bean销毁</strong></p>
<p>容器关闭前触发bean的销毁</p>
<p>关闭容器方式：</p>
<ul>
<li>手动关闭容器，ConfigurableApplicationContext接口close()操作</li>
<li>注册关闭<strong>钩子</strong>，在虚拟机退出前先关闭容器再退出虚拟机，ConfigurableApplicationContext接口registerShutdownHook()操作</li>
</ul>
<h3 id="总结">总结</h3>
<p>bean相关标签属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;dao bookDaoImpl daoImpl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;com.itheima.factory.BookDaoFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code>: bean的Id</li>
<li><code>name</code>: bean别名</li>
<li><code>class</code>: bean类型，静态工厂类，FactoryBean类</li>
<li><code>scope</code>: 控制bean的实例数量</li>
<li><code>init-method</code>: 生命周期初始化方法</li>
<li><code>destroy-method</code>: 生命周期销毁方法</li>
<li><code>autowire</code>: 自动装配类型，实际开发一般用注解，该属性一般不用</li>
<li><code>factory-method</code>: bean工厂方法，应用于静态工厂或实例工厂</li>
<li><code>factory-bean</code>: 实例工厂bean</li>
<li><code>lazy-init</code>: 控制bean延迟加载</li>
</ul>
<h2 id="依赖注入">依赖注入</h2>
<h3 id="手动装配">手动装配</h3>
<ul>
<li>setter注入</li>
</ul>
<p>引用类型使用ref配置</p>
<p>简单类型：使用property标签value属性进行配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造器注入</li>
</ul>
<p>使用constructor-arg标签ref属性注入引用类型对象</p>
<p>依赖注入方式选择</p>
<p>如果使用第三方bean，如果其同时提供了构造器注入和setter注入，使用setter注入。没有setter注入就只能使用构造器注入。自己开发推荐使用setter注入。</p>
<h3 id="自动装配">自动装配</h3>
<p>自动装配方式：</p>
<ol>
<li>按类型</li>
<li>按名称</li>
<li>构造器</li>
<li>不使用自动装配</li>
</ol>
<p>通过属性autowire进行自动装配的配置</p>
<ul>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一</li>
<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>
<li>自动装配优先级低于手动注入</li>
</ul>
<h3 id="集合注入">集合注入</h3>
<p>数组、list、set、map、properties</p>
<p>格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="容器">容器</h2>
<h3 id="创建容器">创建容器</h3>
<p>方式1，使用ClassPathXmlApplicationContext</p>
<p>方式2，使用FileSystemXmlApplicationContext</p>
<h3 id="获取bean">获取bean</h3>
<p>方式1，按名称</p>
<p>方式2，按类型</p>
<p>方式3，按名称并按类型</p>
<h3 id="容器类层次结构">容器类层次结构</h3>
<p><img src="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/image-20250618151923608.png" alt="image-20250618151923608"></p>
<h3 id="总结-2">总结</h3>
<ul>
<li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li>
<li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li>
<li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li>
<li>ApplicationContext接口初始化类
<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
</ul>
</li>
</ul>
<h2 id="加载propertis文件">加载propertis文件</h2>
<h3 id="开启命名空间的方式">开启命名空间的方式</h3>
<p>1.开context命名空间</p>
<p>2.使用context空间加载propertie文件</p>
<p>3.使用属性占位符${}读取properties文件中的属性</p>
<h3 id="加载propertis文件几种方式">加载propertis文件几种方式</h3>
<ul>
<li>
<p>不加载系统属性</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>加载多个properties文件</p>
</li>
<li>
<p>加载所有properties文件</p>
</li>
<li>
<p>加载properties文件标准格式</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>从类路径或jar包中搜索并加载properties文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpathE*:*.properties&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>前三种格式都不规范，推荐使用后两种</p>
<h2 id="注解开发">注解开发</h2>
<h3 id="注解开发定义bean">注解开发定义bean</h3>
<p>使用注解的形式代替原来在配置文件中写的<code>&lt;bean&gt;</code>标签。具体方法是：在相应bean的类那里使用@Component注解。</p>
<p>为了能让Spring容器找到这个<strong>组件</strong>，还要在配置中添加扫描标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.dao.impl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时@Component还有三个衍生注解@Controller、@Service、@Repository</p>
<h3 id="纯注解开发">纯注解开发</h3>
<p>Spring3.0升级了纯注解开发模式</p>
<p>创建一个配置类，添加@Configuration、@ComponentScan注解，就可以完全代替配置文件</p>
<p>相对应的，应用程序的使用也要改变，需要使用AnnotationConfigApplicationContext的实现类创建容器，其相应参数传入我们的配置类。</p>
<p>总之，核心思想就是通过一个类及其注解代替配置文件</p>
<h3 id="bean管理-2">bean管理</h3>
<p>bean作用范围</p>
<p>@Scope</p>
<p>bean生命周期</p>
<p>@PostConstruct</p>
<p>@PreDestroy</p>
<h3 id="依赖注入-2">依赖注入</h3>
<p><strong>引用类型</strong></p>
<p>自动装配@Autowired按照类型自动装配。</p>
<ul>
<li>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法</li>
<li>注意：自动装配建议使用无参构造方法（默认），如果不提供对应构造方法，请提供唯一的构造方法</li>
</ul>
<p>关于有多个同类型的类的情况下如何解决，在SpringBoot的依赖注入部分我已经总结过<a target="_blank" rel="noopener" href="https://kuoz.top/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/">SpringBoot入门 | KuoZ’s blog</a></p>
<p><strong>简单类型</strong></p>
<p>使用@Value()进行值的注入，这样直接注入是静态的，实际上没什么意义，关键是如何动态注入。</p>
<p>如何动态进行注入？</p>
<p>方法：</p>
<ol>
<li>
<p>在properties配置文件中写相应的属性名及其值</p>
</li>
<li>
<p>在配置类中添加@PropertySource(“配置文件名”)注解</p>
</li>
<li>
<p>然后在基本类型的@Value注解中用${属性名}进行替换</p>
</li>
</ol>
<p>注意：要添加多个配置文件，要用数组的形式进行配置，@PropertySource({“配置文件名1”,“配置文件名2”,…})</p>
<h3 id="第三方bean管理">第三方bean管理</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个问题，这个bean实在配置类中写的，可能会有很多第三方bean，如果都写在SpringConfig配置类中就会很臃肿，所以要写新的配置类。接下来的问题是如何将这个新的配置类加载起来，方法是在SpringConfig配置类中使用@Import()注解，同样的，有多个配置类时，要用数组的形式写如@Import的属性。</p>
<p>第三方bean依赖注入</p>
<ul>
<li>引用类型：方法形参</li>
<li>简单类型：成员变量，使用@Value进行注入即可</li>
</ul>
<h3 id="总结-3">总结</h3>
<p>XML和注解配置的对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">XML配置</th>
<th style="text-align:left">注解</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">定义bean</td>
<td style="text-align:left"><code>&lt;bean&gt;</code>标签</td>
<td style="text-align:left"><code>@Component</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">- <code>id</code>属性</td>
<td style="text-align:left">- <code>@Controller</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">- <code>class</code>属性</td>
<td style="text-align:left">- <code>@Service</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">- <code>@Repository</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@ComponentScan</code></td>
</tr>
<tr>
<td style="text-align:left">设置依赖注入</td>
<td style="text-align:left">setter注入（set方法）</td>
<td style="text-align:left"><code>@Autowired</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">- 引用/简单类型</td>
<td style="text-align:left">- <code>@Qualifier</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">构造器注入（构造方法）</td>
<td style="text-align:left"><code>@Value</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">- 引用/简单类型</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">自动装配</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">配置第三方bean</td>
<td style="text-align:left"><code>&lt;bean&gt;</code>标签</td>
<td style="text-align:left"><code>@Bean</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">静态工厂、实例工厂、<code>FactoryBean</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">作用范围</td>
<td style="text-align:left"><code>scope</code>属性</td>
<td style="text-align:left"><code>@Scope</code></td>
</tr>
<tr>
<td style="text-align:left">生命周期</td>
<td style="text-align:left">标准接口</td>
<td style="text-align:left"><code>@PostConstruct</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">- <code>init-method</code></td>
<td style="text-align:left"><code>@PreDestroy</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">- <code>destroy-method</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="整合">整合</h2>
<h3 id="Spring整合MyBatis">Spring整合MyBatis</h3>
<p>如何整合MyBatis？</p>
<ul>
<li>通过MyBatis的实现代码可以看出，MyBatis的核心实现类是SqlSessionFactory，所以整合的核心也是sqlSessionFactory对象</li>
</ul>
<p>简略地说，只有两个bean需要配置</p>
<ul>
<li>SqlSessionFactoryBean</li>
<li>MapperScannerConfigurer</li>
</ul>
<h3 id="Spring整合JUnit">Spring整合JUnit</h3>
<p>在pom中导入JUnit依赖和Spring整合测试依赖</p>
<p>在test包下创建测试类，为其添加注解</p>
<ul>
<li>@RunWith(SpringJUnit4ClassRunner.class)</li>
<li>@ContextConfiguration(classes = SpringConfig.class)</li>
</ul>
<h2 id="AOP">AOP</h2>
<p>在介绍AOP之前，我想先来介绍一下代理模式，这样可以利于理解AOP</p>
<h3 id="代理模式">代理模式</h3>
<p>动态代理</p>
<p>什么是动态代理？</p>
<p>就是一种无侵入式地修改代码、添加功能</p>
<p>这个功能的实现就依赖于代理对象。</p>
<p>什么是代理对象？</p>
<p>代理对象就相当于是一个中间对象，它介于目标对象和调用者之间，通过反射的方式间接调用目标对象的方法，同时还可以添加增强的功能。</p>
<p>下一个问题，如何创建代理对象？</p>
<p>jdk中为我们提供了一个类：java.lang.reflect.Proxy类，提供了为对象产生代理对象的方法：<code>newProxyInstance()</code></p>
<p>该方法的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="keyword">new</span> <span class="title class_">ProxyInstance</span>(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数1：用于指定用哪个类加载器去加载生成的代理类，一般固定</span></span><br><span class="line"><span class="comment">*参数2：指定接口，指明有哪些方法</span></span><br><span class="line"><span class="comment">*参数3：生成的代理对象要干什么事（一般是匿名实现类的匿名对象，不懂的可以去看面向对象高级里的接口）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="AOP-2">AOP</h3>
<ul>
<li>
<p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</p>
</li>
<li>
<p>作用：在不惊动原始设计的基础上为其进行功能增强</p>
</li>
</ul>
<p><strong>AOP的重要概念</strong></p>
<p>连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法</p>
<ul>
<li>在SpringAOP中，理解为方法的执行</li>
</ul>
<p>切入点（Pointcut）：匹配连接点的式子</p>
<ul>
<li>
<p>在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法</p>
<ul>
<li>
<p>一个具体方法：</p>
</li>
<li>
<p>匹配多个方法：</p>
</li>
</ul>
</li>
</ul>
<p>通知（Advice）：在切入点处执行的操作，也就是共性功能</p>
<ul>
<li>在SpringAOP中，功能最终以方法的形式呈现</li>
</ul>
<p>通知类：定义通知的类</p>
<p>切面（Aspect）：描述通知与切入点的对应关系</p>
<p><strong>AOP开发</strong></p>
<p>比如在服务层的若干连接点，在这些方法前执行一个共性方法</p>
<ol>
<li>导入aspect依赖、spring-aop依赖（依赖于Context依赖，导入Context后会自动导入）</li>
<li>定义dao接口和实现类</li>
<li>定义通知类，为这个类添加<code>@Component、@Aspect</code>，</li>
<li>定义切入点，写一个私有空方法（比如<code>private void pt()&#123;&#125;</code>），在上边添加<code>@Pointcut(“execution()”)</code>绑定切入点，参数是切入点的返回类型+包名.类名.方法名</li>
<li>绑定切入点与通知关系，<code>@Before(“pt()”)</code></li>
<li>为配置类添加@EnableAspectJAutoProxy</li>
</ol>
<p><strong>AOP工作流程</strong></p>
<p>工作流程：</p>
<ol>
<li>Spring容器启动</li>
<li>读取所有切面配置的切入点（注意一定是使用了的切入点才会被读取）</li>
<li>初始化bean，判定bean对应的类中的方法是否匹配到了任意切入点
<ul>
<li>匹配失败，创建对象</li>
<li>匹配成功，创建目标对象的代理对象</li>
</ul>
</li>
<li>获取bean的执行方法
<ul>
<li>获取bean，调用方法并执行，完成操作</li>
<li>根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li>
</ul>
</li>
</ol>
<p>AOP的本质就是<strong>代理模式</strong></p>
<p><strong>AOP切入点表达式</strong></p>
<p>切入点表达式和切入点是完全不同的概念</p>
<p>语法格式：</p>
<p>没什么好讲的，大概给个标准格式吧，稍微看一点就会了</p>
<p><code>动作关键字(权限修饰符（可省略） 返回值类型 包名.类/接口名.方法名（形参列表）异常名)</code></p>
<p>通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>可以独立出现，也可以作为前缀或者后缀（如find*）（用在方法参数中一个只表示一个任意参数）</td>
</tr>
<tr>
<td>…</td>
<td>多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</td>
</tr>
<tr>
<td>+</td>
<td>专用于匹配子类类型</td>
</tr>
</tbody>
</table>
<p>下面给几个例子，来体验一下切入点表达式的书写</p>
<p>书写技巧：</p>
<ol>
<li>按照编程的命名规范编程，否则技巧全部无用</li>
<li>通常描述切入点时描述到接口而不写实现类</li>
<li>一般省略修饰符</li>
<li>对于返回值，增删改类使用精准类型加速匹配，查询类使用*通配符快速描述</li>
<li>包名尽量不用…匹配，效率太低，常用*作为单个包匹配，或者精准匹配</li>
<li>接口名采用*匹配，如：<code>*Service</code>，绑定业务层接口名</li>
<li>方法名动词精准匹配，名词用*，如<code>getBy*</code></li>
<li>参数规则较复杂，据业务方法灵活调整</li>
<li>不使用异常方法做匹配规则</li>
</ol>
<p>AOP通知类型</p>
<p>五种类型：</p>
<ul>
<li>前置通知@Before</li>
<li>后置通知@After</li>
<li><strong>环绕通知@Around</strong>（重点）</li>
<li>@AfterReturning（不常用）</li>
<li>@AfterThrowing（不常用）</li>
</ul>
<p>环绕通知的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(pt)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;切入点前执行...&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed; </span><br><span class="line">    System.out.println(<span class="string">&quot;切入点后执行...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于@Around的通知类型的注意：</p>
<ul>
<li>通知中未使用ProceedingJoinPoint对原始方法进行调用，则会跳过原始方法</li>
<li>对原始方法的调用可以不接收返回值，通知方法返回值类型设为void即可，如果接收，则必须设定为Object类型</li>
<li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设定为void，也可以设定成Object</li>
<li>由于无法预知原始方法是否会抛出异常，所以通知方法要抛出异常</li>
</ul>
<p>AOP通知获取数据</p>
<p>获取参数</p>
<p>环绕类型直接使用ProceedingJoinPoint参数获取参数</p>
<p>其他类型使用JoinPoint参数获取参数</p>
<p>获取返回值</p>
<p>使用returning注解属性获取返回值</p>
<p>获取异常</p>
<p>使用throwing注解属性获取返回值</p>
<h2 id="Spring事务属性">Spring事务属性</h2>
<p>Spring事务，在数据层、业务层保障一系列数据库操作同成功同失败</p>
<h3 id="Spring事务的添加">Spring事务的添加</h3>
<ol>
<li>在业务层接口上加@Transactional注解</li>
<li>在配置中添加事务管理器</li>
<li>开启事务控制@EnableTransactionManagement</li>
</ol>
<h3 id="Spring事务角色">Spring事务角色</h3>
<p>Spring事务会让数据层接口的事务加入Spring事务，从而保证一致性</p>
<p>有两个角色</p>
<p>事务管理员：发起事务方，在Spring中代指业务层开启事务的方法</p>
<p>事务协调员：加入事务方，在Spring中代指数据层方法也可以是业务层方法</p>
<h3 id="Spring事务属性-2">Spring事务属性</h3>
<p>事务相关配置</p>
<p>在@Transactionnal注解属性中可以更改readonly、timeout等属性，最重要的还是rollbackFor属性</p>
<p>为什么需要rollbackFor属性？</p>
<p>因为默认情况下只有遇到Error、运行时异常，事务才会回滚。如果想在其他异常时也同样回滚，就需要设置rollbackFor属性。</p>
<p>例如<code>@Transactional(rollbackFor=IOException.class)</code></p>
<p>日志模块</p>
<p>日志模块要求无论转账成功与否，都要在数据库中添加记录</p>
<p>这就涉及到事务的传播行为，来设定事务的处理态度</p>
<p>通过@Transactional注解的Propagation设定</p>
<p>总共有如下取值</p>
<table>
<thead>
<tr>
<th>Propagation</th>
<th>事务管理员</th>
<th>事务协调员</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUIRED</td>
<td>开启T</td>
<td>加入T</td>
</tr>
<tr>
<td></td>
<td>无</td>
<td>新建T2</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>开启T</td>
<td>新建T2</td>
</tr>
<tr>
<td></td>
<td>无</td>
<td>新建T2</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>开启T</td>
<td>加入T</td>
</tr>
<tr>
<td></td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>开启T</td>
<td>无</td>
</tr>
<tr>
<td></td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>开启T</td>
<td>加入T</td>
</tr>
<tr>
<td></td>
<td>无</td>
<td>ERROR</td>
</tr>
<tr>
<td>NEVER</td>
<td>开启T</td>
<td>ERROR</td>
</tr>
<tr>
<td></td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>还有一个是NESTED，设置savePoint，一旦事务回滚，事务将回滚到savaPoint，交由客户响应提交/回滚</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://CV-Elevation.github.io">KuoZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/">http://cv-elevation.github.io/2025/07/18/Spring%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://CV-Elevation.github.io" target="_blank">KuoZ's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post-share"><div class="social-share" data-image="/img/holo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaSE-反射</div></div><div class="info-2"><div class="info-item-1">学到Spring框架发现自己JavaSE的反射还没学，就滚过来学反射了。 黑马的这个课讲的真不错，比尚硅谷的那个要简练一些，很轻松就能听懂了。 反射  Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.  官方对反射的描述：反射允许以编程方式访问已加载类的字段、方法和构造函数的信息，并在安全限制范围内使用反射字段、方法和构造函数来操作其底层对应项。 总之反射就是要获取某个类的Class文件，并解剖出它的成员变量、成员方法和构造方法。 反射第一步：获取class 要获取class，总共有三种方法  Class.forName(&quot;全类名&quot;) 类名.class 对象.getClass()  说明：  1中的全类名指的是包名+类名，一般可以直接复制粘贴 3的getClass方法是Object里的方法，所以所有对象都可以调用 三种方法虽然都可以获取class，但是对应的阶段不同  1对应的是源代码阶段 2对应的是加载到内存的阶段，一般作参数传递 3对应的是运行时阶段，只有这个类的对象创建时才能使用    反射第二步：获得并使用构造方法、属性、成员方法 Java中有一个重要的思想就是万事万物皆对象，相应的，构造方法、属性和成员方法也有其对应的类 属性（Field类）、成员方法（Method类）、构造方法（Constructor） 1.获得并使用构造方法  Class类中的方法：  1234Constructor&lt;?&gt;[] getConstrutors();Constructor&lt;?&gt;[] getDeclaredConstrutors();Constructor&lt;?&gt; getConstrucor(参数列表（注意传参数对应的class对象）);Constructor&lt;?&gt; getDeclaredConstrucor(参数列表（注意传参数对应的class对象）);  使用Constructor类的方法，获得修饰符、名字、形参、对象创建  123public int getModifiers();//获得权限修饰符getName();getParameters();//获取参数列表 （IDEA底层的代码提示其实就是用的反射） 关于modifiers()    变量和类型 常量字段 值     public static final int ABSTRACT 1024   public static final int FINAL 16   public static final int INTERFACE 512   public static final int NATIVE 256   public static final int PRIVATE 2   public static final int PROTECTED 4   public static final int PUBLIC 1   public static final int STATIC 8   public static final int STRICT 2048   public static final int SYNCHRONIZED 32   public static final int TRANSIENT 128   public static final int VOLATILE 64    使用暴力反射进行对象的创建： 对于私有构造器的使用，注意使用setAccessible(true)跳过权限验证 123456Class clazz = Class.forName(&quot;User&quot;);Constructor cons = clazz.getDeclaredConstructor(String.class);System.out.println(cons.getModifiers());cons.setAccessible(true);//设定权限验证User user = (User)...</div></div></div></a><a class="pagination-related" href="/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/" title="分布式缓存——Redis高级篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">分布式缓存——Redis高级篇</div></div><div class="info-2"><div class="info-item-1">分布式缓存——Redis高级篇 单节点Redis问题  数据丢失问题：实现Redis数据持久化 并发能力问题：搭建主从集群，实现读写分离 故障恢复问题：Redis哨兵，实现健康检测和自动恢复 存储能力问题：搭建分片集群，利用插槽机制实现动态扩容  一、持久化 方式之一：RDB持久化 RDB全称RedisDatabaseBackup file（Redis数据备份文件） 有两个命令可以进行RDB持久化  save命令：由主进程执行RDB，会阻塞所有命令 bgsave命令：开子进程执行RDB，避免主进程受影响  默认Redis停机时会执行一次RDB （停机≠宕机） 可以通过修改redis.conf文件来配置相关的RDB参数 1234567save 900 1 #900秒内由1次修改，就会执行bgsave。参数可以进行修改#是否压缩，建议不开启，压缩也会消耗CPU，磁盘的话相对不值钱rdbcompression yes#RDB文件名称dbfilename dump.rdb#文件保存的路径目录dir ./ bgsave流程 bgsave开始时会fork主进程得到子进程（在fork过程中主进程会被阻塞），子进程共享主进程的内存数据。fork后主进程可以正常读写，子进程会读取内存数据并写入RDB文件。 如果只是这样可能会有脏数据的问题，就是说在子进程读的时候主进程可能更改了数据。 要理解这个问题，需要理解内存结构。  如图是我参考课程使用visio绘制的fork框图，下面结合这个来解释一下fork的流程。 首先是关于linux的结构，在linux中，进程都是不能直接更改物理内存的，它在虚拟内存中，通过一个页表来维护关系，进程通过修改页表修改内存中的数据。 当使用bgsave的时候，首先会进行fork，会开启子进程，子进程复制主进程的页表，复制完后，为避免脏读的情况，会将数据A和数据B设为只读的共享内存，这样子进程在存储RDB时就不会被主进程干扰。 相应的主进程要更改数据，数据B会被拷贝为数据B的副本，主进程通过修改副本实现修改的功能。 因为内存进行了拷贝，所以极限情况下可能会占用两倍的内存，这也就是为什么使用Redis都要预留一定的内存空间。 RDB缺点：  RDB间隔较长，两次RDB间由数据丢失风险 fork子进程、压缩写出RDB比较耗时  方式二：AOF持久化 AOF全程Append Only File（追加文件），可以看成命令日志文件 可以通过redis.conf配置文件开启和配置AOF 1234567#开启appendonly yesappendfilename &quot;名字&quot;#频率appendfsync always#每执行一次命令，立即写到AOFappendfsync everysec#写命令执行完先放入AOF缓冲区，每隔一秒将缓冲数据写到AOFappendfsync no#写命令执行完先放入AOF缓冲区，由操作系统决定什么时候将缓冲数据写到AOF AOF体积压缩 因为AOF记录的是每条命令，多条命令叠加下可能很多命令是无效的，所以体积会很大。 可以使用bgrewriteaof命令将AOF文件进行重写以减小体积 什么时候进行重写？ 可以在redis.conf文件中配置 12auto-aof-rewrite-percentage 100#AOF文件增长超过多少百分比触发重写auto-aof-rewrite-min-size 64mb#AOF文件体积最小多大以上触发重写 RDB和AOF对比 各有优缺点，如果对数据安全性要求较高，在实际开发中往往会将两种方式结合起来使用     RDB AOF     持久化方式 定时对整个内存做快照 记录每一次执行的命令   数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略   文件大小 会有压缩，文件体积小 记录命令，文件体积大   宕机恢复速度 很快 慢   数据恢复优先级 低，因为数据完整性不如AOF 高，因为数据完整性高   系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源   使用场景 可以容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高    二、主从集群  搭建主从架构   开启主从关系 1replicaof/slaveof(5.0之前) host...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KuoZ</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CV-Elevation"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这是一个专属于我（KuoZ）的空间，它用来记录我的学习笔记、硬件或软件开发中的经验、还有吹水等等内容。本网站使用HEXO框架搭建。旧的两篇博客在博客园https://www.cnblogs.com/pulse1454</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Spring Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bean%E7%AE%A1%E7%90%86"><span class="toc-text">bean管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">bean作用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">bean的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text">手动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5"><span class="toc-text">集合注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">创建容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96bean"><span class="toc-text">获取bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">容器类层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BDpropertis%E6%96%87%E4%BB%B6"><span class="toc-text">加载propertis文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">开启命名空间的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BDpropertis%E6%96%87%E4%BB%B6%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">加载propertis文件几种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-text">注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89bean"><span class="toc-text">注解开发定义bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-text">纯注解开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E7%AE%A1%E7%90%86-2"><span class="toc-text">bean管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-2"><span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9bean%E7%AE%A1%E7%90%86"><span class="toc-text">第三方bean管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88"><span class="toc-text">整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88MyBatis"><span class="toc-text">Spring整合MyBatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88JUnit"><span class="toc-text">Spring整合JUnit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-2"><span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">Spring事务属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B7%BB%E5%8A%A0"><span class="toc-text">Spring事务的添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E8%A7%92%E8%89%B2"><span class="toc-text">Spring事务角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7-2"><span class="toc-text">Spring事务属性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" title="Redis之多级缓存">Redis之多级缓存</a><time datetime="2025-07-23T11:01:55.000Z" title="发表于 2025-07-23 19:01:55">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/" title="分布式缓存——Redis高级篇">分布式缓存——Redis高级篇</a><time datetime="2025-07-20T16:55:44.000Z" title="发表于 2025-07-21 00:55:44">2025-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/" title="Spring框架">Spring框架</a><time datetime="2025-07-18T08:53:50.000Z" title="发表于 2025-07-18 16:53:50">2025-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" title="SpringMVC之登录校验">SpringMVC之登录校验</a><time datetime="2025-07-13T07:21:29.000Z" title="发表于 2025-07-13 15:21:29">2025-07-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/miku2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By KuoZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>