<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>KuoZ's blog</title><meta name="author" content="KuoZ"><meta name="copyright" content="KuoZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta property="og:type" content="website">
<meta property="og:title" content="KuoZ&#39;s blog">
<meta property="og:url" content="http://cv-elevation.github.io/index.html">
<meta property="og:site_name" content="KuoZ&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cv-elevation.github.io/img/holo.jpg">
<meta property="article:author" content="KuoZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cv-elevation.github.io/img/holo.jpg"><link rel="shortcut icon" href="/img/Myfavicon2.ico"><link rel="canonical" href="http://cv-elevation.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KuoZ\'s blog',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="KuoZ's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/miku2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KuoZ's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">KuoZ's blog</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/" title="Spring框架">Spring框架</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-18T08:53:50.000Z" title="发表于 2025-07-18 16:53:50">2025-07-18</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Spring/">Spring</a></span></div><div class="content">Spring Framework Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门Spring-01-初识Spring_哔哩哔哩_bilibili 要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Spring源码的部分进一步学习。 Spring系统架构  IoC（Inversion of Control）控制翻转 使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象的创建控制权由程序转移到外部，这个思想就是控制翻转。 IoC、Bean和DI：   Spring提供了一个容器，称为IoC容器，用来充当Ioc思想中的“外部”   IoC容器负责对象的创建、初始化的一系列工作，被创建或管理的对象在IoC容器中统称为Bean   DI（依赖注入）在容器中建立起bean与bean之间的关系   我们这样做的目的是充分解耦，具体做法可以概括如下：  使用IoC容器管理bean（IoC） 在IoC容器中将有依赖关系的bean进行关系绑定（DI）  bean管理 bean作用范围 bean的作用范围对应着scope属性，主要就是控制其是否为单例。 为什么bean默认为单例？  IoC容器就适合管理单例的对象，这样才能有效地提高效率。  适合交给容器管理的bean  表现层对象 业务层对象 数据层对象 工具对象  不适合交给容器管理的bean  封装实体的域对象、  bean的实例化  构造方法（常用）  提供可访问的构造方法 配置  无参构造器如果不存在，会抛出BeanCreationException   静态工厂（了解） 实例工厂（了解） 使用FactoryBean实例化，其中有三个方法，用来得到Bean实例、设定Bean类型、设定是否为单例（实用）  bean的生命周期  bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做的一些事情  生命周期控制  配置的方式 接口控制  bean的生命周期 初始化容器  创建对象（内存分配） 执行构造方法 执行属性注入（set操作） 执行bean初始化方法  使用bean  执行业务操作  关闭/销毁容器  执行bean销毁方法  bean销毁 容器关闭前触发bean的销毁 关闭容器方式：  手动关闭容器，ConfigurableApplicationContext接口close()操作 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机，ConfigurableApplicationContext接口registerShutdownHook()操作  总结 bean相关标签属性 123456789101112&lt;bean    id=&quot;bookDao&quot;    name=&quot;dao bookDaoImpl daoImpl&quot;    class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;    scope=&quot;singleton&quot;    init-method=&quot;init&quot;    destroy-method=&quot;destory&quot;    autowire=&quot;byType&quot;    factory-method=&quot;getInstance&quot;    factory-bean=&quot;com.itheima.factory.BookDaoFactory&quot;    lazy-init=&quot;true&quot;      /&gt;  id: bean的Id name: bean别名 class: bean类型，静态工厂类，FactoryBean类 scope: 控制bean的实例数量 init-method: 生命周期初始化方法 destroy-method: 生命周期销毁方法 autowire: 自动装配类型，实际开发一般用注解，该属性一般不用 factory-method: bean工厂方法，应用于静态工厂或实例工厂 factory-bean: 实例工厂bean lazy-init: 控制bean延迟加载  依赖注入 手动装配  setter注入  引用类型使用ref配置 简单类型：使用property标签value属性进行配置 12&lt;property name=&quot;bookDao&quot;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/JavaSE/">JavaSE</a></span></div><div class="content">学到Spring框架发现自己JavaSE的反射还没学，就滚过来学反射了。 黑马的这个课讲的真不错，比尚硅谷的那个要简练一些，很轻松就能听懂了。 反射  Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.  官方对反射的描述：反射允许以编程方式访问已加载类的字段、方法和构造函数的信息，并在安全限制范围内使用反射字段、方法和构造函数来操作其底层对应项。 总之反射就是要获取某个类的Class文件，并解剖出它的成员变量、成员方法和构造方法。 反射第一步：获取class 要获取class，总共有三种方法  Class.forName(&quot;全类名&quot;) 类名.class 对象.getClass()  说明：  1中的全类名指的是包名+类名，一般可以直接复制粘贴 3的getClass方法是Object里的方法，所以所有对象都可以调用 三种方法虽然都可以获取class，但是对应的阶段不同  1对应的是源代码阶段 2对应的是加载到内存的阶段，一般作参数传递 3对应的是运行时阶段，只有这个类的对象创建时才能使用    反射第二步：获得并使用构造方法、属性、成员方法 Java中有一个重要的思想就是万事万物皆对象，相应的，构造方法、属性和成员方法也有其对应的类 属性（Field类）、成员方法（Method类）、构造方法（Constructor） 1.获得并使用构造方法  Class类中的方法：  1234Constructor&lt;?&gt;[] getConstrutors();Constructor&lt;?&gt;[] getDeclaredConstrutors();Constructor&lt;?&gt; getConstrucor(参数列表（注意传参数对应的class对象）);Constructor&lt;?&gt; getDeclaredConstrucor(参数列表（注意传参数对应的class对象）);  使用Constructor类的方法，获得修饰符、名字、形参、对象创建  123public int getModifiers();//获得权限修饰符getName();getParameters();//获取参数列表 （IDEA底层的代码提示其实就是用的反射） 关于modifiers()    变量和类型 常量字段 值     public static final int ABSTRACT 1024   public static final int FINAL 16   public static final int INTERFACE 512   public static final int NATIVE 256   public static final int PRIVATE 2   public static final int PROTECTED 4   public static final int PUBLIC 1   public static final int STATIC 8   public static final int STRICT 2048   public static final int SYNCHRONIZED 32   public static final int TRANSIENT 128   public static final int VOLATILE 64    使用暴力反射进行对象的创建： 对于私有构造器的使用，注意使用setAccessible(true)跳过权限验证 123456Class clazz = Class.forName(&quot;User&quot;);Constructor cons = clazz.getDeclaredConstructor(String.class);System.out.println(cons.getModifiers());cons.setAccessible(true);//设定权限验证User user = (User)...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" title="SpringMVC之登录校验">SpringMVC之登录校验</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-13T07:21:29.000Z" title="发表于 2025-07-13 15:21:29">2025-07-13</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/">会话技术</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Token/">Token</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Filter/">Filter</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Intercetor/">Intercetor</a></span></div><div class="content">SpringMVC之登录校验 登录功能的实现比较简单，只需要根据输入的用户名和密码，或者其他登录验证形式，到数据库查询是否有这条数据就可以了。 但实际上这是一个伪登录的功能。因为HTTP协议是一种无状态的协议，所以在后续的访问中无法记录登录状态。也就是登录校验功能没有实现，下边来详细讲解一下该功能的实现。 graph LR 浏览器--&gt;|请求|拦截器 拦截器--&gt;|响应|浏览器 拦截器--&gt;login 拦截器--&gt;Controller接口 login--&gt;|存|登录标记 登录标记--&gt;|取|拦截器 上图展示了登录验证这一业务的实现流程   实现登录标记：会话技术   实现统一拦截：过滤器(filter)、拦截器(interceptor)   下边介绍这些技术 会话技术  会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应 会话跟踪：一种维护浏览器状态的方法，服务器需要多次请求是否来自于同一浏览器，以便在同一次会话的多次请求之间能够共享数据  Cookie 客户端会话跟踪技术 服务端在响应的响应头里携带Set-Cookie：name=value 之后浏览器在请求时请求头里携带Cookie：name=value 优点：  HTTP协议中支持的技术，浏览器自动进行  缺点：   在移动端无法使用Cookie   不安全，用户可以自己禁用Cookie   Cookie不能跨域   session 服务器会话跟踪技术,是基于Cookie实现的 缺点   服务器集群环境下无法使用session   cookie的缺点：因为底层就是用cookie实现的   令牌技术 优点：   支持PC端和移动端，因为现在不需要把令牌存储在Cookie中，其他的存储空间也是可以的   解决集群环境下的认证问题   减轻服务器端的存储压力   后边在redis还会详细讲解其实现 JWT令牌：（令牌的一种形式） JSON Web Token（https://jwt.io） 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全传输信息。由于数字签名的存在，这些信息是可靠的。 JWT令牌的组成： 第一部分：Header（头），记录令牌类型、签名算法等。 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。 第三部分：Signature（数字签名），防止Token被篡改，确保安全性。融入header、payload，并加入指定秘钥，通过指定签名算法计算而来。 介绍一下Base64编码：是一种基于64个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式。 JWT校验：  JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的 如果JWT令牌解析时报错，则说明JWT令牌被篡改或失效了，令牌非法  JWT校验需要使用统一拦截的技术，下面将会讲解统一拦截的实现方式 统一拦截 过滤器 过滤器(Filter)是JavaWeb三大组件（Filter、Servlet、Listener）之一。 过滤器可以把对资源的请求拦截下来，从而实现一些特殊功能 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等 Filter快速入门：（并不重要） 定义：实现Filter接口 配置： 在实现类上加上@WebFilter(urlPatterns=“/*”)表示拦截路径 Filter并不是SpringBoot的组件，所以需要在启动类上加上@ServletComponentScan 过滤器的执行流程  graph LR 	浏览器--&gt;|请求|Filter 	 	subgraph...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/04/Redis/" title="Redis">Redis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-04T10:00:54.000Z" title="发表于 2025-07-04 18:00:54">2025-07-04</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a></span></div><div class="content">Redis基础部分 介绍 Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征：  键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码） 支持数据持久化 支持主从集群、分片集群 支持多语言客户端  redis安装 关于redis，这里推荐装linux版的。 所以建议先学习安装linux和它的常用vi命令。这里做几点建议：  win10及以上可以直接使用自带的wsl2来安装linux子系统，具体教程b站上有。我使用的是Ubuntu，并且没有什么问题 redis的安装和测试可以参考这个教程如何在 Ubuntu 20.04 上安装和配置 Redis-阿里云开发者社区  redis常用的命令 命令不用死记，建议去redis官网查询命令 又或者，你也可以在命令行中使用help [command]来查询,例如：  下边总结常用的命令   KEYS：查看符合模版的所有key，不建议在生产环境设备上使用，因为效率过低   DEL：删除一个指定的key   EXISTS：判断key是否存在   EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除   TTL：查看一个key的剩余有效期   String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型 其value是字符串，不过根据字符串的格式不同，又可以分为3类：string、int、float String的常见命令  SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的value MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY：让一个整型的key自增并指定步长 INCRYBYFLOAT：让一个浮点类型的数字自增并指定步长 SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX：添加一个String类型的键值对，并指定有效值  Key的层级格式： Redis的key允许有多个单词形成层级结构，多个单词之间用‘:’隔开，这样就会形成层级结构。 Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：  Hash的常见命令：  HSET key field value：添加或修改hash类型key的field的值 HGET key field：获取一个hash类型key的field值 HMSET：批量添加多个hash类型key的field值 HMGET：获取获取多个hash类型key的field值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有field HVALS：获取一个hash类型的key中的所有value HINCRBY：让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行  List类型 Redis中的List类型与Java中的LinkedList基本一致 List的常见命令：  LPUSH key element…：想列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element…：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil  如何利用List结构模拟一个栈?  入口和出口在同一边  如何利用List结构模拟一个队列？  入口和出口在不同边  如何利用List结构模拟一个阻塞队列？  入口和出口在不同边 出队时采用BLPOP或BRPOP  Set类型 Redis的Set结构和Java中的HashSet类似，可以看做是一个value为null的HashMap。 Set的常见指令：  SADD key member …：向Set中添加一个或多个元素 SREM key member …：移除set中的指定元素 SCARD key：返回set中元素的个数 SISMEMBER key...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/" title="Mybatis入门">Mybatis入门</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Mybatis/">Mybatis</a></span></div><div class="content">修改历史：  2025-06-28 修改了部分错误，优化了文档结构 2025-07-01 修复了代码块sql语句无法高亮的问题  Mybatis入门  0.序 Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili。 1.入门 快速入门 开启一个模版程序，实现使用Mybatis查询所有用户数据  准备工作（创建springboot文件，定义实际类User，数据库表user） 添加mybatis相关依赖，配置mybatis（数据库连接信息） 编写SQL语句（注解/XML）  具体操作流程如下：   创建springboot文件：与springboot入门中的创建方法基本一致，注意要勾选Mybatis Framework和MySQL Driver依赖。   定义实际类：实际类要与数据库中user的字段保证一致，常见的几种类型对应：int-&gt;Integer，varchar-&gt;String，tinyint-&gt;Short，主要使用其包装类。同时声明相应的getset方法、构造器、toString方法。   在properties配置文件中加入以下内容，格式比较固定，url要根据相应的数据库名称确定，密码设定为自己的密码   1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatisspring.datasource.username=rootspring.datasource.password=1234  编写SQL语句（注解/XML）  123456@Mapper//在运行时，MyBatis会扫描这个接口，并为其生成一个实现类对象（代理对象），并交给IOC管理public interface UserMapper &#123;    //查询    @Select(&quot;select * from user&quot;)    public List&lt;User&gt; list();&#125;  单元测试  123456789101112@SpringBootTest//springboot整合单元测试的注解class SpringbootMybatisQuickstartApplicationTests &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testListUser() &#123;        List&lt;User&gt; userList = userMapper.list();        for (User user : userList) &#123;            System.out.println(user);        &#125;    &#125;&#125; 创建完成后的文件结构如图  配置SQL提示 在上边的SQL语句中，如果没有配置，那么就不会显示相应的提示，即使写错了也不会提醒，这对于开发是非常不利的。好在Idea中可以为其配置MySQL数据库连接。  选中SQL语句，右键，配置为MySQL语句 点击右侧边栏的数据库选项，点击加号，数据源选择MySQL，填写host、port、用户和密码、数据库  数据库连接池  数据库连接池是个容器，负责分配、管理数据库连接 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 能够释放空闲时间超过最大空闲时间的连接，避免因为没有释放连接引起的数据库连接遗漏 好处：资源重用 提升系统响应速度...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门">SpringBoot入门</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-06-03T14:30:09.000Z" title="发表于 2025-06-03 22:30:09">2025-06-03</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/">三层架构</a></span></div><div class="content">修改历史：  增加了Web入门的基础知识，完善了结构  SpringBoot入门 0.概述 本篇只是对springboot的基本使用的总结，学习视频-&gt;Day05-01. 请求响应-概述_哔哩哔哩_bilibili，使用postman进行调试。 1.Web入门 HTTP协议 概述 HTTP协议（HyperTextTransferProtocol），超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 特点：  TCP协议：面向连接，安全 基于请求-响应模型：一次请求对应一次响应 HTTP是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的  缺点：多次请求无法共享数据 优点：速度快    请求协议 请求数据包括三个部分： 请求行：请求数据第一行（请求方式，资源路径、协议） 请求头：第二行开始，格式key: value 请求体：POST请求，存放请求参数 两种请求方式对比：   请求方式-get：请求参数在请求行中，没有请求体。get请求大小是有限制的。   请求方式-post：请求参数在请求体中，post请求大小是没有限制的。   响应协议 响应数据包括三部分：   响应行：相应数据第一行（协议、状态码、描述）   响应头：key: value   响应体：存放响应数据   常见状态码：    状态码 描述     1xx 响应中   2xx 成功   3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理   4xx 客户端错误-处理发生错误，责任在客户端。如请求了不存在的资源、客户端未被授权、禁止访问   5xx 服务器错误-处理发生错误，责任在服务端。如程序抛出异常    目前主要了解：200 处理成功，404 请求资源不存在，500 服务器端异常 更多状态码见网站： 状态 | Status - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云 协议解析 服务器端要做的事情，一方面是要根据请求协议，解析浏览器发送的请求；另一方面是要根据响应协议，发送响应数据。 这种解析的工作较为固定，有不少Web服务器已经完成了这些工作，这样后端就只用关注业务逻辑的实现。常见的Web服务器有：Tomcat、IBM、jetty、WebLogic等 Tomcat服务器 具体内容暂时不用详细了解，SpringBoot已经内嵌了Tomcat服务器，所以不用专门下载。介绍在此省略 2.请求 此处请求的含义：后端接收来自浏览器端的请求指令，进行解析 简单参数 请求： GET指令：http://localhost:8080/simpleParam?name=miku&amp;age=16 POST指令：http://localhost:8080/simpleParam请求体：name=Miku&amp;age=16 Java代码： 原始方式： 12345678910//在原始的Web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(HttpServletRequest request) &#123;    String name = request.getParameter(&quot;name&quot;);//需要与请求参数的key保持一致    String ageStr = request.getParameter(&quot;age&quot;);//需要与请求参数的key保持一致    int age = Integer.parseInt(ageStr);    System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age);    return &quot;OK&quot;;&#125;//繁琐，并且需要进行手动类型转换 SpringBoot方式： 简单参数，参数名与形参列表名相同，定义形参即可接收参数 12345@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(int age,String name) &#123;    System.out.println(name + &quot;:&quot; + age);    return...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="JavaSE-网络编程">JavaSE-网络编程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-05-27T10:21:16.000Z" title="发表于 2025-05-27 18:21:16">2025-05-27</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/JavaSE/">JavaSE</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/TCP/">TCP</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Socket/">Socket</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/URl/">URl</a></span></div><div class="content">网络编程 软件架构： CS架构：客户端-服务器 BS架构：浏览器-服务器 不过现在的很多软件都是一种混合开发，就是将CS架构和BS架构融合起来。 网络编程三要素 如何准确定位一台或多态主机：使用IP地址 如何定位主机上的特定的应用：使用端口号 如何可靠、高效地进行数据传输：规范通信协议 IP地址 IP地址：网络中的一台计算机设备做唯一编号 IP地址分类： 分类方式一： IPv4：占用4个字节，表示为a.b.c.d的形式，以点分十进制表示 IPv6：占用16个字节 分类方式二： 公网地址（万维网使用）和私网地址（局域网使用）192.168.开头的就是私有地址 本地回路地址：127.0.0.1 域名：便捷地记录ip地址 www.baidu.com kuoz.top 域名使用中通过DNS解析成IP再进行访问的 端口号 端口号可以唯一标识主机中的进程 不同的进程分配不同的端口号 范围：0~65535 网络通信协议 OSI模型：过于理想化，没能实现 TCP/IP：分为应用层、传输层、网络层、物理+数据链路层 InetAddress类 InetAddress类的一个实例就代表一个具体的ip地址 实例化方式： InetAddress getByName(String host) InetAddress getLocalHost() TCP协议和UDP协议 计算机网络的重要重要指示，在此处简要了解。 TCP的Socket网络编程 网络上具有唯一标识的IP地址和端口号的组合，唯一可识别的标识符套接字（Socket） 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void client() throws IOException &#123;    //创建Socket实例    int port = 8888;    InetAddress address = InetAddress.getByName(&quot;10.10.208.62&quot;);    Socket socket = new Socket(address, port);    //通过Socket创建输出流    OutputStream os = socket.getOutputStream();    //发送数据    os.write(&quot;嗨嗨嗨, 服务器我来辣!&quot;.getBytes());    //关闭Socket及相关流    os.close();    socket.close();&#125;@Testpublic void server() throws IOException &#123;    //创建serverSocket实例    int port = 8888;    ServerSocket serverSocket = new ServerSocket(port);    //接收来自于客户端的Socket    Socket socket = serverSocket.accept();    System.out.println(&quot;客户端连接成功，等待接收数据...&quot;);    System.out.println(&quot;收到了来自&quot;+socket.getInetAddress().getHostAddress()+&quot;的连接&quot;);    //通过Socket创建输入流    InputStream is = socket.getInputStream();    //读写过程    byte[] buffer = new byte[5];    ByteArrayOutputStream baos = new ByteArrayOutputStream();    int len;    while((len = is.read(buffer)) != -1) &#123;        //当byte太小时，这里中文会因为中间被截断而出乱码，通过baos来解决        //String message = new String(buffer, 0, len);        //解决方法        baos.write(buffer, 0, len);    &#125;    System.out.print(baos.toString());    System.out.print(&quot;\n接收完毕&quot;);    //关闭Socket和相关流    is.close();   ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/05/25/Maven/" title="Maven">Maven</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-05-25T12:43:27.000Z" title="发表于 2025-05-25 20:43:27">2025-05-25</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Maven/">Maven</a></span></div><div class="content">Maven 概述 Maven是一款管理和构建Java项目的工具。基于POM（项目对象模型）的概念，通过一小段描述来管理项目 Maven坐标，唯一标识和定位一个项目 groupId：组织 artifactId：模块名称 version：版本 仓库：用于存储资源，管理jar包 本地仓库：自己计算机上的一个目录 中央仓库：由Maven团队维护的全球唯一的仓库 远程仓库：一般由公司团队搭建的私有仓库 使用顺序：本地仓库&gt;远程仓库&gt;中央仓库 依赖管理 依赖：指当前项目运行所需的jar包 配置依赖（在IDEA中）  在pom.xml中编写标签 在标签中使用引入坐标 定义坐标的groupId，artifactId，version 点击刷新按钮，引入最新加入的坐标  12345678&lt;dependencyies&gt;	&lt;dependency&gt;    	&lt;groupId&gt;&lt;/groupId&gt;        &lt;artifactId&gt;&lt;/artifactId&gt;        &lt;version&gt;&lt;/version&gt;    &lt;/dependency&gt;    ...&lt;/dependencyies&gt; 依赖传递 依赖具有传递性   直接依赖：在当前项目中通过依赖配置建立的关系   间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源   排除依赖：主动断开依赖的资源，被排除的资源无需指定版本   123456&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;&lt;/groupId&gt;        &lt;artifactId&gt;&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;   依赖范围    scope值 主程序 测试程序 打包（运行） 范例     compile(默认) Y Y Y log4j   test - Y - junit   provided Y Y - servlet-api   runtime - Y Y jdbc驱动    可以通过下面的xml标签来设置依赖范围 1&lt;scope&gt;...&lt;/scope&gt; 生命周期 每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。（运行后面的阶段，前面的阶段也会运行） 生命周期阶段（常见）    常见生命周期阶段      clean 移除上一次构建生成的文件   compile 编译项目源代码   test 使用合适的单元测试框架运行测试   package 将编译后的文件打包，如：jar、war等   install 安装项目到本地仓库    </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/05/24/MySQL/" title="MySQL">MySQL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-05-24T13:58:00.000Z" title="发表于 2025-05-24 21:58:00">2025-05-24</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span></div><div class="content">修改历史：  2025-07-01 修复了sql语句的代码快无法高亮的问题  MySQL-基础 数据库管理系统DBMS MySQL数据模型 客户端-&gt;DBMS-&gt;多个数据库-&gt;多个二维表 SQL语句 DDL(Data Definition Language)数据定义语言（数据库、表、字段） DML(Data Manipulation Language)数据操作语言 DQL(Data Query Language)数据查询语言 DCL(Data Control Language)数据控制语言，管理数据库用户，控制数据库的访问权限 DDL-数据定义 数据库操作    大类 语句 作用     查询 show databases 查询所有数据库    select database() 查询当前数据库   创建 create database [if not exists] 数据库名 （如果不存在）创建一个数据库   使用 use 数据库名; 使用数据库   删除 drop database [if exists] 数据库名 删除数据库    表操作-查询    语句 作用     show tables; 查询当前数据库所有表   desc 表名; 查询表结构   show create table 表名; 查询指定表的建表语句    表操作-创建 12345create table 表名(	字段1 字段类型 [约束] [comment 字段1注释],    ……    字段n 字段类型 [约束] [comment 字段1注释])[comment 表注释]; 关于约束：    约束 描述 关键字     非空约束 限制字段值不能为null not null   唯一约束 保证字段所有数据唯一 unique   主键约束 主键是一行数据的唯一标识，非空且唯一 primary key   默认约束 字段未指定值则用默认值 default   外键约束 让两张表的数据建立连接 foreign key    字段数据类型 数值    类型 大小（byte） 描述     tinyint 1 小整数值   smallint 2 大整数值   mediumint 3 大整数值   int 4 大整数值   bigint 8 极大整数值   float 4 单精度浮点数   double 8 双精度浮点数   decimal  小数值（精确定点数)    例如double,需使用double(整个数的长度，小数部分长度) 字符串    类型 描述     char 定长字符串   varchar 变长字符串   tinyblob 不超过255个字符的二进制数据   tinytext 短文本字符串   blob 二进制形式的长文本数据   text 长文本数据   midiumblob 二进制形式的中等长度文本数据   midiumtext 中等长度文本数据   longblob 二进制形式的极大文本数据   longtext 极大文本数据    日期时间     大小 范围 格式 描述     date 3 1000-01-01至9999-12-31 YYYY-MM-DD 日期值   time 3 -838:59:59至838:59:59 HH:MM:SS 时间值或持续时间   year 1 1901至2155 YYYY 年份值   datatime 8 1000-01-01 00:00:00至9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值   timestamp 4 1970-01-01 00:00:01至2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳    修改、删除表结构 语言可以不掌握，但是要会图形化操作 DML-数据操作 添加数据： insert into 表名(字段1，字段2，……) values(值1,值2,……);  字符串应该和日期型数据应该包含在引号内 插入的数据大小，应该在字段的规定范围内  修改数据 update 表名 set 字段名1=值1,字段名2=值2,…[where 条件] 删除数据 delete from 表名 [where 条件] DQL-数据查询 基本查询： 基本查询 select 字段列表 from 表名; select * from 表名;（不建议在开发中使用这种方式，因为不直观） 起别名 select 字段 as ‘别名’ from 表名;as可省略 去重 select distinct 字段名称 from 表名; 条件查询： select 字段列表 from 表名...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/05/06/JavaSE-Java8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/" title="JavaSE-Java8的两个重要特性">JavaSE-Java8的两个重要特性</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-05-06T13:14:11.000Z" title="发表于 2025-05-06 21:14:11">2025-05-06</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/JavaSE/">JavaSE</a></span></div><div class="content">jdk8 新特性 函数式接口： 函数式接口是什么？如果接口中只声明有一个抽象方法，则此接口称为函数式接口(FunctionalInterface) 为什么要有函数式接口？因为只有给函数式接口创建对象时，才可以使用lambda表达式。 java8中声明的函数式接口所在包：java.util.function 4个基本的函数式接口：（直接copy宋的课件）    函数式接口 称谓 参数类型 用途     Consumer&lt;T&gt;   消费型接口 T 对类型为T的对象应用操作，包含方法：  void accept(T t)     Supplier&lt;T&gt;   供给型接口 无 返回类型为T的对象，包含方法：T get()     Function&lt;T, R&gt;   函数型接口 T 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)     Predicate&lt;T&gt;   判断型接口 T 确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：boolean test(T t)      lambda表达式 lambda表达式怎么用？ 语法规则： -&gt;的左边：lambda的形参列表，参数的类型都可以省略。如果形参列表只有一个，则一对()也可以省略。 -&gt;的右边：lambda体，只有一行执行语句时，则一对{}可以省略，如果有return，则也要省略。 写法举例 1Comparator&lt;Integer&gt; com = (o1 , o2) -&gt; Integer.compara(o1,o2); lambda表达式的本质： 一方面，lambda表达式作为接口实现类的对象；另一方面，lambda表达式是匿名函数。 方法引用   方法引用可以看作是lambda表达式的进一步刻画。   当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。  当满足一定的条件是，我们还可以使用方法引用或构造器引用替换lambda表达式。    方法引用作为了函数式接口的实例。 格式：  对象 :: 实例方法 要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。 注意此方法b是非静态方法，需要对象调用。 类 :: 静态方法 要求：函数式接口的抽象方法a与其内部实现时调用的对象的某个静态方法b的形参列表和返回值类型都相同。此时可以考虑使用方法b实现对a的替换、覆盖。 注意此方法b是静态方法，需要类调用。 类 :: 实例方法 要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第一个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。 注意此方法b是非静态方法，需要对象调用。但是形式上，写出对象a所属的类。  构造器引用 格式：类名 :: new 调用了类名对应的类中某一个确定的构造器。具体调用的是类中的哪一个构造器，取决于函数式接口的抽象方法的形参列表。 数组引用 格式：数组名 :: new StreamAPI Stream使用的流程  实例化 一系列的中间操作 执行终止操作  实例化： 三种方法： 方法一：通过集合 例如：对于List结构，直接使用list.stream()就能创建stream实例 方法二：通过数组 类似方法一，使用Arrays的静态方法stream()Arrays.stream(arr) 方法三：streamof public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流 例如： 12Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5);stream.forEach(System.out::println); 中间操作： 筛选与切片 123456789101112131415@Testpublic void test1() &#123;    //创建Stream    List&lt;Employee&gt; list = EmployeeData.empData();    Stream&lt;Employee&gt; stream = list.stream();    //filter(Predicate p) 过滤    stream.filter(e -&gt; e.getAge() &gt;...</div></div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KuoZ</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CV-Elevation"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这是一个专属于我（KuoZ）的空间，它用来记录我的学习笔记、硬件或软件开发中的经验、还有吹水等等内容。本网站使用HEXO框架搭建。旧的两篇博客在博客园https://www.cnblogs.com/pulse1454</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/" title="Spring框架">Spring框架</a><time datetime="2025-07-18T08:53:50.000Z" title="发表于 2025-07-18 16:53:50">2025-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" title="SpringMVC之登录校验">SpringMVC之登录校验</a><time datetime="2025-07-13T07:21:29.000Z" title="发表于 2025-07-13 15:21:29">2025-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/04/Redis/" title="Redis">Redis</a><time datetime="2025-07-04T10:00:54.000Z" title="发表于 2025-07-04 18:00:54">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/" title="Mybatis入门">Mybatis入门</a><time datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Filter/" style="font-size: 1.1em; color: #999">Filter</a> <a href="/tags/Intercetor/" style="font-size: 1.1em; color: #999">Intercetor</a> <a href="/tags/JavaSE/" style="font-size: 1.5em; color: #99a9bf">JavaSE</a> <a href="/tags/Maven/" style="font-size: 1.1em; color: #999">Maven</a> <a href="/tags/MySQL/" style="font-size: 1.1em; color: #999">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 1.1em; color: #999">Mybatis</a> <a href="/tags/Redis/" style="font-size: 1.1em; color: #999">Redis</a> <a href="/tags/Socket/" style="font-size: 1.1em; color: #999">Socket</a> <a href="/tags/Spring/" style="font-size: 1.1em; color: #999">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 1.1em; color: #999">SpringBoot</a> <a href="/tags/TCP/" style="font-size: 1.1em; color: #999">TCP</a> <a href="/tags/Token/" style="font-size: 1.1em; color: #999">Token</a> <a href="/tags/URl/" style="font-size: 1.1em; color: #999">URl</a> <a href="/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/" style="font-size: 1.1em; color: #999">三层架构</a> <a href="/tags/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/" style="font-size: 1.1em; color: #999">会话技术</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.1em; color: #999">随笔</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">4</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/05/">
            <span class="card-archive-list-date">
              五月 2025
            </span>
            <span class="card-archive-list-count">9</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/04/">
            <span class="card-archive-list-date">
              四月 2025
            </span>
            <span class="card-archive-list-count">5</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/03/">
            <span class="card-archive-list-date">
              三月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">21</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">53.1k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-07-19T05:29:24.827Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/miku2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By KuoZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>