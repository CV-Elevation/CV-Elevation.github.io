<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>KuoZ's blog</title><meta name="author" content="KuoZ"><meta name="copyright" content="KuoZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta property="og:type" content="website">
<meta property="og:title" content="KuoZ&#39;s blog">
<meta property="og:url" content="http://cv-elevation.github.io/index.html">
<meta property="og:site_name" content="KuoZ&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cv-elevation.github.io/img/holo.jpg">
<meta property="article:author" content="KuoZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cv-elevation.github.io/img/holo.jpg"><link rel="shortcut icon" href="/img/Myfavicon2.ico"><link rel="canonical" href="http://cv-elevation.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KuoZ\'s blog',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="KuoZ's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/MyPage/"><i class="fa-fw fas fa-gamepad"></i><span> 丝之歌</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/img/miku2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">KuoZ's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/MyPage/"><i class="fa-fw fas fa-gamepad"></i><span> 丝之歌</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">KuoZ's blog</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/08/06/2025%E7%94%B5%E8%B5%9B%E5%B0%8F%E7%BB%93/" title="2025电赛小结">2025电赛小结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-08-06T01:27:54.000Z" title="发表于 2025-08-06 09:27:54">2025-08-06</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></span></div><div class="content">2025年电赛小结 序言： 2025年电赛，我们选做的是G题。目前还没有出结果，估计最后不加报告是70分，进国测应该是没希望了。不过对于一个已经转码，决定不搞硬件的人来说其实可以接受了。 日志： 2025年7月30日上午 选定题目 D、G甚至F G：感觉难点在于如何复现信号，保证同频 D：应该算精密测量了 F：完全不想做 G题大题思路： G题最重要的就是测量后DAC复现的问题：   数字滤波器？参数固定，不可即时更改(deprecated)（赛后补充，其实我最开始这个想法是正确的，但是和队长商量后他给出了这样的回复，总之就是还是不熟悉吧，也实现不了）   使用dds合成后dac输出，高精度，或许可以抵消滚波（赛后补充，赛后证明是可以的方案，确实可以实现无反馈锁相，只要输出的基波频率足够准确）   基础部分：  搭出预设的电路  经仿真，是一个低通滤波器 且在100Hz~3kHz范围内放大倍数约在5~0.7倍  后续电压步进要在0.1V，所以dac精度应至少有0.02V  使用ad9959可以轻松达到此精度 发挥部分： 现在有3种方案 1.FIR 2.FFE 3.高精度DDS 串口屏需求： 基础  不加电路100~1MHz正弦波输出 加电路2V 1kHz  1~2V 步长0.1V（100Hz~3kHz）[设置+启动]  发挥  滤波类型判断（学习键） 数字重现（一键启动探究装置）  2025年7月31日上午 完成了基础部分的全部内容，硬件结构有9959-&gt;放大器-&gt;已知电路模型 12:53:48 “如果解决不了这个问题，就等着退赛吧”，这是队长的原话。 起因是想移植之前写的fft到队长发来的代码框架，但是之后发生了严重问题！ 这个程序只要一烧写，芯片就会死锁，然后死掉，程序也不能运行，以为是烧写器或板子的问题，就又换了一个板子，可谁曾想，换了之后另一个板子也崩了。 结果就是stm32都用不了了，这如果解决不了，我们就要退赛了。 烧写后，一直报cannot halt the core，知道这大概是死锁了，原因大概是flash中的程序上电后就在跑，导致了无法烧写。 在经过约一个小时的调试，找到了比较好的解决办法 首先记得条stlink的模式为normal，能够识别到stlink之后参考下述博客 stm32 Invalid Rom Table...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" title="Redis之多级缓存">Redis之多级缓存</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-23T11:01:55.000Z" title="发表于 2025-07-23 19:01:55">2025-07-23</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/lua/">lua</a></span></div><div class="content">Redis之多级缓存——亿级流量方案 序言 传统缓存问题： 传统缓存一般是请求到达Tomcat后，Tomcat先查询Redis缓存，如果未命中则查询数据库。存在下面问题：  请求要经过Tomcat服务器，Tomcat的性能成为整个并发缓存的瓶颈 如果Redis缓存失效，会对数据库产生冲击  多级缓存 充分利用各环节，分别添加缓存，减轻Tomcat的压力 客户端缓存-&gt;NGINX本地缓存-&gt;Redis-&gt;Tomcat-&gt;DB 其中Nginx缓存是业务Nginx，通常部署为集群，再由专门的Nginx做反向代理 JVM进程缓存 Caffeine技术 缓存驱逐策略：  基于容量、基于时间、基于引用  实现效果：  第一次查询走数据库，然后就会放入缓存，之后查询就走缓存  Lua语法 轻量小巧的脚本语言 数据类型 nil、boolean、number、string、function、table、type函数 变量 声明变量 12345local var_name = var_value#数组local arr = &#123;&#x27;java&#x27;,&#x27;python&#x27;,&#x27;c++&#x27;&#125;#maplocal map = &#123;name = &#x27;Jack&#x27;,age = 2&#125; 访问数组，下标从一开始arr[1] 访问Map， 12map[&#x27;name&#x27;]map.name 循环遍历 1234567local arr = &#123;&#x27;Java&#x27;,&#x27;lua&#x27;,&#x27;python&#x27;&#125;for index,value in ipairs(arr) do    print(index,value)  	endfor key,value in pairs(map) do    prinr(key,value)    end 函数 1234function fun_name(para)    ---    return nil    end 条件控制 123456if(布尔表达式)    then    ---    else    ---    end 多级缓存 配置nginx   OpenResty是基于Nginx的高性能Web平台   OpenResty使用流程类似于Nginx的使用   监听路径类似于Response Lua文件类似于Service层   请求参数处理，不同参数格式有相应解析代码   nginx查询Tomcat 小规律：服务器前三位地址相同，第四位换为1 nginx提供了内部API用以发送http请求 Tomcat集群的负载均衡 保证缓存一直生效，同一路径访问同一服务器 修改负载均衡算法由轮询改为Hash算法来直接匹配 添加Redis缓存 冷启动：服务器初启动时，没有缓存，此时查询会都导向数据库，带来较大的数据库压力 缓存预热：利用大数据统计热点数据，将热点数据存到缓存 实现nginx优先查询Redis缓存： OpenResty如何操作Redis？ OpenResty提供了操作Redis的模块，大概模块如下：   封装函数，从Redis读取数据并返回   引入Redis模块，并初始化Redis模块   封装函数，释放Redis连接，其实是放入连接池   Nginx本地缓存 利用shared dict开启词典 修改查询逻辑，加入缓存业务 缓存同步 三种方式  设置有效期 同步双写，在修改数据的同时直接修改缓存 异步通知，改数据库时发事件通知，相关服务进行监听到通知后修改缓存  监听mysql，使用MQ/canal实现 canal基于mysql的主从模式，canal伪装为mysql的一个slave节点完成通知 </div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/" title="分布式缓存——Redis高级篇">分布式缓存——Redis高级篇</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-20T16:55:44.000Z" title="发表于 2025-07-21 00:55:44">2025-07-21</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/">Redis 分布式缓存</a></span></div><div class="content">分布式缓存——Redis高级篇 单节点Redis问题  数据丢失问题：实现Redis数据持久化 并发能力问题：搭建主从集群，实现读写分离 故障恢复问题：Redis哨兵，实现健康检测和自动恢复 存储能力问题：搭建分片集群，利用插槽机制实现动态扩容  一、持久化 方式之一：RDB持久化 RDB全称RedisDatabaseBackup file（Redis数据备份文件） 有两个命令可以进行RDB持久化  save命令：由主进程执行RDB，会阻塞所有命令 bgsave命令：开子进程执行RDB，避免主进程受影响  默认Redis停机时会执行一次RDB （停机≠宕机） 可以通过修改redis.conf文件来配置相关的RDB参数 1234567save 900 1 #900秒内由1次修改，就会执行bgsave。参数可以进行修改#是否压缩，建议不开启，压缩也会消耗CPU，磁盘的话相对不值钱rdbcompression yes#RDB文件名称dbfilename dump.rdb#文件保存的路径目录dir ./ bgsave流程 bgsave开始时会fork主进程得到子进程（在fork过程中主进程会被阻塞），子进程共享主进程的内存数据。fork后主进程可以正常读写，子进程会读取内存数据并写入RDB文件。 如果只是这样可能会有脏数据的问题，就是说在子进程读的时候主进程可能更改了数据。 要理解这个问题，需要理解内存结构。  如图是我参考课程使用visio绘制的fork框图，下面结合这个来解释一下fork的流程。 首先是关于linux的结构，在linux中，进程都是不能直接更改物理内存的，它在虚拟内存中，通过一个页表来维护关系，进程通过修改页表修改内存中的数据。 当使用bgsave的时候，首先会进行fork，会开启子进程，子进程复制主进程的页表，复制完后，为避免脏读的情况，会将数据A和数据B设为只读的共享内存，这样子进程在存储RDB时就不会被主进程干扰。 相应的主进程要更改数据，数据B会被拷贝为数据B的副本，主进程通过修改副本实现修改的功能。 因为内存进行了拷贝，所以极限情况下可能会占用两倍的内存，这也就是为什么使用Redis都要预留一定的内存空间。 RDB缺点：  RDB间隔较长，两次RDB间由数据丢失风险 fork子进程、压缩写出RDB比较耗时  方式二：AOF持久化 AOF全程Append Only File（追加文件），可以看成命令日志文件 可以通过redis.conf配置文件开启和配置AOF 1234567#开启appendonly yesappendfilename &quot;名字&quot;#频率appendfsync always#每执行一次命令，立即写到AOFappendfsync everysec#写命令执行完先放入AOF缓冲区，每隔一秒将缓冲数据写到AOFappendfsync no#写命令执行完先放入AOF缓冲区，由操作系统决定什么时候将缓冲数据写到AOF AOF体积压缩 因为AOF记录的是每条命令，多条命令叠加下可能很多命令是无效的，所以体积会很大。 可以使用bgrewriteaof命令将AOF文件进行重写以减小体积 什么时候进行重写？ 可以在redis.conf文件中配置 12auto-aof-rewrite-percentage 100#AOF文件增长超过多少百分比触发重写auto-aof-rewrite-min-size 64mb#AOF文件体积最小多大以上触发重写 RDB和AOF对比 各有优缺点，如果对数据安全性要求较高，在实际开发中往往会将两种方式结合起来使用     RDB AOF     持久化方式 定时对整个内存做快照 记录每一次执行的命令   数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略   文件大小 会有压缩，文件体积小 记录命令，文件体积大   宕机恢复速度 很快 慢   数据恢复优先级 低，因为数据完整性不如AOF 高，因为数据完整性高   系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源   使用场景 可以容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高    二、主从集群  搭建主从架构   开启主从关系 1replicaof/slaveof(5.0之前) host...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/" title="Spring框架">Spring框架</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-18T08:53:50.000Z" title="发表于 2025-07-18 16:53:50">2025-07-18</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Spring/">Spring</a></span></div><div class="content">Spring Framework Java开发要用的Spring家族的基础就是SpringFramework、SpringBoot、SpringCloud。这里笔记记录的就是SpringFramework技术，学习视频是黑马的SSM快速入门Spring-01-初识Spring_哔哩哔哩_bilibili 要注意的是，本内容仅是对Spring框架应用的学习以及架构的认识，更加深入的内容要在Spring源码的部分进一步学习。 Spring系统架构  IoC（Inversion of Control）控制翻转 使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象的创建控制权由程序转移到外部，这个思想就是控制翻转。 IoC、Bean和DI：   Spring提供了一个容器，称为IoC容器，用来充当Ioc思想中的“外部”   IoC容器负责对象的创建、初始化的一系列工作，被创建或管理的对象在IoC容器中统称为Bean   DI（依赖注入）在容器中建立起bean与bean之间的关系   我们这样做的目的是充分解耦，具体做法可以概括如下：  使用IoC容器管理bean（IoC） 在IoC容器中将有依赖关系的bean进行关系绑定（DI）  bean管理 bean作用范围 bean的作用范围对应着scope属性，主要就是控制其是否为单例。 为什么bean默认为单例？  IoC容器就适合管理单例的对象，这样才能有效地提高效率。  适合交给容器管理的bean  表现层对象 业务层对象 数据层对象 工具对象  不适合交给容器管理的bean  封装实体的域对象、  bean的实例化  构造方法（常用）  提供可访问的构造方法 配置  无参构造器如果不存在，会抛出BeanCreationException   静态工厂（了解） 实例工厂（了解） 使用FactoryBean实例化，其中有三个方法，用来得到Bean实例、设定Bean类型、设定是否为单例（实用）  bean的生命周期  bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做的一些事情  生命周期控制  配置的方式 接口控制  bean的生命周期 初始化容器  创建对象（内存分配） 执行构造方法 执行属性注入（set操作） 执行bean初始化方法  使用bean  执行业务操作  关闭/销毁容器  执行bean销毁方法  bean销毁 容器关闭前触发bean的销毁 关闭容器方式：  手动关闭容器，ConfigurableApplicationContext接口close()操作 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机，ConfigurableApplicationContext接口registerShutdownHook()操作  总结 bean相关标签属性 123456789101112&lt;bean    id=&quot;bookDao&quot;    name=&quot;dao bookDaoImpl daoImpl&quot;    class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;    scope=&quot;singleton&quot;    init-method=&quot;init&quot;    destroy-method=&quot;destory&quot;    autowire=&quot;byType&quot;    factory-method=&quot;getInstance&quot;    factory-bean=&quot;com.itheima.factory.BookDaoFactory&quot;    lazy-init=&quot;true&quot;      /&gt;  id: bean的Id name: bean别名 class: bean类型，静态工厂类，FactoryBean类 scope: 控制bean的实例数量 init-method: 生命周期初始化方法 destroy-method: 生命周期销毁方法 autowire: 自动装配类型，实际开发一般用注解，该属性一般不用 factory-method: bean工厂方法，应用于静态工厂或实例工厂 factory-bean: 实例工厂bean lazy-init: 控制bean延迟加载  依赖注入 手动装配  setter注入  引用类型使用ref配置 简单类型：使用property标签value属性进行配置 12&lt;property name=&quot;bookDao&quot;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/JavaSE/">JavaSE</a></span></div><div class="content">学到Spring框架发现自己JavaSE的反射还没学，就滚过来学反射了。 黑马的这个课讲的真不错，比尚硅谷的那个要简练一些，很轻松就能听懂了。 反射  Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.  官方对反射的描述：反射允许以编程方式访问已加载类的字段、方法和构造函数的信息，并在安全限制范围内使用反射字段、方法和构造函数来操作其底层对应项。 总之反射就是要获取某个类的Class文件，并解剖出它的成员变量、成员方法和构造方法。 反射第一步：获取class 要获取class，总共有三种方法  Class.forName(&quot;全类名&quot;) 类名.class 对象.getClass()  说明：  1中的全类名指的是包名+类名，一般可以直接复制粘贴 3的getClass方法是Object里的方法，所以所有对象都可以调用 三种方法虽然都可以获取class，但是对应的阶段不同  1对应的是源代码阶段 2对应的是加载到内存的阶段，一般作参数传递 3对应的是运行时阶段，只有这个类的对象创建时才能使用    反射第二步：获得并使用构造方法、属性、成员方法 Java中有一个重要的思想就是万事万物皆对象，相应的，构造方法、属性和成员方法也有其对应的类 属性（Field类）、成员方法（Method类）、构造方法（Constructor） 1.获得并使用构造方法  Class类中的方法：  1234Constructor&lt;?&gt;[] getConstrutors();Constructor&lt;?&gt;[] getDeclaredConstrutors();Constructor&lt;?&gt; getConstrucor(参数列表（注意传参数对应的class对象）);Constructor&lt;?&gt; getDeclaredConstrucor(参数列表（注意传参数对应的class对象）);  使用Constructor类的方法，获得修饰符、名字、形参、对象创建  123public int getModifiers();//获得权限修饰符getName();getParameters();//获取参数列表 （IDEA底层的代码提示其实就是用的反射） 关于modifiers()    变量和类型 常量字段 值     public static final int ABSTRACT 1024   public static final int FINAL 16   public static final int INTERFACE 512   public static final int NATIVE 256   public static final int PRIVATE 2   public static final int PROTECTED 4   public static final int PUBLIC 1   public static final int STATIC 8   public static final int STRICT 2048   public static final int SYNCHRONIZED 32   public static final int TRANSIENT 128   public static final int VOLATILE 64    使用暴力反射进行对象的创建： 对于私有构造器的使用，注意使用setAccessible(true)跳过权限验证 123456Class clazz = Class.forName(&quot;User&quot;);Constructor cons = clazz.getDeclaredConstructor(String.class);System.out.println(cons.getModifiers());cons.setAccessible(true);//设定权限验证User user = (User)...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/13/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/" title="SpringMVC之登录校验">SpringMVC之登录校验</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-13T07:21:29.000Z" title="发表于 2025-07-13 15:21:29">2025-07-13</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/">会话技术</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Token/">Token</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Filter/">Filter</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Intercetor/">Intercetor</a></span></div><div class="content">SpringMVC之登录校验 登录功能的实现比较简单，只需要根据输入的用户名和密码，或者其他登录验证形式，到数据库查询是否有这条数据就可以了。 但实际上这是一个伪登录的功能。因为HTTP协议是一种无状态的协议，所以在后续的访问中无法记录登录状态。也就是登录校验功能没有实现，下边来详细讲解一下该功能的实现。 graph LR 浏览器--&gt;|请求|拦截器 拦截器--&gt;|响应|浏览器 拦截器--&gt;login 拦截器--&gt;Controller接口 login--&gt;|存|登录标记 登录标记--&gt;|取|拦截器 上图展示了登录验证这一业务的实现流程   实现登录标记：会话技术   实现统一拦截：过滤器(filter)、拦截器(interceptor)   下边介绍这些技术 会话技术  会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应 会话跟踪：一种维护浏览器状态的方法，服务器需要多次请求是否来自于同一浏览器，以便在同一次会话的多次请求之间能够共享数据  Cookie 客户端会话跟踪技术 服务端在响应的响应头里携带Set-Cookie：name=value 之后浏览器在请求时请求头里携带Cookie：name=value 优点：  HTTP协议中支持的技术，浏览器自动进行  缺点：   在移动端无法使用Cookie   不安全，用户可以自己禁用Cookie   Cookie不能跨域   session 服务器会话跟踪技术,是基于Cookie实现的 缺点   服务器集群环境下无法使用session   cookie的缺点：因为底层就是用cookie实现的   令牌技术 优点：   支持PC端和移动端，因为现在不需要把令牌存储在Cookie中，其他的存储空间也是可以的   解决集群环境下的认证问题   减轻服务器端的存储压力   后边在redis还会详细讲解其实现 JWT令牌：（令牌的一种形式） JSON Web Token（https://jwt.io） 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全传输信息。由于数字签名的存在，这些信息是可靠的。 JWT令牌的组成： 第一部分：Header（头），记录令牌类型、签名算法等。 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。 第三部分：Signature（数字签名），防止Token被篡改，确保安全性。融入header、payload，并加入指定秘钥，通过指定签名算法计算而来。 介绍一下Base64编码：是一种基于64个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式。 JWT校验：  JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的 如果JWT令牌解析时报错，则说明JWT令牌被篡改或失效了，令牌非法  JWT校验需要使用统一拦截的技术，下面将会讲解统一拦截的实现方式 统一拦截 过滤器 过滤器(Filter)是JavaWeb三大组件（Filter、Servlet、Listener）之一。 过滤器可以把对资源的请求拦截下来，从而实现一些特殊功能 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等 Filter快速入门：（并不重要） 定义：实现Filter接口 配置： 在实现类上加上@WebFilter(urlPatterns=“/*”)表示拦截路径 Filter并不是SpringBoot的组件，所以需要在启动类上加上@ServletComponentScan 过滤器的执行流程  graph LR 	浏览器--&gt;|请求|Filter 	 	subgraph...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/07/04/Redis/" title="Redis">Redis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-04T10:00:54.000Z" title="发表于 2025-07-04 18:00:54">2025-07-04</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a></span></div><div class="content">Redis基础部分 介绍 Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征：  键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码） 支持数据持久化 支持主从集群、分片集群 支持多语言客户端  redis安装 关于redis，这里推荐装linux版的。 所以建议先学习安装linux和它的常用vi命令。这里做几点建议：  win10及以上可以直接使用自带的wsl2来安装linux子系统，具体教程b站上有。我使用的是Ubuntu，并且没有什么问题 redis的安装和测试可以参考这个教程如何在 Ubuntu 20.04 上安装和配置 Redis-阿里云开发者社区  redis常用的命令 命令不用死记，建议去redis官网查询命令 又或者，你也可以在命令行中使用help [command]来查询,例如：  下边总结常用的命令   KEYS：查看符合模版的所有key，不建议在生产环境设备上使用，因为效率过低   DEL：删除一个指定的key   EXISTS：判断key是否存在   EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除   TTL：查看一个key的剩余有效期   String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型 其value是字符串，不过根据字符串的格式不同，又可以分为3类：string、int、float String的常见命令  SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的value MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY：让一个整型的key自增并指定步长 INCRYBYFLOAT：让一个浮点类型的数字自增并指定步长 SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX：添加一个String类型的键值对，并指定有效值  Key的层级格式： Redis的key允许有多个单词形成层级结构，多个单词之间用‘:’隔开，这样就会形成层级结构。 Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：  Hash的常见命令：  HSET key field value：添加或修改hash类型key的field的值 HGET key field：获取一个hash类型key的field值 HMSET：批量添加多个hash类型key的field值 HMGET：获取获取多个hash类型key的field值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有field HVALS：获取一个hash类型的key中的所有value HINCRBY：让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行  List类型 Redis中的List类型与Java中的LinkedList基本一致 List的常见命令：  LPUSH key element…：想列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element…：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key start end：返回一段角标范围内的所有元素 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil  如何利用List结构模拟一个栈?  入口和出口在同一边  如何利用List结构模拟一个队列？  入口和出口在不同边  如何利用List结构模拟一个阻塞队列？  入口和出口在不同边 出队时采用BLPOP或BRPOP  Set类型 Redis的Set结构和Java中的HashSet类似，可以看做是一个value为null的HashMap。 Set的常见指令：  SADD key member …：向Set中添加一个或多个元素 SREM key member …：移除set中的指定元素 SCARD key：返回set中元素的个数 SISMEMBER key...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/06/08/Mybatis%E5%85%A5%E9%97%A8/" title="Mybatis入门">Mybatis入门</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-06-08T12:02:16.000Z" title="发表于 2025-06-08 20:02:16">2025-06-08</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Mybatis/">Mybatis</a></span></div><div class="content">修改历史：  2025-06-28 修改了部分错误，优化了文档结构 2025-07-01 修复了代码块sql语句无法高亮的问题  Mybatis入门  0.序 Mybatis是持久层（也就是三层架构中的Dao层）的一款框架，简化了JDBC的开发。内容来自视频-&gt;Day08-14. Mybatis-入门-快速入门程序_哔哩哔哩_bilibili。 1.入门 快速入门 开启一个模版程序，实现使用Mybatis查询所有用户数据  准备工作（创建springboot文件，定义实际类User，数据库表user） 添加mybatis相关依赖，配置mybatis（数据库连接信息） 编写SQL语句（注解/XML）  具体操作流程如下：   创建springboot文件：与springboot入门中的创建方法基本一致，注意要勾选Mybatis Framework和MySQL Driver依赖。   定义实际类：实际类要与数据库中user的字段保证一致，常见的几种类型对应：int-&gt;Integer，varchar-&gt;String，tinyint-&gt;Short，主要使用其包装类。同时声明相应的getset方法、构造器、toString方法。   在properties配置文件中加入以下内容，格式比较固定，url要根据相应的数据库名称确定，密码设定为自己的密码   1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatisspring.datasource.username=rootspring.datasource.password=1234  编写SQL语句（注解/XML）  123456@Mapper//在运行时，MyBatis会扫描这个接口，并为其生成一个实现类对象（代理对象），并交给IOC管理public interface UserMapper &#123;    //查询    @Select(&quot;select * from user&quot;)    public List&lt;User&gt; list();&#125;  单元测试  123456789101112@SpringBootTest//springboot整合单元测试的注解class SpringbootMybatisQuickstartApplicationTests &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testListUser() &#123;        List&lt;User&gt; userList = userMapper.list();        for (User user : userList) &#123;            System.out.println(user);        &#125;    &#125;&#125; 创建完成后的文件结构如图  配置SQL提示 在上边的SQL语句中，如果没有配置，那么就不会显示相应的提示，即使写错了也不会提醒，这对于开发是非常不利的。好在Idea中可以为其配置MySQL数据库连接。  选中SQL语句，右键，配置为MySQL语句 点击右侧边栏的数据库选项，点击加号，数据源选择MySQL，填写host、port、用户和密码、数据库  数据库连接池  数据库连接池是个容器，负责分配、管理数据库连接 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 能够释放空闲时间超过最大空闲时间的连接，避免因为没有释放连接引起的数据库连接遗漏 好处：资源重用 提升系统响应速度...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/06/03/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门">SpringBoot入门</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-06-03T14:30:09.000Z" title="发表于 2025-06-03 22:30:09">2025-06-03</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/">三层架构</a></span></div><div class="content">修改历史：  增加了Web入门的基础知识，完善了结构  SpringBoot入门 0.概述 本篇只是对springboot的基本使用的总结，学习视频-&gt;Day05-01. 请求响应-概述_哔哩哔哩_bilibili，使用postman进行调试。 1.Web入门 HTTP协议 概述 HTTP协议（HyperTextTransferProtocol），超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 特点：  TCP协议：面向连接，安全 基于请求-响应模型：一次请求对应一次响应 HTTP是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的  缺点：多次请求无法共享数据 优点：速度快    请求协议 请求数据包括三个部分： 请求行：请求数据第一行（请求方式，资源路径、协议） 请求头：第二行开始，格式key: value 请求体：POST请求，存放请求参数 两种请求方式对比：   请求方式-get：请求参数在请求行中，没有请求体。get请求大小是有限制的。   请求方式-post：请求参数在请求体中，post请求大小是没有限制的。   响应协议 响应数据包括三部分：   响应行：相应数据第一行（协议、状态码、描述）   响应头：key: value   响应体：存放响应数据   常见状态码：    状态码 描述     1xx 响应中   2xx 成功   3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理   4xx 客户端错误-处理发生错误，责任在客户端。如请求了不存在的资源、客户端未被授权、禁止访问   5xx 服务器错误-处理发生错误，责任在服务端。如程序抛出异常    目前主要了解：200 处理成功，404 请求资源不存在，500 服务器端异常 更多状态码见网站： 状态 | Status - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云 协议解析 服务器端要做的事情，一方面是要根据请求协议，解析浏览器发送的请求；另一方面是要根据响应协议，发送响应数据。 这种解析的工作较为固定，有不少Web服务器已经完成了这些工作，这样后端就只用关注业务逻辑的实现。常见的Web服务器有：Tomcat、IBM、jetty、WebLogic等 Tomcat服务器 具体内容暂时不用详细了解，SpringBoot已经内嵌了Tomcat服务器，所以不用专门下载。介绍在此省略 2.请求 此处请求的含义：后端接收来自浏览器端的请求指令，进行解析 简单参数 请求： GET指令：http://localhost:8080/simpleParam?name=miku&amp;age=16 POST指令：http://localhost:8080/simpleParam请求体：name=Miku&amp;age=16 Java代码： 原始方式： 12345678910//在原始的Web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(HttpServletRequest request) &#123;    String name = request.getParameter(&quot;name&quot;);//需要与请求参数的key保持一致    String ageStr = request.getParameter(&quot;age&quot;);//需要与请求参数的key保持一致    int age = Integer.parseInt(ageStr);    System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age);    return &quot;OK&quot;;&#125;//繁琐，并且需要进行手动类型转换 SpringBoot方式： 简单参数，参数名与形参列表名相同，定义形参即可接收参数 12345@RequestMapping(&quot;/simpleParam&quot;)public String simpleRequest(int age,String name) &#123;    System.out.println(name + &quot;:&quot; + age);    return...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/05/27/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="JavaSE-网络编程">JavaSE-网络编程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-05-27T10:21:16.000Z" title="发表于 2025-05-27 18:21:16">2025-05-27</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/JavaSE/">JavaSE</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/TCP/">TCP</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Socket/">Socket</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/URl/">URl</a></span></div><div class="content">网络编程 软件架构： CS架构：客户端-服务器 BS架构：浏览器-服务器 不过现在的很多软件都是一种混合开发，就是将CS架构和BS架构融合起来。 网络编程三要素 如何准确定位一台或多态主机：使用IP地址 如何定位主机上的特定的应用：使用端口号 如何可靠、高效地进行数据传输：规范通信协议 IP地址 IP地址：网络中的一台计算机设备做唯一编号 IP地址分类： 分类方式一： IPv4：占用4个字节，表示为a.b.c.d的形式，以点分十进制表示 IPv6：占用16个字节 分类方式二： 公网地址（万维网使用）和私网地址（局域网使用）192.168.开头的就是私有地址 本地回路地址：127.0.0.1 域名：便捷地记录ip地址 www.baidu.com kuoz.top 域名使用中通过DNS解析成IP再进行访问的 端口号 端口号可以唯一标识主机中的进程 不同的进程分配不同的端口号 范围：0~65535 网络通信协议 OSI模型：过于理想化，没能实现 TCP/IP：分为应用层、传输层、网络层、物理+数据链路层 InetAddress类 InetAddress类的一个实例就代表一个具体的ip地址 实例化方式： InetAddress getByName(String host) InetAddress getLocalHost() TCP协议和UDP协议 计算机网络的重要重要指示，在此处简要了解。 TCP的Socket网络编程 网络上具有唯一标识的IP地址和端口号的组合，唯一可识别的标识符套接字（Socket） 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void client() throws IOException &#123;    //创建Socket实例    int port = 8888;    InetAddress address = InetAddress.getByName(&quot;10.10.208.62&quot;);    Socket socket = new Socket(address, port);    //通过Socket创建输出流    OutputStream os = socket.getOutputStream();    //发送数据    os.write(&quot;嗨嗨嗨, 服务器我来辣!&quot;.getBytes());    //关闭Socket及相关流    os.close();    socket.close();&#125;@Testpublic void server() throws IOException &#123;    //创建serverSocket实例    int port = 8888;    ServerSocket serverSocket = new ServerSocket(port);    //接收来自于客户端的Socket    Socket socket = serverSocket.accept();    System.out.println(&quot;客户端连接成功，等待接收数据...&quot;);    System.out.println(&quot;收到了来自&quot;+socket.getInetAddress().getHostAddress()+&quot;的连接&quot;);    //通过Socket创建输入流    InputStream is = socket.getInputStream();    //读写过程    byte[] buffer = new byte[5];    ByteArrayOutputStream baos = new ByteArrayOutputStream();    int len;    while((len = is.read(buffer)) != -1) &#123;        //当byte太小时，这里中文会因为中间被截断而出乱码，通过baos来解决        //String message = new String(buffer, 0, len);        //解决方法        baos.write(buffer, 0, len);    &#125;    System.out.print(baos.toString());    System.out.print(&quot;\n接收完毕&quot;);    //关闭Socket和相关流    is.close();   ...</div></div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/holo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KuoZ</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CV-Elevation"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这是一个专属于我（KuoZ）的空间，它用来记录我的学习笔记、硬件或软件开发中的经验、还有吹水等等内容。本网站使用HEXO框架搭建。旧的两篇博客在博客园https://www.cnblogs.com/pulse1454</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/06/2025%E7%94%B5%E8%B5%9B%E5%B0%8F%E7%BB%93/" title="2025电赛小结">2025电赛小结</a><time datetime="2025-08-06T01:27:54.000Z" title="发表于 2025-08-06 09:27:54">2025-08-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/Redis%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" title="Redis之多级缓存">Redis之多级缓存</a><time datetime="2025-07-23T11:01:55.000Z" title="发表于 2025-07-23 19:01:55">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94Redis%E9%AB%98%E7%BA%A7%E7%AF%87/" title="分布式缓存——Redis高级篇">分布式缓存——Redis高级篇</a><time datetime="2025-07-20T16:55:44.000Z" title="发表于 2025-07-21 00:55:44">2025-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/18/Spring%E6%A1%86%E6%9E%B6/" title="Spring框架">Spring框架</a><time datetime="2025-07-18T08:53:50.000Z" title="发表于 2025-07-18 16:53:50">2025-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><time datetime="2025-07-16T07:11:44.000Z" title="发表于 2025-07-16 15:11:44">2025-07-16</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Filter/" style="font-size: 1.1em; color: #999">Filter</a> <a href="/tags/Intercetor/" style="font-size: 1.1em; color: #999">Intercetor</a> <a href="/tags/JavaSE/" style="font-size: 1.5em; color: #99a9bf">JavaSE</a> <a href="/tags/Maven/" style="font-size: 1.1em; color: #999">Maven</a> <a href="/tags/MySQL/" style="font-size: 1.1em; color: #999">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 1.1em; color: #999">Mybatis</a> <a href="/tags/Redis/" style="font-size: 1.3em; color: #99a1ac">Redis</a> <a href="/tags/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" style="font-size: 1.1em; color: #999">Redis 分布式缓存</a> <a href="/tags/Socket/" style="font-size: 1.1em; color: #999">Socket</a> <a href="/tags/Spring/" style="font-size: 1.1em; color: #999">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 1.1em; color: #999">SpringBoot</a> <a href="/tags/TCP/" style="font-size: 1.1em; color: #999">TCP</a> <a href="/tags/Token/" style="font-size: 1.1em; color: #999">Token</a> <a href="/tags/URl/" style="font-size: 1.1em; color: #999">URl</a> <a href="/tags/lua/" style="font-size: 1.1em; color: #999">lua</a> <a href="/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/" style="font-size: 1.1em; color: #999">三层架构</a> <a href="/tags/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/" style="font-size: 1.1em; color: #999">会话技术</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.3em; color: #99a1ac">随笔</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">6</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/05/">
            <span class="card-archive-list-date">
              五月 2025
            </span>
            <span class="card-archive-list-count">9</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/04/">
            <span class="card-archive-list-date">
              四月 2025
            </span>
            <span class="card-archive-list-count">5</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/03/">
            <span class="card-archive-list-date">
              三月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">24</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">58.2k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-08-24T07:27:21.481Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/miku2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By KuoZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>